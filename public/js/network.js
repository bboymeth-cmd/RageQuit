// network.js - autogenerated module from original game.js

// Track recently removed players to prevent re-adds within a short window (dedupe)
const recentlyRemoved = {};
const DEDUPE_WINDOW_MS = 500; // 500ms window to ignore duplicate adds

// Position update optimization
let lastPositionSent = Date.now();
const POSITION_UPDATE_RATE = 50; // Invia posizione ogni 50ms (20 volte al secondo)

// Auto-send position updates
function sendPositionUpdate() {
    const now = Date.now();
    if (socket && socket.connected && playerMesh && !playerStats.isDead) {
        if (now - lastPositionSent >= POSITION_UPDATE_RATE) {
            const animState = isSprinting ? 'run' : (moveForward || moveBackward || moveLeft || moveRight) ? 'walk' : 'idle';
            socket.emit('playerMovement', { 
                position: playerMesh.position, 
                rotation: { 
                    x: playerMesh.rotation.x, 
                    y: playerMesh.rotation.y, 
                    z: playerMesh.rotation.z 
                }, 
                animState: animState, 
                weaponMode: weaponMode,
                velocity: velocity // Invia anche velocità per predizione
            });
            lastPositionSent = now;
        }
    }
}

function initMultiplayer() {
            if (typeof io !== 'undefined') {
                // Prevent multiple initializations (double connections / duplicated handlers)
                if (typeof socket !== 'undefined' && socket && socket.connected) {
                    console.warn('initMultiplayer called but socket already connected');
                    return;
                }

                socket = io({ reconnection: true, transports: ['websocket', 'polling'] });
                socket.on('connect', () => {
                    console.log('TRACE: socket connected. socket.id=', socket.id, 'myId(before)=', myId);
                    document.getElementById('connection-status').innerText = "CONNESSO: " + myUsername;
                    myId = socket.id;
                    console.log('TRACE: myId set to', myId);
                    socket.emit('joinGame', { username: myUsername, teamColor: myTeamColor, gameMode: myGameMode, team: myTeam });
                    socket.emit('requestPosition');
                    
                    // Inizializza kill counter
                    playerKills[myId] = myKills;
                    updateKillCounter();
                    
                    // Start ping measurement
                    setInterval(() => {
                        const start = Date.now();
                        socket.emit('ping', start);
                    }, 2000); // Ogni 2 secondi
                });
                socket.on('pong', (timestamp) => {
                    currentPing = Date.now() - timestamp;
                    const pingEl = document.getElementById('ping-counter');
                    if (pingEl) {
                        pingEl.innerText = 'PING: ' + currentPing + 'ms';
                        pingEl.style.color = currentPing < 50 ? '#00ff00' : currentPing < 100 ? '#ffff00' : '#ff0000';
                    }
                });
                socket.on('disconnect', () => { document.getElementById('connection-status').innerText = "DISCONNESSO"; document.getElementById('connection-status').style.color = "red"; });
                socket.on('serverMsg', (msg) => { addToLog(msg, 'server-msg'); });
                socket.on('hitRejected', (data) => {
                    // Il server ha respinto l'hit per posizione non valida
                    console.warn('[HIT REJECTED] Target:', data.targetId, '- desync rilevato');
                    // Opzionale: mostra messaggio al player
                    // showFloatingText('MISS', camera.position, 0xff0000, 1000);
                });
                socket.on('chatMessage', (data) => {
                    if (typeof addChatMessage === 'function') {
                        addChatMessage(data.username, data.text, false);
                    }
                });
                socket.on('teamCounts', (counts) => {
                    if (typeof updateTeamCounts === 'function') {
                        updateTeamCounts(counts);
                    }
                });
                socket.on('forcePositionUpdate', () => { if (myId && !playerStats.isDead) { const animState = isSprinting ? 'run' : (moveForward || moveBackward) ? 'walk' : 'idle'; socket.emit('playerMovement', { position: playerMesh.position, rotation: { x: playerMesh.rotation.x, y: playerMesh.rotation.y, z: playerMesh.rotation.z }, animState: animState, weaponMode: weaponMode }); } });
                socket.on('currentPlayers', (players) => {
                    console.log('TRACE: received currentPlayers', Object.keys(players), 'myId=', myId, 'socket.id=', socket.id);
                    Object.keys(players).forEach((id) => {
                        // Defensive: ignore own id (use both myId and socket.id in case of timing differences)
                        if (id === myId || id === socket.id) return;
                        if (!otherPlayers[id]) addOtherPlayer(players[id]);
                    });
                });
                socket.on('newPlayer', (playerInfo) => { 
                    console.log('TRACE: newPlayer received id=', playerInfo && playerInfo.id, 'username=', playerInfo && playerInfo.username, 'myId=', myId);
                    addToLog(playerInfo.username + " è entrato!", "heal"); 
                    // Defensive: ignore if server accidentally broadcasts the joining player's own data
                    if (playerInfo.id === myId || playerInfo.id === socket.id) return;
                    // Skip if recently removed (dedupe window)
                    if (recentlyRemoved[playerInfo.id]) {
                        console.log('TRACE: skipping newPlayer for', playerInfo.id, '(recently removed)');
                        return;
                    }
                    if (!otherPlayers[playerInfo.id]) addOtherPlayer(playerInfo); 
                });
                socket.on('playerDisconnected', (id) => { if (otherPlayers[id]) addToLog(otherPlayers[id].username + " è uscito.", "kill"); removeOtherPlayer(id); });
                socket.on('updateUsername', (data) => { if (otherPlayers[data.id]) { otherPlayers[data.id].username = data.username; const oldLabel = otherPlayers[data.id].mesh.children.find(c => c.userData.isLabel); if (oldLabel) otherPlayers[data.id].mesh.remove(oldLabel); const newLabel = createPlayerLabel(data.username); newLabel.position.y = 14; newLabel.userData.isLabel = true; otherPlayers[data.id].mesh.add(newLabel); otherPlayers[data.id].mesh.userData.hpBar = newLabel.userData.hpBar; } });
                socket.on('playerMoved', (playerInfo) => { 
                    if (otherPlayers[playerInfo.id]) { 
                        const p = otherPlayers[playerInfo.id]; 
                        
                        // Se il giocatore era morto e si muove, significa che è respawnato
                        if (p.mesh.userData.isDead) {
                            p.mesh.userData.isDead = false;
                            p.mesh.visible = true;
                        }
                        
                        p.mesh.userData.targetPos = playerInfo.position; 
                        p.mesh.userData.targetRot = playerInfo.rotation; 
                        p.mesh.userData.animState = playerInfo.animState; 
                        if(p.mesh.userData.weaponMode !== playerInfo.weaponMode) { 
                            p.mesh.userData.weaponMode = playerInfo.weaponMode; 
                            updateOpponentWeaponVisuals(otherPlayers[playerInfo.id], playerInfo.weaponMode); 
                        } 
                    } 
                });
                
                socket.on('updateTeamColor', (data) => {
                    if (otherPlayers[data.id]) {
                        const newColor = data.teamColor || 0x2c3e50;
                        const armorMat = new THREE.MeshStandardMaterial({ color: newColor, metalness: 0.7 });
                        // Aggiorna il colore di tutti i componenti dell'armatura
                        otherPlayers[data.id].mesh.traverse(mesh => {
                            if (mesh.material && mesh !== otherPlayers[data.id].mesh) {
                                if (mesh.material.color && !mesh.userData.isLabel && mesh !== otherPlayers[data.id].weaponMeshes?.shield) {
                                    mesh.material = armorMat.clone();
                                }
                            }
                        });
                    }
                });

                socket.on('updateEnemyBlock', (data) => {
                    if (otherPlayers[data.id]) {
                        otherPlayers[data.id].mesh.userData.isBlocking = data.isBlocking;
                        updateEnemyShield(otherPlayers[data.id], data.isBlocking);
                    }
                });

                socket.on('remoteEffect', (data) => {
                    if (otherPlayers[data.id]) {
                        let color = 0xffffff;
                        if(data.type === 'heal') color = 0x00ff00;
                        else if(data.type === 'mana') color = 0x0000ff;
                        else if(data.type === 'stamina') color = 0xffff00;
                        
                        spawnParticles(otherPlayers[data.id].mesh.position, color, 15, 15, 0.4, false);
                        const light = new THREE.PointLight(color, 5, 20);
                        light.position.copy(otherPlayers[data.id].mesh.position).add(new THREE.Vector3(0,5,0));
                        scene.add(light);
                        setTimeout(() => scene.remove(light), 300);
                        
                        if(data.type === 'heal') playSound('heal', otherPlayers[data.id].mesh.position);
                    }
                });

                socket.on('remoteDamageTaken', (data) => {
                    if (data.id === myId) {
                        spawnParticles(playerMesh.position, 0xff0000, 5, 20, 0.5, false); 
                    } else if (otherPlayers[data.id]) { 
                        if (otherPlayers[data.id].mesh.userData.isDead) return;
                        spawnParticles(otherPlayers[data.id].mesh.position, 0xff0000, 5, 20, 0.5, false); 
                    } 
                });
                
                socket.on('playerHitResponse', (data) => {
                    const diff = -data.damage;
                    playerStats.hp = Math.max(0, playerStats.hp + diff); 
                    updateUI(); 
                    if (diff < 0) {
                        flashScreen('red'); 
                    }
                    // Controlla se il player è morto
                    if (playerStats.hp <= 0 && !playerStats.isDead) {
                        playerStats.isDead = true;
                        document.getElementById('message').innerHTML = "SEI STATO SCONFITTO<br><span style='font-size:16px'>Premi RESPAWN</span>"; 
                        document.getElementById('message').style.display = "block";
                        document.exitPointerLock();
                        spawnParticles(playerMesh.position, 0xff0000, 50, 50, 1.0, true);
                        playSound('death');
                    }
                });

                socket.on('enemyAttacked', (data) => { 
                    if (otherPlayers[data.id]) { 
                        if (data.type === 'melee') { otherPlayers[data.id].mesh.userData.isAttacking = true; otherPlayers[data.id].mesh.userData.attackTimer = 0; playSound('swing_heavy', otherPlayers[data.id].mesh.position); } 
                        else if (data.type === 'whirlwind') {
                            otherPlayers[data.id].mesh.userData.isWhirlwinding = true;
                            const remoteDur = typeof data.duration === 'number' ? data.duration : 500;
                            setTimeout(() => { if(otherPlayers[data.id]) otherPlayers[data.id].mesh.userData.isWhirlwinding = false; }, remoteDur);
                            playSound('whirlwind', otherPlayers[data.id].mesh.position);
                        } 
                        else if (data.type === 'spikes') { 
                            if (data.targetId === myId) { spawnStoneSpikes(playerMesh, true); } 
                            else if (otherPlayers[data.targetId]) { spawnStoneSpikes(otherPlayers[data.targetId].mesh, true); } 
                            else { spawnStoneSpikes(data.origin, false); } 
                        } 
                        else { spawnEnemyProjectile(data.origin, data.direction, data.type); } 
                    } 
                });
                
                socket.on('playerPushed', (data) => { 
                    if (data.forceY) { velocity.y = data.forceY; } 
                    if (data.forceVec) { velocity.add(new THREE.Vector3(data.forceVec.x, data.forceVec.y, data.forceVec.z)); }
                    
                    if (!data.forceY && !data.forceVec && data.pushOrigin) { 
                        const origin = new THREE.Vector3(data.pushOrigin.x, data.pushOrigin.y, data.pushOrigin.z); 
                        const dir = new THREE.Vector3().subVectors(playerMesh.position, origin).normalize(); 
                        velocity.add(dir.multiplyScalar(SETTINGS.pushForce)); velocity.y += 100; 
                    } 
                    playerStats.isFalling = true; canJump = false; playerMesh.position.y += 0.5; 
                });

                socket.on('updateHealth', (data) => { 
                    if (data.id === myId) { 
                        playerStats.hp = data.hp; updateUI(); 
                    } else if (otherPlayers[data.id]) { 
                        updateEnemyHealthBar(otherPlayers[data.id], data.hp); 
                    } 
                });
                
                socket.on('playerDied', (data) => { 
                    if (data.id === myId) { 
                        playerStats.isDead = true; playerStats.hp = 0; 
                        document.getElementById('message').innerHTML = "SEI STATO SCONFITTO<br><span style='font-size:16px'>Premi RESPAWN</span>"; 
                        document.getElementById('message').style.display = "block"; document.exitPointerLock(); 
                        spawnParticles(playerMesh.position, 0xff0000, 50, 50, 1.0, true);
                        playerMesh.visible = false;
                    } else if(otherPlayers[data.id]) { 
                        otherPlayers[data.id].mesh.userData.isDead = true;
                        otherPlayers[data.id].mesh.visible = false; // Nascondi invece di rimuovere
                        addToLog(otherPlayers[data.id].username + " eliminato!", "kill"); 
                        spawnParticles(otherPlayers[data.id].mesh.position, 0xff0000, 50, 50, 1.0, true);
                        // Non rimuovere il giocatore - sar\u00e0 rimostrato quando respawna
                    }
                    
                    // Incrementa kill counter per il killer
                    if (data.killerId && data.killerId === myId) {
                        const victimTeam = otherPlayers[data.id]?.team || null;
                        incrementKill(myId, myTeam);
                        addFloatingText(playerMesh.position.clone().add(new THREE.Vector3(0, 12, 0)), '☠️ KILL!', 0xff0000, 1.5);
                    } else if (data.killerId && otherPlayers[data.killerId]) {
                        const killerTeam = otherPlayers[data.killerId].team || null;
                        incrementKill(data.killerId, killerTeam);
                    }
                });
            } else { console.warn("Modalità Offline"); document.getElementById('connection-status').innerText = "OFFLINE"; }
        }

function addOtherPlayer(info) {
    if (!info || !info.id) return;
    if (recentlyRemoved[info.id]) return;
    if (otherPlayers[info.id]) removeOtherPlayer(info.id);

    // Placeholder base (semplice box) + strutture richieste dal codice esistente
    const mesh = new THREE.Group();
    const placeholder = new THREE.Mesh(new THREE.BoxGeometry(5,10,5), new THREE.MeshStandardMaterial({color: info.teamColor || 0xaa3333}));
    placeholder.position.y = 5; mesh.add(placeholder);
    // Limbs placeholder
    const armL = new THREE.Group(); const armR = new THREE.Group(); const legL = new THREE.Group(); const legR = new THREE.Group();
    const bootL = new THREE.Group(); const bootR = new THREE.Group(); const head = new THREE.Group(); const torso = placeholder;
    mesh.add(armL); mesh.add(armR); mesh.add(legL); mesh.add(legR); mesh.add(bootL); mesh.add(bootR); mesh.add(head);
    armL.position.set(-3,8,0); armR.position.set(3,8,0);
    // Weapon placeholders
    const staff = new THREE.Group(); staff.visible=false; mesh.add(staff);
    const sword = new THREE.Group(); sword.visible=false; mesh.add(sword);
    const bow = new THREE.Group(); bow.visible=false; mesh.add(bow);
    const shield = new THREE.Group(); shield.visible=false; mesh.add(shield);

    mesh.position.set(info.position.x, info.position.y, info.position.z);
    const label = createPlayerLabel(info.username); label.position.y = 14; label.userData.isLabel = true; mesh.add(label); mesh.userData.hpBar = label.userData.hpBar;
    mesh.userData.isDead = false; mesh.userData.weaponMode = info.weaponMode || 'melee';
    scene.add(mesh);

    otherPlayers[info.id] = {
        username: info.username,
        team: info.team || null,
        mesh,
        limbs:{armL, armR, legL, legR, bootL, bootR, head, torso},
        weaponMeshes:{staff, sword, bow, shield},
        isAttacking:false, attackTimer:0, isWhirlwinding:false, isDead:false,
        lastStepPos:new THREE.Vector3(),
        needsKnightUpgrade:true,
        mixer:null, animations:null, knightModel:null
    };

    // Carica modello Knight asincrono
    const loader = new THREE.GLTFLoader();
    loader.load('./models/Knight Met.glb', (gltf) => {
        const teamColor = info.teamColor || 0x2c3e50;
        const knightModel = gltf.scene.clone(true);
        knightModel.scale.set(10,10,10);
        knightModel.rotation.y = 0;
        knightModel.traverse(c => { if (c.isMesh && c.material) { c.material = c.material.clone(); c.material.color.setHex(teamColor); c.castShadow=true; c.receiveShadow=true; }});
        mesh.add(knightModel);
        // Rimuove box placeholder
        mesh.remove(placeholder);
        const mixer = new THREE.AnimationMixer(knightModel);
        const animations = {};
        if (gltf.animations && gltf.animations.length) {
            gltf.animations.forEach(clip => {
                const lname = clip.name.toLowerCase();
                const action = mixer.clipAction(clip);
                if (lname.includes('idle') && !animations.idle) { action.setLoop(THREE.LoopRepeat); animations.idle = action; }
                else if (lname.includes('walk') && !animations.walk) { action.setLoop(THREE.LoopRepeat); animations.walk = action; }
                else if (lname.includes('run') && !animations.run) { action.setLoop(THREE.LoopRepeat); animations.run = action; }
                else if (lname.includes('attack') && !animations.attack) { action.setLoop(THREE.LoopOnce); action.clampWhenFinished = true; animations.attack = action; }
                else if (lname.includes('block') && !animations.block) { action.setLoop(THREE.LoopRepeat); animations.block = action; }
            });
        }
        if (animations.idle) animations.idle.play();
        const p = otherPlayers[info.id];
        if (p) {
            p.knightModel = knightModel;
            p.mixer = mixer;
            p.animations = animations;
            p.needsKnightUpgrade = false;
            mesh.userData.mixer = mixer;
            mesh.userData.animations = animations;
            mesh.userData.currentAnim = 'idle';
            console.log('[NETWORK] Knight model loaded for remote player', p.username);
        }
    }, (xhr)=>{}, (err)=>{
        console.error('[NETWORK] Knight load error remote player', info.username, err);
        otherPlayers[info.id].needsKnightUpgrade = false; // evita retry loop
    });
}

function createPlayerLabel(name) {
            const group = new THREE.Group();
            const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d'); canvas.width = 256; canvas.height = 64;
            ctx.fillStyle = "rgba(0,0,0,0.5)"; ctx.fillRect(0,0,256,64); ctx.font = "bold 32px Arial"; ctx.fillStyle = "white"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(name, 128, 32);
            const tex = new THREE.CanvasTexture(canvas); const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex })); sprite.scale.set(6, 1.5, 1); group.add(sprite);
            const bg = new THREE.Mesh(new THREE.PlaneGeometry(5, 0.5), new THREE.MeshBasicMaterial({ color: 0x330000 })); bg.position.y = 1.2; group.add(bg);
            const fg = new THREE.Mesh(new THREE.PlaneGeometry(5, 0.5), new THREE.MeshBasicMaterial({ color: 0x00ff00 })); fg.position.y = 1.2; fg.position.z = 0.01; fg.geometry.translate(2.5, 0, 0); fg.position.x = -2.5; group.add(fg);
            group.userData.hpBar = fg; return group;
        }

function updateEnemyHealthBar(playerObj, hp) { 
            if(playerObj && playerObj.mesh.userData.hpBar) { 
                const scale = Math.max(0, hp / 100); 
                playerObj.mesh.userData.hpBar.scale.x = scale; 
                playerObj.mesh.userData.hpBar.material.color.setHex(scale > 0.5 ? 0x00ff00 : (scale > 0.2 ? 0xffa500 : 0xff0000)); 
            } 
        }

function removeOtherPlayer(id) { 
            if (otherPlayers[id]) { 
                scene.remove(otherPlayers[id].mesh); 
                delete otherPlayers[id];
                // Mark as recently removed to prevent re-add within dedupe window
                recentlyRemoved[id] = Date.now();
                setTimeout(() => { delete recentlyRemoved[id]; }, DEDUPE_WINDOW_MS);
            } 
        }

function updateOpponentWeaponVisuals(p, mode) {
            if (p.weaponMeshes) {
                p.weaponMeshes.staff.visible = (mode === 'ranged');
                p.weaponMeshes.sword.visible = (mode === 'melee');
                p.weaponMeshes.bow.visible = (mode === 'bow');
            }
        }

function updateEnemyShield(p, blocking) {
            if(p.weaponMeshes && p.weaponMeshes.shield) {
                p.weaponMeshes.shield.visible = blocking;
                if(blocking) {
                    p.limbs.armL.rotation.set(-Math.PI/2, 0, Math.PI/2);
                } else {
                    p.limbs.armL.rotation.set(0,0,0);
                }
            }
        }

function checkLogin() {
            // Funzione obsoleta - il login è gestito dal nuovo menu
            const savedName = localStorage.getItem('ragequit_username');
            if (savedName) { 
                myUsername = savedName; 
            }
        }

