// network.js - autogenerated module from original game.js

// Track recently removed players to prevent re-adds within a short window (dedupe)
const recentlyRemoved = {};
const DEDUPE_WINDOW_MS = 500; // 500ms window to ignore duplicate adds

// Position update optimization
let lastPositionSent = Date.now();
const POSITION_UPDATE_RATE = 33; // Increased to 30Hz (33ms) for smoother FPS movement

// Auto-send position updates
function sendPositionUpdate() {
    const now = Date.now();
    if (socket && socket.connected && playerMesh && !playerStats.isDead) {
        if (now - lastPositionSent >= POSITION_UPDATE_RATE) {
            // FIX: Broadcast actual speed state (walk if cooldown) and JUMP
            const animState = (!canJump) ? 'jump' : (isSprinting && !sprintCooldown) ? 'run' : (moveForward || moveBackward || moveLeft || moveRight) ? 'walk' : 'idle';
            socket.emit('playerMovement', {
                position: playerMesh.position,
                rotation: {
                    x: playerMesh.rotation.x,
                    y: playerMesh.rotation.y,
                    z: playerMesh.rotation.z
                },
                animState: animState,
                weaponMode: weaponMode,
                velocity: velocity, // Invia anche velocità per predizione
                ping: currentPing || 0
            });
            lastPositionSent = now;
        }
    }
}

function initMultiplayer() {
    if (typeof io !== 'undefined') {
        // Prevent multiple initializations (double connections / duplicated handlers)
        if (typeof socket !== 'undefined' && socket && socket.connected) {
            console.warn('initMultiplayer called but socket already connected');
            return;
        }

        socket = io({ reconnection: true, transports: ['websocket'] }); // Force WebSocket (No Polling overhead)
        socket.on('connect', () => {
            console.log('TRACE: socket connected. socket.id=', socket.id, 'myId(before)=', myId);
            document.getElementById('connection-status').innerText = "CONNECTED: " + myUsername;
            myId = socket.id;
            console.log('TRACE: myId set to', myId);
            socket.emit('joinGame', { username: myUsername, teamColor: myTeamColor, gameMode: myGameMode, team: myTeam });
            socket.emit('requestPosition'); // Chiedi spawn point immediato

            // Inizializza kill counter
            playerKills[myId] = myKills;
            updateKillCounter();

            // Start ping measurement
            setInterval(() => {
                const start = Date.now();
                socket.emit('ping', start);
            }, 2000); // Ogni 2 secondi
        });
        socket.on('pong', (timestamp) => {
            currentPing = Date.now() - timestamp;
            const pingEl = document.getElementById('ping-counter');
            if (pingEl) {
                pingEl.innerText = 'PING: ' + currentPing + 'ms';
                pingEl.style.color = currentPing < 50 ? '#00ff00' : currentPing < 100 ? '#ffff00' : '#ff0000';
            }
        });
        socket.on('disconnect', () => { document.getElementById('connection-status').innerText = "DISCONNECTED"; document.getElementById('connection-status').style.color = "red"; });
        socket.on('serverMsg', (msg) => { addToLog(msg, 'server-msg'); });
        socket.on('hitRejected', (data) => {
            // Il server ha respinto l'hit per posizione non valida
            console.warn('[HIT REJECTED] Target:', data.targetId, '- desync rilevato');
            // Opzionale: mostra messaggio al player
            // showFloatingText('MISS', camera.position, 0xff0000, 1000);
        });
        socket.on('chatMessage', (data) => {
            if (typeof addChatMessage === 'function') {
                addChatMessage(data.username, data.text, false, data.id);
            }
        });
        socket.on('teamCounts', (counts) => {
            if (typeof updateTeamCounts === 'function') {
                updateTeamCounts(counts);
            }
        });
        socket.on('forcePositionUpdate', () => { if (myId && !playerStats.isDead) { const animState = isSprinting ? 'run' : (moveForward || moveBackward) ? 'walk' : 'idle'; socket.emit('playerMovement', { position: playerMesh.position, rotation: { x: playerMesh.rotation.x, y: playerMesh.rotation.y, z: playerMesh.rotation.z }, animState: animState, weaponMode: weaponMode }); } });
        socket.on('currentPlayers', (players) => {
            console.log('TRACE: received currentPlayers', Object.keys(players), 'myId=', myId, 'socket.id=', socket.id);

            // OPTIMIZATION: Process players in batches to prevent "Login Freeze"
            // Use a simple Interval to add players one by one
            const playerIds = Object.keys(players);
            let index = 0;

            function processNextBatch() {
                const start = performance.now();
                while (index < playerIds.length && performance.now() - start < 5) { // 5ms budget per frame
                    const id = playerIds[index++];
                    if (id !== myId && id !== socket.id) {
                        if (!otherPlayers[id]) addOtherPlayer(players[id]);
                    }
                }

                if (index < playerIds.length) {
                    requestAnimationFrame(processNextBatch); // Continue next frame
                } else {
                    console.log('[NETWORK] All players loaded.');
                }
            }

            processNextBatch();
        });
        socket.on('newPlayer', (playerInfo) => {
            console.log('TRACE: newPlayer received id=', playerInfo && playerInfo.id, 'username=', playerInfo && playerInfo.username, 'myId=', myId);

            // CRITICAL: NEVER create your own player in otherPlayers
            if (playerInfo.id === myId || playerInfo.id === socket.id) {
                console.log('TRACE: BLOCKED newPlayer for self', playerInfo.id);
                return;
            }

            // Skip if recently removed (dedupe window)
            if (recentlyRemoved[playerInfo.id]) {
                console.log('TRACE: skipping newPlayer for', playerInfo.id, '(recently removed)');
                return;
            }

            addToLog(playerInfo.username + " joined!", "system-info");

            if (!otherPlayers[playerInfo.id]) {
                addOtherPlayer(playerInfo);
            } else {
                // Player già esistente - assicura che sia visibile (potrebbe essere stato nascosto alla morte)
                const p = otherPlayers[playerInfo.id];
                p.mesh.visible = true;
                p.mesh.userData.isDead = false;
                updateEnemyHealthBar(p, playerInfo.hp || 100);
                console.log('TRACE: Player', playerInfo.id, 'già esistente - forzata visibilità');

                // SAFETY: Ensure low poly parts are hidden on respawn/re-join
                if (p.limbs) {
                    if (p.limbs.torso) p.limbs.torso.visible = false;
                    if (p.limbs.chest) p.limbs.chest.visible = false;
                    if (p.limbs.legL) p.limbs.legL.visible = false;
                    if (p.limbs.legR) p.limbs.legR.visible = false;
                    if (p.limbs.armL) p.limbs.armL.visible = false;
                    if (p.limbs.armR) p.limbs.armR.visible = false;
                    if (p.limbs.head) p.limbs.head.visible = false;
                }
            }
        });
        socket.on('playerDisconnected', (id) => { if (otherPlayers[id]) addToLog(otherPlayers[id].username + " left.", "system-info"); removeOtherPlayer(id); });

        socket.on('updateTeamScores', (scores) => {
            if (scores) {
                // Update global variable in game.js
                if (typeof teamKills !== 'undefined') {
                    teamKills.red = scores.red || 0;
                    teamKills.black = scores.black || 0;
                    teamKills.green = scores.green || 0;
                    teamKills.purple = scores.purple || 0;

                    if (typeof updateKillCounter === 'function') {
                        updateKillCounter();
                    }
                }
            }
        });

        socket.on('updateUsername', (data) => { if (otherPlayers[data.id]) { otherPlayers[data.id].username = data.username; const oldLabel = otherPlayers[data.id].mesh.children.find(c => c.userData.isLabel); if (oldLabel) otherPlayers[data.id].mesh.remove(oldLabel); const newLabel = createPlayerLabel(data.username); newLabel.position.y = 14; newLabel.userData.isLabel = true; otherPlayers[data.id].mesh.add(newLabel); otherPlayers[data.id].mesh.userData.hpBar = newLabel.userData.hpBar; } });
        socket.on('worldUpdate', (updates) => {
            if (!Array.isArray(updates)) return;

            updates.forEach(playerInfo => {
                if (playerInfo.id === myId || playerInfo.id === socket.id) return;

                if (otherPlayers[playerInfo.id]) {
                    const p = otherPlayers[playerInfo.id];

                    // 1. LAGG COMPENSATION: Buffer Position
                    if (typeof window.updatePositionBuffer === 'function') {
                        const pos = new THREE.Vector3(playerInfo.position.x, playerInfo.position.y, playerInfo.position.z);
                        // FIX: Use CLIENT time for interpolation to avoid Server/Client clock skew on Render.com
                        // Using server timestamp caused massive delays if server clock was behind/ahead.
                        const time = Date.now();
                        window.updatePositionBuffer(playerInfo.id, pos, time);
                    }

                    // 2. Respawn / Visibility Check
                    if (p.mesh.userData.isDead) {
                        p.mesh.userData.isDead = false;
                        p.mesh.visible = true;

                        // SAFETY: Ensure low poly parts are hidden on respawn
                        if (p.limbs) {
                            if (p.limbs.torso) p.limbs.torso.visible = false;
                            if (p.limbs.chest) p.limbs.chest.visible = false;
                            if (p.limbs.legL) p.limbs.legL.visible = false;
                            if (p.limbs.legR) p.limbs.legR.visible = false;
                            if (p.limbs.armL) p.limbs.armL.visible = false;
                            if (p.limbs.armR) p.limbs.armR.visible = false;
                            if (p.limbs.head) p.limbs.head.visible = false;
                        }
                    }

                    // 3. Update Rotation & State (Direct set, smoothed in render loop)
                    // Note: We don't set targetPos anymore because we use the buffer!
                    // But we keep targetPos logic for rotation or if buffer missing?
                    // Let's remove targetPos setting to enforce buffer usage.

                    p.mesh.userData.targetRot = playerInfo.rotation;
                    p.mesh.userData.animState = playerInfo.animState;

                    if (p.mesh.userData.weaponMode !== playerInfo.weaponMode) {
                        p.mesh.userData.weaponMode = playerInfo.weaponMode;
                        updateOpponentWeaponVisuals(otherPlayers[playerInfo.id], playerInfo.weaponMode);
                    }
                }
            });
        });

        socket.on('scoreboardUpdate', (stats) => {
            if (!stats) return;

            // Store global map of stats for UI usage
            // We can attach it to `otherPlayers` or a global `playerStatsCache`
            if (!window.playerStatsCache) window.playerStatsCache = {};

            Object.keys(stats).forEach(id => {
                const data = stats[id];
                window.playerStatsCache[id] = data;

                // Also update local objects if they exist
                if (otherPlayers[id]) {
                    otherPlayers[id].stats = data;
                }

                // If it's me
                if (id === myId) {
                    // Verify local sync (optional)
                    // console.log(`My Ping: ${data.latency}, K/D: ${data.kills}/${data.deaths}`);
                    // Update floating ping counter
                    if (data.latency > 0) {
                        const pingEl = document.getElementById('ping-counter');
                        if (pingEl) {
                            pingEl.innerText = 'PING: ' + data.latency + 'ms';
                            pingEl.style.color = data.latency < 50 ? '#00ff00' : data.latency < 100 ? '#ffff00' : '#ff0000';
                        }
                    }
                }
            });

            // Update Scoreboard UI if open
            if (document.getElementById('scoreboard').style.display !== 'none') {
                if (typeof window.updateScoreboard === 'function') window.updateScoreboard();
            }
        });

        socket.on('updateTeamColor', (data) => {
            if (otherPlayers[data.id]) {
                const newColor = data.teamColor || 0x2c3e50;
                const armorMat = new THREE.MeshStandardMaterial({ color: newColor, metalness: 0.7 });
                // Aggiorna il colore di tutti i componenti dell'armatura
                otherPlayers[data.id].mesh.traverse(mesh => {
                    if (mesh.material && mesh !== otherPlayers[data.id].mesh) {
                        if (mesh.material.color && !mesh.userData.isLabel && mesh !== otherPlayers[data.id].weaponMeshes?.shield) {
                            mesh.material = armorMat.clone();
                        }
                    }
                });
            }
        });

        socket.on('updateEnemyBlock', (data) => {
            if (otherPlayers[data.id]) {
                otherPlayers[data.id].mesh.userData.isBlocking = data.isBlocking;
                updateEnemyShield(otherPlayers[data.id], data.isBlocking);
            }
        });

        socket.on('remoteEffect', (data) => {
            if (otherPlayers[data.id]) {
                let color = 0xffffff;
                if (data.type === 'heal') {
                    color = 0x00ff00;
                    color = 0x00ff00;
                    if (typeof spawnHealCylinder === 'function') spawnHealCylinder(otherPlayers[data.id].mesh);
                    // Spawn beam if coordinates provided
                    if (data.origin && data.target && typeof spawnHealBeam === 'function') {
                        const start = new THREE.Vector3(data.origin.x, data.origin.y, data.origin.z);
                        const end = new THREE.Vector3(data.target.x, data.target.y, data.target.z);
                        spawnHealBeam(start, end);
                    }
                } else if (data.type === 'mana') color = 0x0000ff;
                else if (data.type === 'stamina') color = 0xff0000; // Red for Stamina->HP
                else if (data.type === 'stamina_gain') color = 0xffff00; // Yellow for Mana->Stamina

                // Spawn visual effect on enemy
                const p = otherPlayers[data.id];
                const spawnPos = p.mesh.position.clone().add(new THREE.Vector3(0, 5, 0));

                // Particles
                spawnParticles(spawnPos, color, 15, 15, 0.4, false);

                // Light
                const light = new THREE.PointLight(color, 5, 20);
                light.position.copy(spawnPos);
                scene.add(light);

                // Fade out light
                let intensity = 5;
                const fade = setInterval(() => {
                    intensity -= 0.2;
                    light.intensity = intensity;
                    if (intensity <= 0) {
                        clearInterval(fade);
                        scene.remove(light);
                    }
                }, 50);

                if (data.type === 'heal' || data.type.includes('stamina') || data.type === 'mana') {
                    playSound('heal', p.mesh.position);
                }

                // Trigger powerup animation
                if (typeof playEnemyKnightAnimation === 'function') {
                    // Set flag to prevent immediate override
                    p.mesh.userData.isPoweringUp = true;
                    p.mesh.userData.powerupTimer = 0;

                    // console.log(`[NET-DEBUG] Triggering powerup for ${data.id} (Effect: ${data.type})`);
                    playEnemyKnightAnimation(p, 'powerup', true);
                }
            }
        });
        socket.on('remoteDamageTaken', (data) => {
            if (data.id === myId) {
                spawnParticles(playerMesh.position, 0xff0000, 5, 20, 0.5, false);
            } else if (otherPlayers[data.id]) {
                if (otherPlayers[data.id].mesh.userData.isDead) return;
                spawnParticles(otherPlayers[data.id].mesh.position, 0xff0000, 5, 20, 0.5, false);
            }
        });

        socket.on('playerHitResponse', (data) => {
            // CRITICAL FIX: NON modificare HP qui! Il server invia già updateHealth con HP corretto.
            // playerHitResponse serve SOLO per feedback visivo locale (flash screen, particles, etc)

            console.log(`[PLAYER HIT] Ricevuto danno: ${data.damage}, Bloccato: ${data.isBlocking}`);

            // Effetti visivi differenziati se BLOCK o danno normale
            if (data.isBlocking) {
                // FEEDBACK per BLOCCO
                console.log(`[BLOCK] Danno parato! Danno ridotto: ${Math.round(data.damage)}`);

                // Testo "BLOCK" prominente
                createFloatingText(playerMesh.position.clone().add(new THREE.Vector3(0, 10, 0)), "BLOCK!", "#00aaff");

                // Flash schermo blu (invece di rosso)
                flashScreen('blue');

                // Particelle blu/argento per indicare blocco
                spawnParticles(playerMesh.position, 0x00aaff, 15, 40, 0.7, false);

                // Suono di blocco metallico
                playSound('block');

                // Log nella chat
                addToLog(`Attack BLOCKED! (${Math.round(data.damage)} damage mitigated)`, "block-success");

            } else if (data.damage > 0) {
                // FEEDBACK per DANNO NORMALE (non bloccato)

                // Flash schermo rosso
                flashScreen('red');

                // Particelle di sangue
                spawnParticles(playerMesh.position, 0xff0000, 10, 30, 0.6, false);

                // Testo floating con danno
                createFloatingText(playerMesh.position.clone().add(new THREE.Vector3(0, 8, 0)), `-${Math.round(data.damage)}`, "#ff0000");

                // Suono di impatto
                playSound('hit');

                // Log nella chat
                addToLog(`You took ${Math.round(data.damage)} damage!`, "damage-taken");
            } else if (data.damage < 0) {
                // FEEDBACK per CURA (danno negativo)
                const healAmount = Math.abs(Math.round(data.damage));

                // Flash schermo verde
                flashScreen('green');

                // Particelle verdi
                spawnParticles(playerMesh.position, 0x00ff00, 10, 30, 0.6, false);

                // Testo +20
                createFloatingText(playerMesh.position.clone().add(new THREE.Vector3(0, 8, 0)), `+${healAmount}`, "#00ff00");

                // Suono heal
                playSound('heal');

                addToLog(`You were healed for ${healAmount} HP!`, "heal");
            }

            // NOTE: La morte viene gestita in updateHealth quando HP <= 0
            // Non controlliamo playerStats.hp <= 0 qui perché non abbiamo ancora l'HP aggiornato dal server
        });

        socket.on('enemyAttacked', (data) => {
            if (otherPlayers[data.id]) {
                if (data.type === 'melee') {
                    otherPlayers[data.id].mesh.userData.isAttacking = true;
                    otherPlayers[data.id].mesh.userData.attackTimer = 0;
                    playSound('swing_heavy', otherPlayers[data.id].mesh.position);
                    if (typeof playEnemyKnightAnimation === 'function') {
                        // console.log(`[NET-DEBUG] Triggering attack for ${data.id} (Melee)`);
                        playEnemyKnightAnimation(otherPlayers[data.id], 'attack', true, true); // Force restart
                    }
                }
                else if (data.type === 'whirlwind') {
                    otherPlayers[data.id].mesh.userData.isWhirlwinding = true;
                    setTimeout(() => { if (otherPlayers[data.id]) otherPlayers[data.id].mesh.userData.isWhirlwinding = false; }, 500);
                    playSound('whirlwind', otherPlayers[data.id].mesh.position);
                    playSound('whirlwind', otherPlayers[data.id].mesh.position);
                    if (typeof playEnemyKnightAnimation === 'function') {
                        // console.log(`[NET-DEBUG] Triggering whirlwind for ${data.id}`);
                        playEnemyKnightAnimation(otherPlayers[data.id], 'whirlwind', true, true); // Force restart
                    }
                }
                else if (data.type === 'spikes') {
                    if (data.targetId === myId) { spawnStoneSpikes(playerMesh, true); }
                    else if (otherPlayers[data.targetId]) { spawnStoneSpikes(otherPlayers[data.targetId].mesh, true); }
                    else { spawnStoneSpikes(data.origin, false); }
                    // Spikes cast -> Cast animation
                    otherPlayers[data.id].mesh.userData.isAttacking = true;
                    otherPlayers[data.id].mesh.userData.attackTimer = 0;

                    if (typeof playEnemyKnightAnimation === 'function') playEnemyKnightAnimation(otherPlayers[data.id], 'cast', true);
                }
                else {
                    // Projectiles (Magic Missile, Push, Fireball, Arrow) -> Cast animation
                    spawnEnemyProjectile(data.origin, data.direction, data.type);

                    // Set flag to prevent immediate override
                    otherPlayers[data.id].mesh.userData.isAttacking = true;
                    otherPlayers[data.id].mesh.userData.attackTimer = 0;

                    if (typeof playEnemyKnightAnimation === 'function') playEnemyKnightAnimation(otherPlayers[data.id], 'cast', true, true);
                }
            }
        });

        socket.on('playerStartCasting', (data) => {
            if (otherPlayers[data.id]) {
                const p = otherPlayers[data.id];
                console.log(`[NET] ${p.username} started casting (isHoldingSpell=true)`);
                p.mesh.userData.isHoldingSpell = true;
                p.mesh.userData.isCasting = true;
                p.mesh.userData.castingType = data.type;

                // Play bow reload sound
                if (data.type === 'bow') {
                    playSound('bow_reload', p.mesh.position);
                }

                // TRIGGER VISUAL SPHERE
                if (typeof startCastingEffect === 'function') {
                    startCastingEffect(p, data.type);
                }

                // Trigger animation
                if (typeof playEnemyKnightAnimation === 'function') {
                    playEnemyKnightAnimation(p, 'castHold', false);
                }
            }
        });

        socket.on('playerStopCasting', (data) => {
            if (otherPlayers[data.id]) {
                // console.log(`[NET] ${otherPlayers[data.id].username} stopped casting`);
                otherPlayers[data.id].mesh.userData.isHoldingSpell = false;
                // Non forzare idle qui, perché subito dopo arriverà 'enemyAttacked' con 'cast'
                // Ma se il cast è stato annullato, tornerà idle grazie al fix T-Pose o al prossimo update

                // REMOVE VISUAL SPHERE
                if (typeof stopCastingEffect === 'function') {
                    stopCastingEffect(otherPlayers[data.id]);
                }
            }
        });

        socket.on('playerPushed', (data) => {
            if (data.forceY) { velocity.y = data.forceY; }
            if (data.forceVec) { velocity.add(new THREE.Vector3(data.forceVec.x, data.forceVec.y, data.forceVec.z)); }

            if (!data.forceY && !data.forceVec && data.pushOrigin) {
                const origin = new THREE.Vector3(data.pushOrigin.x, data.pushOrigin.y, data.pushOrigin.z);
                const dir = new THREE.Vector3().subVectors(playerMesh.position, origin).normalize();
                velocity.add(dir.multiplyScalar(SETTINGS.pushForce)); velocity.y += 100;
            }
            playerStats.isFalling = true; canJump = false; playerMesh.position.y += 0.5;
        });

        socket.on('updateHealth', (data) => {
            if (data.id === myId) {
                // FIX: Il server è la fonte di verità per l'HP
                playerStats.hp = data.hp;
                updateUI();
                console.log(`[HP SYNC] Il mio HP aggiornato dal server: ${data.hp}`);

                // CRITICAL: Se HP = 0, aspetta playerDied dal server (non gestiamo morte qui)
                // playerDied arriverà subito dopo e gestirà animazione/respawn
            } else if (otherPlayers[data.id]) {
                // FIX: Inizializza maxHp se non esiste
                if (!otherPlayers[data.id].maxHp) otherPlayers[data.id].maxHp = 100;

                // CRITICAL: Salva HP vecchio PRIMA di aggiornare per logging
                const oldHp = otherPlayers[data.id].hp || 100;
                const damage = oldHp - data.hp;

                // Aggiorna HP
                otherPlayers[data.id].hp = data.hp;
                updateEnemyHealthBar(otherPlayers[data.id], data.hp);
                console.log(`[HP SYNC] HP di ${otherPlayers[data.id].username}: ${oldHp} → ${data.hp} (danno: ${damage})`);
            }
        });

        socket.on('playerRespawned', (data) => {
            // CRITICAL: Ignora se è il nostro player (gestiamo respawn localmente)
            if (data.id === myId || data.id === socket.id) {
                console.log('[CLIENT] Ignorato playerRespawned per me stesso');
                return;
            }

            if (otherPlayers[data.id]) {
                // Reset completo stato del player respawnato
                otherPlayers[data.id].mesh.userData.isDead = false;
                otherPlayers[data.id].mesh.visible = true;

                // FIX: Ferma animazione death e torna a idle
                if (otherPlayers[data.id].knightAnimations && otherPlayers[data.id].knightAnimations.death) {
                    otherPlayers[data.id].knightAnimations.death.stop();
                }
                if (typeof playEnemyKnightAnimation === 'function') {
                    playEnemyKnightAnimation(otherPlayers[data.id], 'idle', false);
                }

                // CRITICAL: Aggiorna team e teamColor per evitare perdita dati
                if (data.team !== undefined) {
                    otherPlayers[data.id].team = data.team;
                }
                if (data.teamColor !== undefined) {
                    otherPlayers[data.id].teamColor = data.teamColor;
                    // Aggiorna il colore del mesh se necessario
                    if (otherPlayers[data.id].mesh.material) {
                        otherPlayers[data.id].mesh.material.color.setHex(data.teamColor);
                    }
                }
                if (data.username !== undefined) {
                    otherPlayers[data.id].username = data.username;
                }

                // Aggiorna posizione se fornita
                if (data.position) {
                    otherPlayers[data.id].mesh.position.set(data.position.x, data.position.y, data.position.z);
                }
                if (data.rotation) {
                    otherPlayers[data.id].mesh.rotation.set(data.rotation.x, data.rotation.y, data.rotation.z);
                }

                // Reset HP a pieno al respawn
                otherPlayers[data.id].hp = data.hp || 200;
                otherPlayers[data.id].maxHp = 200;
                updateEnemyHealthBar(otherPlayers[data.id], otherPlayers[data.id].hp);

                // FIX: Non forzare visibilità di tutti i figli (causa sovrapposizione modelli)
                // Invece, aggiorna la visibilità corretta in base al weaponMode
                const currentMode = otherPlayers[data.id].mesh.userData.weaponMode || 'ranged';
                updateOpponentWeaponVisuals(otherPlayers[data.id], currentMode);

                console.log(`[CLIENT] Player ${data.id} respawnato - team: ${data.team}, visibile: true`);
            } else {
                // Se il player non esiste, crealo usando i dati del respawn
                console.log(`[CLIENT] Player ${data.id} respawnato ma non trovato - creazione con dati completi`);

                // Crea oggetto player completo per addOtherPlayer
                const playerInfo = {
                    id: data.id,
                    username: data.username || 'Player',
                    hp: data.hp || 200,
                    maxHp: data.hp || 200,
                    position: data.position || { x: 0, y: 6, z: 0 },
                    rotation: data.rotation || { x: 0, y: 0, z: 0 },
                    team: data.team,
                    teamColor: data.teamColor || 0x2c3e50,
                    animState: 'idle',
                    weaponMode: 'ranged',
                    isBlocking: false,
                    isDead: false
                };

                addOtherPlayer(playerInfo);
            }
        });

        socket.on('playerDied', (data) => {
            if (data.id === myId) {
                playerStats.isDead = true; playerStats.hp = 0;
                document.getElementById('message').innerHTML = "SEI STATO SCONFITTO<br><span style='font-size:16px'>Respawn in 3 secondi...</span>";
                document.getElementById('message').style.display = "block"; document.exitPointerLock();
                spawnParticles(playerMesh.position, 0xff0000, 50, 50, 1.0, true);

                // ANIMAZIONE DEATH per giocatore locale
                if (typeof playKnightAnimation === 'function' && knightModel && knightModel.visible) {
                    playKnightAnimation('death', true);
                    // Nascondi dopo animazione (circa 3 secondi per death 0.7x)
                    setTimeout(() => {
                        if (playerStats.isDead) playerMesh.visible = false;
                    }, 3000);
                } else {
                    playerMesh.visible = false;
                }

                console.log('[CLIENT] Io sono morto - respawn automatico in 3 secondi');

                // RESPAWN AUTOMATICO dopo 3 secondi
                setTimeout(() => {
                    if (playerStats.isDead) { // Controlla se è ancora morto
                        console.log('[CLIENT] Auto-respawn attivato');
                        respawnPlayer();
                    }
                }, 3000);
            } else if (otherPlayers[data.id]) {
                // CRITICAL: Setta HP a 0 IMMEDIATAMENTE
                otherPlayers[data.id].hp = 0;
                otherPlayers[data.id].mesh.userData.isDead = true;
                updateEnemyHealthBar(otherPlayers[data.id], 0);

                addToLog(otherPlayers[data.id].username + " eliminated!", "kill");
                spawnParticles(otherPlayers[data.id].mesh.position, 0xff0000, 50, 50, 1.0, true);

                // CLEANUP CASTING SPHERE ON DEATH
                if (typeof stopCastingEffect === 'function') {
                    stopCastingEffect(otherPlayers[data.id]);
                }

                console.log(`[DEATH] Player ${data.id} morto - HP settato a 0, isDead=true`);

                // ANIMAZIONE DEATH per nemico
                if (typeof playEnemyKnightAnimation === 'function' && otherPlayers[data.id].knightModel) {
                    playEnemyKnightAnimation(otherPlayers[data.id], 'death', true);
                    // Nascondi dopo animazione
                    setTimeout(() => {
                        if (otherPlayers[data.id] && otherPlayers[data.id].mesh.userData.isDead) {
                            otherPlayers[data.id].mesh.visible = false;
                        }
                    }, 3000);
                } else {
                    otherPlayers[data.id].mesh.visible = false;
                }

                // Non rimuovere il giocatore - sarà rimostrato quando respawna
            }

            // Score Logic: Friendly Fire Check
            if (data.killerId) {
                const killerId = data.killerId;
                const victimId = data.id;

                // Determine teams
                const killerTeam = (killerId === myId) ? myTeam : (otherPlayers[killerId]?.team || null);
                const victimTeam = (victimId === myId) ? myTeam : (otherPlayers[victimId]?.team || null);

                if (killerTeam && victimTeam) {
                    if (killerTeam === victimTeam && killerId !== victimId) {
                        // FRIENDLY FIRE: PENALTY (-1)
                        if (typeof updateTeamScore === 'function') {
                            updateTeamScore(killerTeam, -1);
                            console.log(`[SCORE] Friendly Fire! ${killerTeam} -1`);
                        }
                    } else if (killerTeam !== victimTeam) {
                        // NORMAL KILL: POINT (+1)
                        if (typeof updateTeamScore === 'function') {
                            updateTeamScore(killerTeam, 1);
                        }
                    }
                }

                // Show Personal Kill Text
                if (killerId === myId && killerTeam !== victimTeam) {
                    addFloatingText(playerMesh.position.clone().add(new THREE.Vector3(0, 12, 0)), '☠️ KILL!', 0xff0000, 1.5);
                    // Update personal Kills local storage (legacy default)
                    myKills++;
                    localStorage.setItem('ragequit_kills', myKills);
                }
            }
        });
    } else { console.warn("Modalità Offline"); document.getElementById('connection-status').innerText = "OFFLINE"; }
}

function addOtherPlayer(info) {
    if (!info || !info.id) return;

    // CRITICAL: NEVER add yourself to otherPlayers
    if (info.id === myId || info.id === socket.id) {
        console.error('[BLOCKED] Tentativo di creare copia di me stesso in otherPlayers!', info.id);
        return;
    }

    // Skip if recently removed (within dedupe window) to prevent duplicate adds
    if (recentlyRemoved[info.id]) {
        console.log('TRACE: skipping addOtherPlayer for', info.id, '(recently removed)');
        return;
    }
    // If an entry already exists for this id, remove it first to prevent duplicates
    if (otherPlayers[info.id]) {
        console.warn('[WARN] Player', info.id, 'già esistente in otherPlayers - rimuovo vecchio mesh');
        removeOtherPlayer(info.id);
    }
    const mesh = new THREE.Group();
    const playerTeamColor = info.teamColor || 0x2c3e50;
    const armorMat = new THREE.MeshStandardMaterial({
        color: playerTeamColor,
        metalness: 0.7,
        emissive: playerTeamColor,
        emissiveIntensity: 0.3
    });
    const metalMat = new THREE.MeshStandardMaterial({ color: 0x95a5a6, metalness: 0.9 });
    const torso = new THREE.Mesh(new THREE.BoxGeometry(4.5, 6.5, 3), armorMat); torso.position.y = 3.5; mesh.add(torso);
    const chest = new THREE.Mesh(new THREE.BoxGeometry(4.7, 3.5, 3.2), metalMat); chest.position.y = 5.0; mesh.add(chest);

    const headGroup = createHelmet(mesh);

    // Gambe composte (Cosce e Stivali)
    const legUpperGeo = new THREE.BoxGeometry(1.6, 3.25, 1.6);
    const legLowerGeo = new THREE.BoxGeometry(1.6, 3.25, 1.6);

    // Gamba Sinistra
    const legL = new THREE.Mesh(legUpperGeo, armorMat); legL.geometry.translate(0, -3.25 / 2, 0);
    legL.position.set(-1.4, 3.5, 0);
    const bootL = new THREE.Mesh(legLowerGeo, armorMat); bootL.geometry.translate(0, -3.25 / 2, 0);
    bootL.position.y = -3.25;
    legL.add(bootL);
    mesh.add(legL);

    // Gamba Destra
    const legR = new THREE.Mesh(legUpperGeo, armorMat); legR.geometry.translate(0, -3.25 / 2, 0);
    legR.position.set(1.4, 3.5, 0);
    const bootR = new THREE.Mesh(legLowerGeo, armorMat); bootR.geometry.translate(0, -3.25 / 2, 0);
    bootR.position.y = -3.25;
    legR.add(bootR);
    mesh.add(legR);

    const armGeo = new THREE.BoxGeometry(1.4, 6, 1.4);
    const armL = new THREE.Mesh(armGeo, armorMat); armL.geometry.translate(0, -2.5, 0); armL.position.set(-3, 8.0, 0);
    mesh.add(armL);
    const armR = new THREE.Mesh(armGeo, armorMat); armR.geometry.translate(0, -2.5, 0); armR.position.set(3, 8.0, 0);
    mesh.add(armR);
    const staff = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.3, 22), new THREE.MeshStandardMaterial({ color: 0x3e2723 })); staff.position.set(0, -4, 0); staff.rotation.x = -Math.PI / 6; armR.add(staff);

    const swordGroup = new THREE.Group();
    const blade = new THREE.Mesh(new THREE.BoxGeometry(0.8, 18, 0.2), new THREE.MeshStandardMaterial({ color: 0xecf0f1 })); blade.position.y = 10; swordGroup.add(blade);
    const guard = new THREE.Mesh(new THREE.BoxGeometry(6, 0.8, 0.8), new THREE.MeshStandardMaterial({ color: 0xf39c12 })); guard.position.y = 1; swordGroup.add(guard);
    const hilt = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 4), new THREE.MeshStandardMaterial({ color: 0x5a3a22 })); hilt.position.y = -1.5; swordGroup.add(hilt);

    swordGroup.position.set(0, -5, 0.5);
    swordGroup.rotation.x = -Math.PI / 2;
    swordGroup.rotation.z = Math.PI / 2;

    swordGroup.visible = false; armR.add(swordGroup);

    const shield = new THREE.Mesh(new THREE.BoxGeometry(4, 8, 1), new THREE.MeshBasicMaterial({ color: 0x00aaff, transparent: true, opacity: 0.4 }));
    shield.position.set(3, -2, 0);
    shield.rotation.y = -Math.PI / 2;

    shield.visible = false; armL.add(shield);

    // BOW for Enemy
    const bowGroup = new THREE.Group();
    const bowCurve = new THREE.Mesh(new THREE.TorusGeometry(3, 0.2, 8, 12, Math.PI), new THREE.MeshStandardMaterial({ color: 0x8B4513 }));
    bowCurve.rotation.z = -Math.PI / 2;
    bowGroup.add(bowCurve);
    const stringGeo = new THREE.CylinderGeometry(0.05, 0.05, 6);
    const string = new THREE.Mesh(stringGeo, new THREE.MeshBasicMaterial({ color: 0xffffff }));
    string.rotation.z = -Math.PI / 2;
    string.position.x = -0.5; // Offset string slightly
    bowGroup.add(string);

    bowGroup.position.set(0, -2, 0);
    bowGroup.visible = false;
    armL.add(bowGroup); // Held in left hand

    mesh.position.set(info.position.x, info.position.y, info.position.z);
    const label = createPlayerLabel(info.username); label.position.y = 14; label.userData.isLabel = true; mesh.add(label); mesh.userData.hpBar = label.userData.hpBar;

    // CRITICAL: Assicura che il mesh sia visibile (importante per respawn)
    mesh.visible = true;
    // REMOVED UNSAFE TRAVERSE: Do not force children visibility as it unhides low poly parts
    // mesh.traverse((child) => {
    //     if (!child.userData.isLabel) { // Non modificare label visibility
    //         child.visible = true;
    //     }
    // });

    scene.add(mesh);
    otherPlayers[info.id] = {
        username: info.username,
        team: info.team || null,
        teamColor: info.teamColor || 0x2c3e50,
        mesh: mesh,
        limbs: {
            armL, armR,
            legL: legL,
            legR: legR,
            bootL: bootL,
            bootR: bootR,
            head: headGroup, torso, chest
        },
        weaponMeshes: { staff: staff, sword: swordGroup, shield: shield, bow: bowGroup },
        isAttacking: false, attackTimer: 0, isWhirlwinding: false, isDead: info.isDead || false,
        lastStepPos: new THREE.Vector3(),
        // FIX: Inizializza sempre hp e maxHp per evitare bug primo colpo
        hp: info.hp || 200,
        maxHp: 200
    };

    // HIDE LOW POLY PARTS IMMEDIATELY (We use Knight model always)
    if (torso) torso.visible = false;
    if (chest) chest.visible = false;
    if (legL) legL.visible = false;
    if (legR) legR.visible = false;
    if (armL) armL.visible = false;
    if (armR) armR.visible = false;
    if (headGroup) headGroup.visible = false;

    // Initialize weaponMode from info or default to ranged
    otherPlayers[info.id].mesh.userData.weaponMode = info.weaponMode || 'ranged';

    // Load Knight Model for Enemy
    if (typeof loadEnemyKnightModel === 'function') {
        loadEnemyKnightModel(otherPlayers[info.id]);
    }

    // Initial visual update
    updateOpponentWeaponVisuals(otherPlayers[info.id], otherPlayers[info.id].mesh.userData.weaponMode);
    console.log(`[CLIENT] addOtherPlayer: ${info.id} - visible: ${mesh.visible}, isDead: ${info.isDead || false}, team: ${info.team}`);
}

function createPlayerLabel(name) {
    const group = new THREE.Group();
    const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d'); canvas.width = 256; canvas.height = 64;
    ctx.fillStyle = "rgba(0,0,0,0.5)"; ctx.fillRect(0, 0, 256, 64); ctx.font = "bold 32px Arial"; ctx.fillStyle = "white"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(name, 128, 32);
    const tex = new THREE.CanvasTexture(canvas); const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex })); sprite.scale.set(10, 2.5, 1); group.add(sprite);
    const bg = new THREE.Mesh(new THREE.PlaneGeometry(5, 0.5), new THREE.MeshBasicMaterial({ color: 0x330000 })); bg.position.y = 1.2; group.add(bg);
    const fg = new THREE.Mesh(new THREE.PlaneGeometry(5, 0.5), new THREE.MeshBasicMaterial({ color: 0x00ff00 })); fg.position.y = 1.2; fg.position.z = 0.01; fg.geometry.translate(2.5, 0, 0); fg.position.x = -2.5; group.add(fg);
    group.userData.hpBar = fg; return group;
}

function updateEnemyHealthBar(playerObj, hp) {
    if (playerObj && playerObj.mesh.userData.hpBar) {
        // FIX: Assicura che hp sia valido e usa maxHp corretto
        if (!playerObj.hp && hp !== undefined) {
            playerObj.hp = hp;
        }
        if (!playerObj.maxHp) {
            playerObj.maxHp = 100;
        }

        const oldHp = playerObj.hp;
        const validHp = (hp !== undefined && hp !== null) ? hp : (playerObj.hp || 100);
        const scale = Math.max(0, Math.min(1, validHp / playerObj.maxHp));

        // DEBUG: Log dettagliato per capire il bug del doppio danno
        const damage = oldHp - validHp;
        console.log(`[HP BAR DETAILED] Player ${playerObj.username}:`);
        console.log(`  - HP prima: ${oldHp}, HP dopo: ${validHp}, Differenza: ${damage}`);
        console.log(`  - MaxHP: ${playerObj.maxHp}`);
        console.log(`  - Scale calcolata: ${scale.toFixed(3)} (${(scale * 100).toFixed(1)}%)`);
        console.log(`  - Parametro hp ricevuto: ${hp}`);

        playerObj.mesh.userData.hpBar.scale.x = scale;
        playerObj.mesh.userData.hpBar.material.color.setHex(scale > 0.5 ? 0x00ff00 : (scale > 0.2 ? 0xffa500 : 0xff0000));
    }
}

function removeOtherPlayer(id) {
    if (otherPlayers[id]) {
        const p = otherPlayers[id];

        // 1. CLEANUP ANIMATIONS (SERIAL KILLER MODE)
        if (p.knightMixer) {
            p.knightMixer.stopAllAction();
            // Uncache everything attached to this root
            p.knightMixer.uncacheRoot(p.knightMixer.getRoot());

            // Explicitly uncache known clips
            if (p.knightAnimations) {
                Object.values(p.knightAnimations).forEach(action => {
                    if (action) {
                        action.stop();
                        action.reset(); // Reset state
                        const clip = action.getClip();
                        if (clip) p.knightMixer.uncacheClip(clip);
                    }
                });
            }
        }

        // 2. DEEP DISPOSE OF VISUAL ASSETS
        if (p.mesh) {
            p.mesh.traverse((child) => {
                if (child.isMesh) {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => {
                                if (m.map) m.map.dispose();
                                if (m.emissiveMap) m.emissiveMap.dispose();
                                m.dispose();
                            });
                        } else {
                            if (child.material.map) child.material.map.dispose();
                            if (child.material.emissiveMap) child.material.emissiveMap.dispose();
                            child.material.dispose();
                        }
                    }
                }
            });
            scene.remove(p.mesh);
        }

        delete otherPlayers[id];
        // Mark as recently removed to prevent re-add within dedupe window
        recentlyRemoved[id] = Date.now();
        setTimeout(() => { delete recentlyRemoved[id]; }, DEDUPE_WINDOW_MS);

        // CLEANUP SPELL EFFECTS
        if (typeof stopCastingEffect === 'function') {
            stopCastingEffect(p);
        }
    }
}

function updateOpponentWeaponVisuals(p, mode) {
    if (p.weaponMeshes) {
        p.weaponMeshes.staff.visible = (mode === 'ranged');
        p.weaponMeshes.sword.visible = (mode === 'melee');
        p.weaponMeshes.bow.visible = (mode === 'bow');

        // Toggle Knight vs Archer Model
        if (mode === 'bow' && p.archerModel) {
            // SHOW ARCHER
            p.archerModel.visible = true;
            if (p.knightModel) p.knightModel.visible = false;

            // Hide separate bow mesh if using archer model (assuming model has bow)
            // If model doesn't have bow, we might need to attach p.weaponMeshes.bow to it.
            // For now, let's assume we hide the separate bow to avoid duplication if the model has one.
            // But if the model is just the character, we need the bow.
            // User said "Voglio vedere il player nemico con l arco in mano".
            // Usually "Knight_archer.glb" implies character + bow.
            // I will hide the separate bow mesh for now.
            p.weaponMeshes.bow.visible = false;

        } else {
            // SHOW KNIGHT
            if (p.knightModel) {
                p.knightModel.visible = true;
                // Ensure low poly parts are hidden
                if (p.limbs.torso) p.limbs.torso.visible = false;
                if (p.limbs.chest) p.limbs.chest.visible = false;
                if (p.limbs.legL) p.limbs.legL.visible = false;
                if (p.limbs.legR) p.limbs.legR.visible = false;
                if (p.limbs.armL) p.limbs.armL.visible = false;
                if (p.limbs.armR) p.limbs.armR.visible = false;
                if (p.limbs.head) p.limbs.head.visible = false;
            }
            if (p.archerModel) p.archerModel.visible = false;
        }
    }
}

function updateEnemyShield(p, blocking) {
    if (p.weaponMeshes && p.weaponMeshes.shield) {
        p.weaponMeshes.shield.visible = blocking;
        if (blocking) {
            p.limbs.armL.rotation.set(-Math.PI / 2, 0, Math.PI / 2);
        } else {
            p.limbs.armL.rotation.set(0, 0, 0);
        }
    }
}

function checkLogin() {
    // Funzione obsoleta - il login è gestito dal nuovo menu
    const savedName = localStorage.getItem('ragequit_username');
    if (savedName) {
        myUsername = savedName;
    }
}

