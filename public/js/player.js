// player.js - autogenerated module from original game.js

// GLB Knight Model - Sistema Completo
let knightModel = null;
let fpsBowContainer = null; // Container for FPS Archer Model
let fpsArcherMixer = null; // Mixer for FPS Archer
let fpsStaffContainer = null; // Container for FPS Mage Model
let fpsMageMixer = null; // Mixer for FPS Mage
let knightMixer = null;
let knightAnimations = {
    idle: null,
    walk: null,
    run: null,
    strafe: null,
    jump: null,
    attack: null,
    cast: null,
    whirlwind: null,
    block: null,
    blockIdle: null,
    powerup: null,
    death: null
};
let currentKnightAction = null;
let currentKnightAnimName = '';
// Stato precedente di blocco per evitare ri-trigger del reverse su cambi rapidi di movimento
let wasBlocking = false;
let isKnightLoaded = false;
let animationStartTime = 0;
let minAnimDuration = 0; // Durata minima per animazioni speciali
let sprintCooldown = false; // Prevents rapid toggle when stamina hits 0
let upperBodyBones = []; // Bone della parte superiore (spine/chest in su)
let lowerBodyBones = []; // Bone della parte inferiore (hips/gambe)
// Flag dedicato per salto (mantiene animazione jump anche se canJump torna true anticipatamente)
// Jump semplificato: nessun flag, si usa solo canJump per mostrare animazione in aria

function loadKnightModel(callback) {
    if (isKnightLoaded) {
        if (callback) callback();
        return;
    }

    console.log('=== LOADING KNIGHT MET.GLB ===');
    const loader = new THREE.GLTFLoader();

    const cacheBuster = Date.now();
    loader.load(`./models/Knight_Met_2.glb?v=${cacheBuster}`, (gltf) => {
        // DEFENSIVE LOADING: Cleanup existing model if present
        if (knightModel) {
            console.warn('[KNIGHT] Existing model detected! Cleaning up...');
            if (knightMixer) {
                knightMixer.stopAllAction();
                knightMixer.uncacheRoot(knightModel);
            }
            if (playerMesh) playerMesh.remove(knightModel);
            knightModel.traverse((child) => {
                if (child.isMesh) {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) child.material.forEach(m => m.dispose());
                        else child.material.dispose();
                    }
                }
            });
            knightModel = null;
        }

        knightModel = gltf.scene;
        knightModel.scale.set(10, 10, 10);
        knightModel.position.set(0, -6.0, 0); // Lowered to touch ground (Player pivot is at y=6)
        knightModel.rotation.y = Math.PI; // Gira verso il mirino
        knightModel.visible = false;

        console.log('[KNIGHT] ✓ Model loaded');
        console.log('[KNIGHT] Animations found:', gltf.animations.length);

        // Applica colore team
        const teamColor = typeof myTeamColor !== 'undefined' ? myTeamColor : 0x2c3e50;
        knightModel.traverse((child) => {
            if (child.isMesh) {
                if (child.material) {
                    // FIX: Clone solo se necessario, preserva texture
                    child.material = child.material.clone();

                    // Apply 100% tint of team color (Full Color)
                    const tintColor = new THREE.Color(0xffffff).lerp(new THREE.Color(teamColor), 1.0);
                    child.material.color.copy(tintColor);

                    // Remove emissive to avoid washing out texture
                    child.material.emissive = new THREE.Color(0x000000);
                    child.material.emissiveIntensity = 0.0;

                    child.material.metalness = 0.5;
                    child.material.roughness = 0.5;

                    // FIX: Forza rendering corretto
                    child.material.side = THREE.FrontSide;
                    child.material.depthWrite = true;
                    child.material.depthTest = true;
                    child.material.needsUpdate = true;
                }
                child.castShadow = true;
                child.receiveShadow = true;

                // FIX: Disabilita frustum culling per evitare scomparsa quando vicino alla camera
                child.frustumCulled = false;
            }
        });

        if (playerMesh) {
            playerMesh.add(knightModel);
            console.log('[KNIGHT] ✓ Added to player');
        }

        // Crea mixer per le animazioni
        knightMixer = new THREE.AnimationMixer(knightModel);
        console.log('[KNIGHT] ✓ Mixer created');

        // MAPPA TUTTE LE ANIMAZIONI DAL GLB
        console.log('[KNIGHT] === MAPPING ANIMATIONS ===');

        if (gltf.animations && gltf.animations.length > 0) {
            console.log('[KNIGHT] Total animations:', gltf.animations.length);

            // Helper to filter root motion but keep specific axes (e.g. Y for bobbing)
            const filterPositionTrack = (track, keepX, keepY, keepZ) => {
                const values = track.values;
                const times = track.times;
                const newValues = new Float32Array(values.length);

                // Copy values but zero out unwanted axes
                for (let i = 0; i < values.length; i += 3) {
                    newValues[i] = keepX ? values[i] : values[0]; // Keep X or use initial
                    newValues[i + 1] = keepY ? values[i + 1] : values[1]; // Keep Y or use initial
                    newValues[i + 2] = keepZ ? values[i + 2] : values[2]; // Keep Z or use initial
                }

                return new THREE.VectorKeyframeTrack(track.name, times, newValues);
            };

            gltf.animations.forEach((clip, index) => {
                const name = clip.name.toLowerCase();
                if (name.includes('.001') || name.includes('mixamo.com')) return; // SKIP DUPLICATES & JUNK

                // CLIP TRIMMING (Stop 2 Frames Early)
                // Trim 0.06s from one-shot animations to prevent T-pose/Loop glitches at the end
                if (name.includes('attack') || name.includes('jump') || name.includes('leap') ||
                    name.includes('whirlwind') || name.includes('spin') || name.includes('cast') ||
                    name.includes('powerup') || name.includes('death') || name.includes('die')) {
                    if (clip.duration > 0.1) {
                        clip.duration -= 0.06;
                        // console.log(`  [TRIM] Trimmed 0.06s from ${clip.name}. New duration: ${clip.duration.toFixed(3)}s`);
                    }
                }

                console.log(`  [${index}] "${clip.name}" (${clip.duration.toFixed(2)}s)`);

                // Mappa in base al nome e configura loop appropriati
                if (name.includes('walk') && !name.includes('block') || name.includes('wal')) {
                    // WALK: Use original clip directly (Root Motion removed in source)
                    knightAnimations.walk = knightMixer.clipAction(clip);
                    knightAnimations.walk.setLoop(THREE.LoopRepeat);
                    knightAnimations.walk.clampWhenFinished = false;
                    console.log('    → WALK (loop, original clip used)');
                    knightAnimations.walk.setLoop(THREE.LoopRepeat);
                    knightAnimations.walk.clampWhenFinished = false;
                    console.log('    → WALK (loop, root motion removed - tasto W)');
                }
                else if (name.includes('strafe')) {
                    // STRAFE: Use original clip directly
                    knightAnimations.strafe = knightMixer.clipAction(clip);
                    knightAnimations.strafe.setLoop(THREE.LoopRepeat);
                    knightAnimations.strafe.clampWhenFinished = false;
                    console.log('    → STRAFE (loop, original clip used)');
                    knightAnimations.strafe.setLoop(THREE.LoopRepeat);
                    knightAnimations.strafe.clampWhenFinished = false;
                    console.log('    → STRAFE (loop, no root motion)');
                }
                else if (name.includes('idle') && !name.includes('block')) {
                    knightAnimations.idle = knightMixer.clipAction(clip);
                    knightAnimations.idle.setLoop(THREE.LoopRepeat);
                    knightAnimations.idle.clampWhenFinished = false;
                    console.log('    → IDLE (loop)');
                }
                else if (name.includes('run')) {
                    // RUN: Use original clip directly
                    knightAnimations.run = knightMixer.clipAction(clip);
                    knightAnimations.run.setLoop(THREE.LoopRepeat);
                    knightAnimations.run.clampWhenFinished = false;
                    console.log('    → RUN (loop, original clip used)');
                    knightAnimations.run.setLoop(THREE.LoopRepeat);
                    knightAnimations.run.clampWhenFinished = false;
                    console.log('    → RUN (loop, no root motion)');
                }
                else if (name.includes('jump') || name.includes('leap')) {
                    // JUMP: Use original clip directly
                    knightAnimations.jump = knightMixer.clipAction(clip);
                    knightAnimations.jump.setLoop(THREE.LoopOnce);
                    knightAnimations.jump.clampWhenFinished = false;
                    knightAnimations.jump.repetitions = 1;
                    console.log('    → JUMP (once, original clip used)');
                }
                else if ((name.includes('attack') && name.includes('1')) || name === 'attack 1' || name === 'attack1') {
                    knightAnimations.attack = knightMixer.clipAction(clip);
                    knightAnimations.attack.setLoop(THREE.LoopOnce);
                    knightAnimations.attack.clampWhenFinished = true;
                    knightAnimations.attack.repetitions = 1;
                    console.log('    → ATTACK 1 (once, clamp finish - no T-pose)');
                }
                else if ((name.includes('cast') && name.includes('1')) || name === 'cast 1' || name === 'cast1') {
                    knightAnimations.cast = knightMixer.clipAction(clip);
                    knightAnimations.cast.setLoop(THREE.LoopOnce);
                    knightAnimations.cast.clampWhenFinished = true;
                    knightAnimations.cast.repetitions = 1;
                    console.log('    → CAST 1 (once, clamp finish - spell casting)');
                }
                else if (name.includes('whirlwind') || name.includes('180') || name.includes('spin')) {
                    // WHIRLWIND: Use original clip directly
                    knightAnimations.whirlwind = knightMixer.clipAction(clip);
                    knightAnimations.whirlwind.setLoop(THREE.LoopOnce);
                    knightAnimations.whirlwind.clampWhenFinished = true; // FIX: Clamp to prevent reset to frame 0
                    knightAnimations.whirlwind.repetitions = 1;
                    console.log('    → WHIRLWIND (once, original clip used)');
                }
                else if (name.includes('block') && name.includes('idle')) {
                    knightAnimations.blockIdle = knightMixer.clipAction(clip);
                    knightAnimations.blockIdle.setLoop(THREE.LoopRepeat);
                    knightAnimations.blockIdle.clampWhenFinished = false;
                    console.log('    → BLOCK IDLE (loop)');
                }
                else if (name.includes('block') || name.includes('parry')) {
                    knightAnimations.block = knightMixer.clipAction(clip);
                    knightAnimations.block.setLoop(THREE.LoopRepeat);
                    knightAnimations.block.clampWhenFinished = false;
                    console.log('    → BLOCK (loop)');
                }
                else if (name.includes('powerup') || name.includes('power up')) {
                    knightAnimations.powerup = knightMixer.clipAction(clip);
                    knightAnimations.powerup.setLoop(THREE.LoopOnce);
                    knightAnimations.powerup.clampWhenFinished = true; // Mantiene la posa finale
                    knightAnimations.powerup.repetitions = 1;
                    console.log('    → POWERUP (once, clamp finish)');
                }
                else if (name.includes('death') || name.includes('die')) {
                    knightAnimations.death = knightMixer.clipAction(clip);
                    knightAnimations.death.setLoop(THREE.LoopOnce);
                    knightAnimations.death.clampWhenFinished = true;
                    console.log('    → DEATH (once+hold)');
                }
                else {
                    console.log('    → (unmapped)');
                }
            });

            // Evento quando finisce un'animazione one-shot
            knightMixer.addEventListener('finished', (e) => {
                if (e.action === knightAnimations.attack) {
                    console.log('[KNIGHT] ✓ Attack complete');
                    isAttacking = false;
                    minAnimDuration = 0;
                    // Non resettare subito currentKnightAnimName per evitare scatti
                    // T-POSE FIX: Restore idle immediately
                    if (knightAnimations.idle) {
                        knightAnimations.idle.setEffectiveWeight(1.0);
                        knightAnimations.idle.play();
                    }
                    // FADE OUT FIX: Release weight so Dynamic Idle takes over
                    e.action.fadeOut(0.2);

                    // IMMEDIATE RESET: No delay to prevent gaps
                    if (currentKnightAnimName === 'attack') {
                        currentKnightAnimName = '';
                    }
                } else if (e.action === knightAnimations.attackUpper) {
                    console.log('[KNIGHT] ✓ Layered attack upper complete');
                    isAttacking = false;
                    minAnimDuration = 0;
                    // SMART RESTORE: Check movement to prevent T-Pose/Glitch
                    const isMoving = moveForward || moveBackward || moveLeft || moveRight;
                    if (isMoving) {
                        // Restore movement animation immediately
                        const moveAnim = (isSprinting && !sprintCooldown && knightAnimations.run) ? knightAnimations.run : knightAnimations.walk;
                        if (moveAnim) {
                            moveAnim.setEffectiveWeight(1.0);
                            moveAnim.play();
                            // Keep idle low but alive
                            if (knightAnimations.idle) knightAnimations.idle.setEffectiveWeight(0.01);
                        }
                    } else {
                        // Not moving, restore idle
                        if (knightAnimations.idle) {
                            knightAnimations.idle.setEffectiveWeight(1.0);
                            knightAnimations.idle.play();
                        }
                    }

                    // Stop the upper action explicitly to clear it
                    // FIX: DO NOT STOP immediately. Let it hold (clamped) until next anim starts.
                    // e.action.stop();
                    // FADE OUT FIX: Release weight so Dynamic Idle takes over
                    e.action.fadeOut(0.2);

                    // IMMEDIATE RESET
                    if (currentKnightAnimName === 'attack_layered') {
                        currentKnightAnimName = '';
                    }
                } else if (e.action === knightAnimations.whirlwind) {
                    console.log('[KNIGHT] ✓ Whirlwind complete');
                    minAnimDuration = 0;
                    // Delay per transizione fluida
                    // T-POSE FIX: Restore idle immediately
                    if (knightAnimations.idle) {
                        knightAnimations.idle.setEffectiveWeight(1.0);
                        knightAnimations.idle.play();
                    }
                    // FADE OUT FIX: Release weight so Dynamic Idle takes over
                    e.action.fadeOut(0.2);

                    // IMMEDIATE RESET
                    if (currentKnightAnimName === 'whirlwind') {
                        currentKnightAnimName = '';
                    }
                } else if (e.action === knightAnimations.powerup) {
                    console.log('[KNIGHT] ✓ Powerup complete');
                    minAnimDuration = 0;
                    // T-POSE FIX: Restore idle immediately
                    if (knightAnimations.idle) {
                        knightAnimations.idle.setEffectiveWeight(1.0);
                        knightAnimations.idle.play();
                    }
                    // FADE OUT FIX: Release weight so Dynamic Idle takes over
                    e.action.fadeOut(0.2);

                    // IMMEDIATE RESET
                    if (currentKnightAnimName === 'powerup') {
                        currentKnightAnimName = '';
                    }
                } else if (e.action === knightAnimations.powerupUpper) {
                    console.log('[KNIGHT] ✓ Layered powerup complete');
                    minAnimDuration = 0;
                    // IMMEDIATE RESET
                    if (currentKnightAnimName === 'powerup_layered') {
                        currentKnightAnimName = '';
                    }
                }
            });

            // Identifica bone per layering upper/lower body
            let hipsBone = null;
            knightModel.traverse((node) => {
                if (node.isBone) {
                    const boneName = node.name.toLowerCase();
                    // Upper body: spine, chest, neck, head, shoulders, arms
                    if (boneName.includes('spine') || boneName.includes('chest') ||
                        boneName.includes('neck') || boneName.includes('head') ||
                        boneName.includes('shoulder') || boneName.includes('arm') ||
                        boneName.includes('hand') || boneName.includes('finger') ||
                        boneName.includes('clavicle')) {
                        upperBodyBones.push(node);
                    }
                    // Lower body: hips, legs, feet
                    else if (boneName.includes('hips') || boneName.includes('leg') ||
                        boneName.includes('thigh') || boneName.includes('calf') ||
                        boneName.includes('foot') || boneName.includes('toe')) {
                        lowerBodyBones.push(node);
                        if (boneName.includes('hips') || boneName.includes('mixamorig:hips')) {
                            hipsBone = node;
                        }
                    }
                }
            });
            console.log(`[KNIGHT] Bone layering: ${upperBodyBones.length} upper, ${lowerBodyBones.length} lower`);

            // Crea clip layered per blockIdle (upper body only) e strafe (lower body only)
            // Crea clip layered per blockIdle (upper body only) e strafe (lower body only)
            if (knightAnimations.blockIdle && upperBodyBones.length > 0) {
                const originalClip = knightAnimations.blockIdle.getClip();
                // FIX: Include Hips Rotation! Otherwise shield points wrong way (left) because body isn't turned.
                const rotOnlyBones = hipsBone ? [hipsBone] : [];
                const upperClip = createAdvancedLayeredClip(originalClip, upperBodyBones, rotOnlyBones, null, 'blockIdle_upperBody_withHipsRot');

                knightAnimations.blockIdleUpper = knightMixer.clipAction(upperClip);
                knightAnimations.blockIdleUpper.setLoop(THREE.LoopRepeat);
                console.log('[KNIGHT] ✓ Created blockIdle upper body layer (with hips rotation)');
            }
            if (knightAnimations.strafe && lowerBodyBones.length > 0) {
                const originalClip = knightAnimations.strafe.getClip();
                // Lower body (full) MA hips solo posizione
                const lowerNoHips = lowerBodyBones.filter(b => b !== hipsBone);
                const posOnlyBones = hipsBone ? [hipsBone] : [];
                const lowerClip = createAdvancedLayeredClip(originalClip, lowerNoHips, null, posOnlyBones, 'strafe_lowerBody');

                knightAnimations.strafeLower = knightMixer.clipAction(lowerClip);
                knightAnimations.strafeLower.setLoop(THREE.LoopRepeat);
                console.log('[KNIGHT] ✓ Created strafe lower body layer (hips pos only)');
            }
            // Layer per ATTACK (upper body + HIPS ROTATION) e WALK/RUN (lower body)
            if (knightAnimations.attack && upperBodyBones.length > 0) {
                const attackClip = knightAnimations.attack.getClip();
                // Include upper body (full) AND hips (rotation only)
                const rotOnlyBones = hipsBone ? [hipsBone] : [];
                const attackUpperClip = createAdvancedLayeredClip(attackClip, upperBodyBones, rotOnlyBones, null, 'attack_upperBody_withHipsRot');

                knightAnimations.attackUpper = knightMixer.clipAction(attackUpperClip);
                knightAnimations.attackUpper.setLoop(THREE.LoopOnce);
                knightAnimations.attackUpper.clampWhenFinished = true; // FIX: Clamp to prevent T-pose gap
                knightAnimations.attackUpper.repetitions = 1;
                console.log('[KNIGHT] ✓ Created attack upper body layer (with hips rotation)');
            }
            if (knightAnimations.walk && lowerBodyBones.length > 0) {
                const walkClip = knightAnimations.walk.getClip();
                // Lower body (full) MA hips solo posizione (per evitare conflitti rotazione con attack)
                const lowerNoHips = lowerBodyBones.filter(b => b !== hipsBone);
                const posOnlyBones = hipsBone ? [hipsBone] : [];
                const walkLowerClip = createAdvancedLayeredClip(walkClip, lowerNoHips, null, posOnlyBones, 'walk_lowerBody');

                knightAnimations.walkLower = knightMixer.clipAction(walkLowerClip);
                knightAnimations.walkLower.setLoop(THREE.LoopRepeat);
                console.log('[KNIGHT] ✓ Created walk lower body layer (hips pos only)');
            }
            if (knightAnimations.run && lowerBodyBones.length > 0) {
                const runClip = knightAnimations.run.getClip();
                // Lower body (full) MA hips solo posizione
                const lowerNoHips = lowerBodyBones.filter(b => b !== hipsBone);
                const posOnlyBones = hipsBone ? [hipsBone] : [];
                const runLowerClip = createAdvancedLayeredClip(runClip, lowerNoHips, null, posOnlyBones, 'run_lowerBody');

                knightAnimations.runLower = knightMixer.clipAction(runLowerClip);
                knightAnimations.runLower.setLoop(THREE.LoopRepeat);
                console.log('[KNIGHT] ✓ Created run lower body layer (hips pos only)');
            }
            // Layer per POWERUP (upper body)
            if (knightAnimations.powerup && upperBodyBones.length > 0) {
                const puClip = knightAnimations.powerup.getClip();
                const puUpperClip = createLayeredClip(puClip, upperBodyBones, 'powerup_upperBody');
                knightAnimations.powerupUpper = knightMixer.clipAction(puUpperClip);
                knightAnimations.powerupUpper.setLoop(THREE.LoopOnce);
                knightAnimations.powerupUpper.clampWhenFinished = true; // FIX: Clamp to prevent T-pose gap
                knightAnimations.powerupUpper.repetitions = 1;
                console.log('[KNIGHT] ✓ Created powerup upper body layer');
            }
            // Layer per JUMP (lower body) - rimuove anche rotazioni upper body
            if (knightAnimations.jump && lowerBodyBones.length > 0) {
                const jumpClip = knightAnimations.jump.getClip();
                // Crea clip solo con lower body MA rimuove anche quaternion di spine/chest
                const tracks = [];
                for (let i = 0; i < jumpClip.tracks.length; i++) {
                    const track = jumpClip.tracks[i];
                    const trackName = track.name.toLowerCase();
                    const boneName = trackName.split('.')[0].toLowerCase();

                    // Filtra quaternion di spine/chest per evitare rotazioni upper body
                    if (trackName.includes('.quaternion') && (boneName.includes('spine') || boneName.includes('chest'))) {
                        console.log(`      [JumpLower] Filtrata rotazione upper: ${track.name}`);
                        continue;
                    }

                    // Mantieni solo tracce di lower body bones
                    const isLowerBone = lowerBodyBones.some(bone => track.name.startsWith(bone.name + '.'));
                    if (isLowerBone) {
                        tracks.push(track);
                    }
                }
                const jumpLowerClip = new THREE.AnimationClip('jump_lowerBody_noRotation', jumpClip.duration, tracks);
                knightAnimations.jumpLower = knightMixer.clipAction(jumpLowerClip);
                knightAnimations.jumpLower.setLoop(THREE.LoopOnce);
                knightAnimations.jumpLower.clampWhenFinished = true; // FIX: Clamp to prevent T-pose gap
                knightAnimations.jumpLower.repetitions = 1;
                console.log('[KNIGHT] ✓ Created jump lower body layer (no upper rotation)');
            }

            // Avvia idle se disponibile - SEMPRE RUNNING per evitare T-pose
            if (knightAnimations.idle) {
                knightAnimations.idle.reset();
                knightAnimations.idle.setEffectiveWeight(1.0); // Peso completo
                knightAnimations.idle.play();
                currentKnightAction = knightAnimations.idle;
                currentKnightAnimName = 'idle';
                console.log('[KNIGHT] ▶ Started IDLE (always active)');
            } else if (knightAnimations.walk) {
                knightAnimations.walk.play();
                currentKnightAction = knightAnimations.walk;
                currentKnightAnimName = 'walk';
                console.log('[KNIGHT] ▶ Started WALK (no idle)');
            }

            console.log('[KNIGHT] ✓ Animations ready:', {
                idle: !!knightAnimations.idle,
                walk: !!knightAnimations.walk,
                run: !!knightAnimations.run,
                strafe: !!knightAnimations.strafe,
                jump: !!knightAnimations.jump,
                attack: !!knightAnimations.attack,
                whirlwind: !!knightAnimations.whirlwind,
                block: !!knightAnimations.block,
                blockIdle: !!knightAnimations.blockIdle,
                death: !!knightAnimations.death
            });
        } else {
            console.error('[KNIGHT] ✗ No animations in GLB!');
        }

        isKnightLoaded = true;
        if (callback) callback();

    }, undefined, (error) => {
        console.error('[KNIGHT] ✗ Load error:', error);
    });
}

function loadArcherModel() {
    console.log('=== LOADING ARCHER.GLB ===');
    const loader = new THREE.GLTFLoader();

    loader.load('./models/archer.glb', (gltf) => {
        const model = gltf.scene;

        // Setup container attached to camera for FPS view
        fpsBowContainer = new THREE.Group();
        fpsBowContainer.add(model);

        // Final Calibrated Values (User Provided)
        // RESTORED: Scale and Position restored to original values to avoid clipping with new Camera Near Plane (0.1)
        // IDLE STATE
        const idlePos = new THREE.Vector3(-0.270, -0.600, -0.300);
        console.log('[ARCHER DEBUG] Loaded IdlePos:', idlePos);
        const idleRot = new THREE.Euler(0.020, 3.292, 0.530);
        const idleScale = new THREE.Vector3(0.700, 0.700, 0.700);

        // AIM STATE
        const aimPos = new THREE.Vector3(-0.155, -0.220, 0.000);
        // Rotation and Scale are same as IDLE for now, but we store them if needed

        // Apply Initial (IDLE)
        model.position.copy(idlePos);
        model.rotation.copy(idleRot);
        model.scale.copy(idleScale);

        // Store config for animation switching
        model.userData.idlePos = idlePos;
        model.userData.aimPos = aimPos;

        fpsBowContainer.visible = false;
        if (typeof weaponMode !== 'undefined' && weaponMode === 'bow') {
            fpsBowContainer.visible = true;
        }
        camera.add(fpsBowContainer); // Attach to camera so it moves with view

        // Setup Animation Mixer
        fpsArcherMixer = new THREE.AnimationMixer(model);
        fpsArcherAnimations = {}; // Store animations globally or on a reachable object

        // Load and configure animations
        if (gltf.animations && gltf.animations.length > 0) {
            // Helper to setup action
            const setupAction = (name) => {
                const clip = gltf.animations.find(a => a.name === name);
                if (clip) {
                    const action = fpsArcherMixer.clipAction(clip);
                    fpsArcherAnimations[name] = action;
                    return action;
                }
                return null;
            };

            const idleAction = setupAction('Bow_IDLE');
            const aimAction = setupAction('Bow_AIM_IDLE');
            const runAction = setupAction('Bow_RUN');
            const walkAction = setupAction('Bow_WALK');
            const jumpStartAction = setupAction('Bow_JUMP_START');
            const jumpEndAction = setupAction('Bow_JUMP_END');
            const fireAction = setupAction('Bow_FIRE');

            // Configure Fire animation to play once and not loop
            if (fireAction) {
                fireAction.setLoop(THREE.LoopOnce);
                fireAction.clampWhenFinished = true;

                // On finish, return to IDLE (or AIM if holding?)
                fpsArcherMixer.addEventListener('finished', (e) => {
                    if (e.action === fireAction) {
                        // Return to appropriate state
                        if (window.isBowAiming) {
                            switchArcherAnimation('Bow_AIM_IDLE');
                        } else {
                            switchArcherAnimation('Bow_IDLE');
                        }
                    }
                });
            }

            if (jumpStartAction) {
                jumpStartAction.setLoop(THREE.LoopOnce);
                jumpStartAction.clampWhenFinished = true;
            }
            if (jumpEndAction) {
                jumpEndAction.setLoop(THREE.LoopOnce);
                jumpEndAction.clampWhenFinished = true;
            }

            // Play IDLE by default
            if (idleAction) {
                idleAction.play();
                fpsArcherCurrentAction = idleAction; // Track current action
            } else if (gltf.animations[0]) {
                idleAction.play();
                fpsArcherCurrentAction = idleAction; // Track current action
            } else if (gltf.animations[0]) {
                // Fallback
                const action = fpsArcherMixer.clipAction(gltf.animations[0]);
                action.play();
                fpsArcherCurrentAction = action;
            }
        }

        console.log('[ARCHER] ✓ Model loaded with calibrated values.');

        // Check for debug flag to enable calibration tool
        // ENABLED BY USER REQUEST
        if (false && (true || window.debugModelPosition)) {
            enableModelCalibration(model, 'ARCHER');
        }

        // Traverse to fix materials and apply TEAM COLOR
        model.traverse((child) => {
            if (child.isMesh) {
                child.frustumCulled = false; // Always render
                if (child.material) {
                    // FIX: Rimuove DoubleSide che causa buchi nelle texture
                    child.material.side = THREE.FrontSide;

                    // FIX: Apply Team Color Tint (30% intensity)
                    // Use emissive to give a slight glow/tint of the team color
                    if (typeof myTeamColor !== 'undefined') {
                        const color = new THREE.Color(myTeamColor);
                        // Clone material to avoid affecting other instances if any
                        child.material = child.material.clone();
                        child.material.emissive = color;
                        child.material.emissiveIntensity = 0.2;

                        // FIX: Blend 30% of team color into the base texture
                        // This keeps the model solid but tints it with the team color
                        child.material.color.lerp(color, 0.3);
                    }

                    // FIX: Forza depth test corretto per evitare z-fighting
                    child.material.depthWrite = true;
                    child.material.depthTest = true;
                    child.material.transparent = false;
                    child.material.needsUpdate = true;
                }
            }
        });

    }, undefined, (error) => {
        console.error('[ARCHER] ✗ Load error:', error);
    });
}

function loadMageModel() {
    console.log('=== LOADING MAGE.GLB ===');
    const loader = new THREE.GLTFLoader();

    loader.load('./models/mage.glb', (gltf) => {
        const model = gltf.scene;

        // Setup container attached to camera for FPS view
        fpsStaffContainer = new THREE.Group();
        fpsStaffContainer.add(model);

        // Initial Calibration (Final User Calibrated Values)
        model.position.set(0.000, -5.080, 0.210);
        model.rotation.set(-0.140, 3.100, -0.020);
        model.scale.set(2.810, 2.810, 2.810);

        fpsStaffContainer.visible = false;
        if (typeof weaponMode !== 'undefined' && weaponMode === 'ranged') {
            fpsStaffContainer.visible = true;
        }
        camera.add(fpsStaffContainer);

        // Setup Animation Mixer
        fpsMageMixer = new THREE.AnimationMixer(model);
        window.fpsMageAnimations = {}; // Store animations globally

        // Helper to setup action
        const setupMageAction = (name, alias) => {
            let clip = gltf.animations.find(a => a.name === name);
            if (!clip && alias) clip = gltf.animations.find(a => a.name === alias);

            if (clip) {
                const action = fpsMageMixer.clipAction(clip);
                window.fpsMageAnimations[name] = action;
                return action;
            }
            return null;
        };

        // Load Animations
        const idleAction = setupMageAction("arms_armature|arms_armature|Combat_idle_loop", "arms_armature|Combat_idle_loop");
        const spellStartAction = setupMageAction("arms_armature|arms_armature|Magic_spell_loop_start");
        const spellLoopAction = setupMageAction("arms_armature|arms_armature|Magic_spell_loop");
        const spellAttackAction = setupMageAction("arms_armature|arms_armature|Magic_spell_attack");

        // Play IDLE by default
        if (idleAction) {
            idleAction.play();
            window.fpsMageAction = idleAction;
        } else if (gltf.animations.length > 0) {
            // Fallback
            const action = fpsMageMixer.clipAction(gltf.animations[0]);
            action.play();
            window.fpsMageAction = action;
        }

        // Function to switch animations
        window.switchMageAnimation = function (animName) {
            if (!window.fpsMageAnimations || !window.fpsMageAnimations[animName]) {
                console.warn('[MAGE] Animation not found:', animName);
                return;
            }

            const newAction = window.fpsMageAnimations[animName];
            if (window.fpsMageAction === newAction) return; // Already playing

            // Fade out current
            if (window.fpsMageAction) {
                window.fpsMageAction.fadeOut(0.2);
            }

            // Reset and fade in new
            newAction.reset();
            newAction.fadeIn(0.2);
            newAction.play();
            window.fpsMageAction = newAction;

            // Special handling for non-looping animations
            if (animName === "arms_armature|arms_armature|Magic_spell_loop_start") {
                newAction.setLoop(THREE.LoopOnce);
                newAction.clampWhenFinished = true;

                // Auto-transition to LOOP when START finishes
                fpsMageMixer.addEventListener('finished', (e) => {
                    if (e.action === newAction) {
                        window.switchMageAnimation("arms_armature|arms_armature|Magic_spell_loop");
                    }
                });
            }

            if (animName === "arms_armature|arms_armature|Magic_spell_attack") {
                newAction.setLoop(THREE.LoopOnce);
                newAction.clampWhenFinished = true;

                // Auto-transition to IDLE when ATTACK finishes
                fpsMageMixer.addEventListener('finished', (e) => {
                    if (e.action === newAction) {
                        window.switchMageAnimation("arms_armature|arms_armature|Combat_idle_loop");
                    }
                });
            }
        };

        console.log('[MAGE] ✓ Model loaded.');

        // Enable calibration if debug is on
        if (window.debugModelPosition) {
            enableModelCalibration(model, 'MAGE');
        }

        // Apply Team Color / Material Fixes
        model.traverse((child) => {
            if (child.isMesh) {
                child.frustumCulled = false;
                if (child.material) {
                    // FIX: Rimuove DoubleSide che causa buchi nelle texture
                    child.material.side = THREE.FrontSide;

                    if (typeof myTeamColor !== 'undefined') {
                        const color = new THREE.Color(myTeamColor);
                        child.material = child.material.clone();
                        child.material.emissive = color;
                        child.material.emissiveIntensity = 0.2;
                        child.material.color.lerp(color, 0.3);
                    }

                    // FIX: Forza depth test corretto per evitare z-fighting
                    child.material.depthWrite = true;
                    child.material.depthTest = true;
                    child.material.transparent = false;
                    child.material.needsUpdate = true;
                }
            }
        });

    }, undefined, (error) => {
        console.error('[MAGE] ✗ Load error:', error);
    });
}

// === REUSABLE MODEL CALIBRATION TOOL ===
// Call window.debugModelPosition = true; in console before loading model to use
window.enableModelCalibration = function (model, label = 'MODEL') {
    console.log(`[CALIBRATION] Enabled for ${label}`);

    // Create UI for calibration
    let calibUI = document.getElementById('calib-ui');
    if (!calibUI) {
        calibUI = document.createElement('div');
        calibUI.id = 'calib-ui';
        calibUI.style.position = 'fixed';
        calibUI.style.top = '10px';
        calibUI.style.right = '10px';
        calibUI.style.backgroundColor = 'rgba(0,0,0,0.7)';
        calibUI.style.color = '#0f0';
        calibUI.style.padding = '10px';
        calibUI.style.fontFamily = 'monospace';
        calibUI.style.zIndex = '9999';
        document.body.appendChild(calibUI);
    }

    calibUI.innerHTML = `
        <b>${label} CALIBRATION</b><br>
        ARROWS: Move X/Y<br>
        PgUp/Dn: Move Z<br>
        I/K: Rot X | J/L: Rot Y | U/O: Rot Z<br>
        Numpad +/-: Scale<br>
        P: Log Coords<br>
        <div id="calib-values"></div>
    `;

    const updateUI = () => {
        const vals = document.getElementById('calib-values');
        if (vals) {
            vals.innerHTML = `
                POS: ${model.position.x.toFixed(3)}, ${model.position.y.toFixed(3)}, ${model.position.z.toFixed(3)}<br>
                ROT: ${model.rotation.x.toFixed(3)}, ${model.rotation.y.toFixed(3)}, ${model.rotation.z.toFixed(3)}<br>
                SCL: ${model.scale.x.toFixed(3)}
            `;
        }
    };
    updateUI();

    const handler = (e) => {
        // Only active if this specific model is being debugged

        // FIX: Prevent default browser/game actions for debug keys
        const debugKeys = ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'PageUp', 'PageDown',
            'KeyI', 'KeyK', 'KeyJ', 'KeyL', 'KeyU', 'KeyO', 'NumpadAdd', 'NumpadSubtract',
            'KeyP', 'KeyR'];

        if (debugKeys.includes(e.code)) {
            e.preventDefault();
            e.stopPropagation();
        } else {
            return; // Ignore other keys
        }

        // FIX: Reduced step size for finer control
        const moveStep = e.shiftKey ? 0.001 : 0.005;
        const rotStep = e.shiftKey ? 0.005 : 0.02;
        const scaleStep = e.shiftKey ? 0.001 : 0.01;

        // FIX: If model has a targetPosition (lerp enabled), update THAT instead of position directly
        const target = (model.userData && model.userData.targetPosition) ? model.userData.targetPosition : model.position;

        switch (e.code) {
            // Position - Updates target if exists, or position directly
            case 'ArrowLeft': target.x -= moveStep; break;
            case 'ArrowRight': target.x += moveStep; break;
            case 'ArrowUp': target.y += moveStep; break;
            case 'ArrowDown': target.y -= moveStep; break;
            case 'PageUp': target.z += moveStep; break;
            case 'PageDown': target.z -= moveStep; break;

            // Rotation - Always direct update
            case 'KeyI': model.rotation.x += rotStep; break;
            case 'KeyK': model.rotation.x -= rotStep; break;
            case 'KeyJ': model.rotation.y += rotStep; break;
            case 'KeyL': model.rotation.y -= rotStep; break;
            case 'KeyU': model.rotation.z += rotStep; break;
            case 'KeyO': model.rotation.z -= rotStep; break;

            // Scale - Always direct update
            case 'NumpadAdd':
                model.scale.addScalar(scaleStep);
                break;
            case 'NumpadSubtract':
                model.scale.addScalar(-scaleStep);
                break;

            // Log
            case 'KeyP':
                console.log(`
// CALIBRATED VALUES for ${label}
// Position (Target/Current):
const pos = new THREE.Vector3(${target.x.toFixed(3)}, ${target.y.toFixed(3)}, ${target.z.toFixed(3)});
const rot = new THREE.Euler(${model.rotation.x.toFixed(3)}, ${model.rotation.y.toFixed(3)}, ${model.rotation.z.toFixed(3)});
const scale = new THREE.Vector3(${model.scale.x.toFixed(3)}, ${model.scale.x.toFixed(3)}, ${model.scale.x.toFixed(3)});
                `);
                alert('Coordinates logged to console (F12)!');
                break;

            // RESET
            case 'KeyR':
                if (model.userData && model.userData.targetPosition) {
                    model.userData.targetPosition.set(0, -1, -3);
                }
                model.position.set(0, -1, -3);
                model.rotation.set(0, Math.PI, 0);
                model.scale.set(1, 1, 1);
                console.log('[CALIBRATION] Reset to default');
                updateUI();
                break;
        }

        // Sync position immediately if we updated target, to see result instantly (lerp will catch up/maintain)
        if (model.userData && model.userData.targetPosition) {
            // Optional: Force snap to target for instant feedback? 
            // No, let lerp handle it, but update UI with TARGET values for accuracy
        }

        updateUI();
    };

    window.addEventListener('keydown', handler);
};

function createLayeredClip(originalClip, includeBones, clipName) {
    // Crea un nuovo clip che include SOLO i track dei bone specificati
    if (!originalClip || !includeBones || includeBones.length === 0) return originalClip;

    const filteredTracks = [];
    originalClip.tracks.forEach((track) => {
        const boneName = track.name.split('.')[0];
        // Includi solo track dei bone nella lista
        const shouldInclude = includeBones.some(bone => bone.name === boneName);
        if (shouldInclude) {
            filteredTracks.push(track);
        }
    });

    if (filteredTracks.length === 0) return originalClip;
    return new THREE.AnimationClip(clipName, originalClip.duration, filteredTracks);
}

function createStaticClip(originalClip, time, clipName) {
    // Crea un clip statico campionando l'originale a un tempo specifico
    if (!originalClip) return null;

    const tracks = [];
    originalClip.tracks.forEach((track) => {
        const times = [0, 1]; // Durata fittizia di 1s
        const values = [];

        // Campiona il valore al tempo specificato
        // Nota: Questo è un campionamento semplificato, assume interpolazione lineare o step
        // Per precisione assoluta servirebbe interpolare, ma per "hold" va bene prendere il keyframe più vicino o il primo

        // Trova i valori grezzi dal track originale
        // THREE.KeyframeTrack non ha un metodo facile per "getAt(time)", quindi facciamo una copia del primo valore
        // o cerchiamo di interpolare manualmente. Per semplicità, prendiamo il valore a metà array se time è ~0.5

        // APPROCCIO MIGLIORE: Usiamo AnimationAction per campionare? No, siamo in fase di setup.
        // Facciamo un clone del track ma con un solo keyframe ripetuto.

        const stride = track.getValueSize();
        const buffer = track.values;
        const numKeys = track.times.length;

        // Cerchiamo l'indice del keyframe più vicino al tempo desiderato
        let index = 0;
        for (let i = 0; i < numKeys; i++) {
            if (track.times[i] >= time) {
                index = i;
                break;
            }
        }

        // Copia i valori di quel keyframe
        const value = [];
        for (let k = 0; k < stride; k++) {
            value.push(buffer[index * stride + k]);
        }

        // Crea due keyframe identici per fare un loop statico
        const newValues = [...value, ...value];

        // Crea il nuovo track dello stesso tipo
        const TrackConstructor = track.constructor;
        tracks.push(new TrackConstructor(track.name, times, newValues));
    });

    return new THREE.AnimationClip(clipName, 1.0, tracks);
}

function createAdvancedLayeredClip(originalClip, fullBones, rotOnlyBones, posOnlyBones, clipName) {
    // Crea un clip che include:
    // - TUTTI i track per i bone in fullBones
    // - SOLO i track QUATERNION per i bone in rotOnlyBones
    // - SOLO i track POSITION per i bone in posOnlyBones
    if (!originalClip) return null;

    const filteredTracks = [];
    originalClip.tracks.forEach((track) => {
        const boneName = track.name.split('.')[0];
        const propName = track.name.split('.')[1]; // .position, .quaternion, .scale

        // Check full bones
        const isFull = fullBones && fullBones.some(bone => bone.name === boneName);
        if (isFull) {
            filteredTracks.push(track);
            return;
        }

        // Check rotation only bones
        const isRot = rotOnlyBones && rotOnlyBones.some(bone => bone.name === boneName);
        if (isRot && propName === 'quaternion') {
            filteredTracks.push(track);
            return;
        }

        // Check position only bones
        const isPos = posOnlyBones && posOnlyBones.some(bone => bone.name === boneName);
        if (isPos && propName === 'position') {
            filteredTracks.push(track);
            return;
        }
    });

    if (filteredTracks.length === 0) return originalClip;
    return new THREE.AnimationClip(clipName, originalClip.duration, filteredTracks);
}

function stopLayeredActions(excludeActions = []) {
    // Helper per fermare forzatamente tutte le azioni layered
    // Questo previene che rimangano attive con weight residui che corrompono altre animazioni
    const layeredActions = [
        knightAnimations.attackUpper,
        knightAnimations.runLower,
        knightAnimations.walkLower,
        knightAnimations.strafeLower,
        knightAnimations.powerupUpper,
        knightAnimations.blockIdleUpper,
        knightAnimations.jumpLower
    ];

    layeredActions.forEach(action => {
        if (action && action.isRunning() && !excludeActions.includes(action)) {
            action.stop();
            action.setEffectiveWeight(0);
            action.setEffectiveTimeScale(1.0);
        }
    });
}

function playKnightAnimation(animName, forceRestart = false) {
    if (!knightMixer || !knightAnimations[animName]) return;

    if (currentKnightAnimName === animName && !forceRestart) return;

    console.log(`[KNIGHT] ▶ ${animName}`);

    // SPECIAL CASE: layered attack while moving
    if (animName === 'attack' && (moveForward || moveBackward || moveLeft || moveRight) && knightAnimations.attackUpper && (knightAnimations.walkLower || knightAnimations.runLower)) {
        const fadeTime = 0.15;
        // Determina clip gambe (run se sprint, altrimenti walk)
        // Animazione segue l'input del giocatore, MA ORA rispetta anche la stamina (physically accurate)
        const isSprintingActive = isSprinting && moveForward && !sprintCooldown;
        const legsAction = isSprintingActive && knightAnimations.runLower ? knightAnimations.runLower : knightAnimations.walkLower;

        // CORRUPTION FIX: Ferma altri layer ma mantieni le gambe se servono
        stopLayeredActions(legsAction ? [legsAction] : []);

        // FIX: Keep idle at 1% for safety (Anti T-Pose)
        if (knightAnimations.idle) knightAnimations.idle.setEffectiveWeight(0.01);

        // Fade out altri layer (eccetto idle che gestiamo sopra)
        // Fade out altri layer (eccetto idle che gestiamo sopra)
        Object.entries(knightAnimations).forEach(([k, action]) => {
            if (action && action.isRunning() && action !== legsAction && action !== knightAnimations.idle && action !== knightAnimations.attackUpper) {
                // ANTI-ACCUMULATION FIX: Se peso basso, STOP immediato
                if (action.getEffectiveWeight() < 0.1) {
                    action.stop();
                    action.setEffectiveWeight(0);
                } else {
                    action.fadeOut(fadeTime);
                }
            }
        });
        // Avvia gambe
        if (legsAction) {
            if (!legsAction.isRunning()) {
                legsAction.reset();
                // SYNC FIX: Se l'animazione full-body corrispondente è attiva, sincronizza il tempo
                // Questo evita che le gambe "scattino" a una posizione diversa
                const fullBodyAnim = (legsAction === knightAnimations.runLower) ? knightAnimations.run : knightAnimations.walk;
                if (fullBodyAnim && fullBodyAnim.isRunning()) {
                    // Copia il tempo attuale per mantenere la fase del passo
                    legsAction.time = fullBodyAnim.time;
                    // console.log(`[SYNC] Synced ${legsAction.getClip().name} to ${fullBodyAnim.getClip().name} (time: ${fullBodyAnim.time.toFixed(2)})`);
                }
            }
            legsAction.setEffectiveWeight(1.3);
            legsAction.fadeIn(fadeTime).play();
        }
        // Avvia upper attack
        const upper = knightAnimations.attackUpper;
        upper.reset();
        upper.setEffectiveTimeScale(1.4); // SPEED FIX: 1.4x instead of 2.0x
        upper.setEffectiveWeight(2.2);
        upper.fadeIn(fadeTime).play();
        const naturalDuration = upper.getClip().duration;
        const actualDuration = naturalDuration / 1.4;
        minAnimDuration = actualDuration;

        // SYNC FIX: Calcola velocità spada per finire esattamente con l'animazione
        // La spada fa un arco di PI (3.14) radianti
        swordAnimationSpeed = Math.PI / actualDuration;

        animationStartTime = performance.now();
        currentKnightAnimName = 'attack_layered';
        console.log(`  [Attack Layered] Upper+Legs (${legsAction === knightAnimations.runLower ? 'RUN' : 'WALK'}) Duration: ${actualDuration.toFixed(2)}s, SwordSpeed: ${swordAnimationSpeed.toFixed(2)}`);

        // CONFLICT FIX: Reset timer per garantire inizio pulito
        attackTimer = 0;
        isAttacking = true;
        return;
    }
    // SPECIAL CASE: layered powerup while moving
    if (animName === 'powerup' && (moveForward || moveBackward || moveLeft || moveRight) && knightAnimations.powerupUpper && (knightAnimations.walkLower || knightAnimations.runLower)) {
        const fadeTime = 0.2;
        // Animazione segue l'input del giocatore, non la stamina
        const isSprintingActive = isSprinting && moveForward;
        const legsAction = isSprintingActive && knightAnimations.runLower ? knightAnimations.runLower : knightAnimations.walkLower;

        // CORRUPTION FIX: Ferma altri layer ma mantieni le gambe se servono
        stopLayeredActions(legsAction ? [legsAction] : []);

        Object.entries(knightAnimations).forEach(([k, action]) => {
            if (action && action.isRunning() && action !== legsAction && action !== knightAnimations.idle && action !== knightAnimations.powerupUpper) {
                // ANTI-ACCUMULATION FIX: Se peso basso, STOP immediato
                if (action.getEffectiveWeight() < 0.1) {
                    action.stop();
                    action.setEffectiveWeight(0);
                } else {
                    action.fadeOut(fadeTime);
                }
            }
        });
        if (legsAction) {
            if (!legsAction.isRunning()) {
                legsAction.reset();
                // SYNC FIX: Sincronizzazione anche per powerup
                const fullBodyAnim = (legsAction === knightAnimations.runLower) ? knightAnimations.run : knightAnimations.walk;
                if (fullBodyAnim && fullBodyAnim.isRunning()) {
                    legsAction.time = fullBodyAnim.time;
                }
            }
            legsAction.setEffectiveWeight(1.2);
            legsAction.fadeIn(fadeTime).play();
        }
        const upper = knightAnimations.powerupUpper;
        upper.reset();
        upper.setEffectiveTimeScale(1.0);
        upper.setEffectiveWeight(2.0);
        upper.fadeIn(fadeTime).play();
        const naturalDuration = upper.getClip().duration;
        minAnimDuration = naturalDuration;
        animationStartTime = performance.now();
        currentKnightAnimName = 'powerup_layered';
        console.log(`  [Powerup Layered] Upper+Legs (${legsAction === knightAnimations.runLower ? 'RUN' : 'WALK'}) Duration: ${naturalDuration.toFixed(2)}s`);
        return;
    }

    let targetAction = knightAnimations[animName];

    // CORRUPTION FIX: Se avviamo un'animazione standard (non layered), 
    // assicuriamoci che i layer precedenti siano completamente spenti
    stopLayeredActions();

    // Jump sempre sul posto: nessuna sostituzione condizionale necessaria
    const fadeTime = 0.2; // 200ms di crossfade

    // SISTEMA ANTI T-POSE: Mantieni idle sempre attiva
    if (knightAnimations.idle) {
        if (!knightAnimations.idle.isRunning()) {
            knightAnimations.idle.reset();
            knightAnimations.idle.play();
        }

        // FIX: Se l'animazione target NON è idle, riduci il peso di idle a 0 per evitare blending
        // Se è idle, mettila a 1.0 (o fade in)
        if (animName !== 'idle') {
            // T-POSE FIX: Keep idle alive at 1% weight as safety net
            knightAnimations.idle.setEffectiveWeight(0.01);
        } else {
            knightAnimations.idle.setEffectiveWeight(1.0);
        }
    }

    // Fade out delle altre animazioni (eccetto idle) e fade in della nuova
    // Fade out delle altre animazioni (eccetto idle) e fade in della nuova
    Object.values(knightAnimations).forEach(action => {
        if (action && action !== targetAction && action !== knightAnimations.idle && action.isRunning()) {
            // ANTI-ACCUMULATION FIX: Se peso basso, STOP immediato
            if (action.getEffectiveWeight() < 0.1) {
                action.stop();
                action.setEffectiveWeight(0);
            } else {
                action.fadeOut(fadeTime);
            }
        }
    });

    targetAction.reset();

    // SYNC FIX: Se stiamo tornando a Walk/Run da un Layered Attack, sincronizza il tempo
    if (animName === 'run' || animName === 'walk') {
        const layeredAnim = (animName === 'run') ? knightAnimations.runLower : knightAnimations.walkLower;
        if (layeredAnim && layeredAnim.isRunning()) {
            targetAction.time = layeredAnim.time;
            // console.log(`[SYNC] Synced ${animName} to ${layeredAnim.getClip().name} (time: ${layeredAnim.time.toFixed(2)})`);
        }
    }

    targetAction.fadeIn(fadeTime);

    // Se non è idle, imposta weight maggiore dell'animazione target per sovrascrivere idle
    if (animName !== 'idle') {
        targetAction.setEffectiveWeight(2.0); // Peso doppio per sovrascrivere idle
    }

    // Imposta timeScale appropriato
    if (animName === 'attack') {
        // SPEED FIX: 1.4x instead of 2.0x
        targetAction.setEffectiveTimeScale(1.4);
        const naturalDuration = targetAction.getClip().duration;
        const actualDuration = naturalDuration / 1.4;
        minAnimDuration = actualDuration;

        // SYNC FIX: Calcola velocità spada per finire esattamente con l'animazione
        swordAnimationSpeed = Math.PI / actualDuration;

        // CONFLICT FIX: Reset timer per garantire inizio pulito
        attackTimer = 0;

        console.log(`  [Attack] Speed: 1.4x, Duration: ${actualDuration.toFixed(2)}s, SwordSpeed: ${swordAnimationSpeed.toFixed(2)}`);
    } else if (animName === 'whirlwind') {
        // Whirlwind a velocità naturale per massima fluidità
        targetAction.setEffectiveTimeScale(1.0);
        // FIX: Rimuovi peso idle per evitare conflitti sulla rotazione hips (taglio al centro)
        if (knightAnimations.idle) knightAnimations.idle.setEffectiveWeight(0);

        const naturalDuration = targetAction.getClip().duration;
        minAnimDuration = naturalDuration;
        console.log(`  [Whirlwind] Natural speed, Duration: ${naturalDuration.toFixed(2)}s`);
    } else if (animName === 'jump') {
        // Rallenta il salto per renderlo più leggibile
        targetAction.setEffectiveTimeScale(0.6);
        console.log('  [Jump] Slowed: timeScale 0.6');
    } else if (animName === 'death') {
        // SLOW DOWN DEATH ANIMATION as requested
        targetAction.setEffectiveTimeScale(0.7);
        console.log('  [Death] Slowed: timeScale 0.7');
    } else if (animName === 'powerup') {
        // Powerup: imposta durata completa ma sarà bypassabile dalla parata
        targetAction.setEffectiveTimeScale(1.0);
        const naturalDuration = targetAction.getClip().duration;
        minAnimDuration = naturalDuration;
        console.log(`  [Powerup] Duration: ${naturalDuration.toFixed(2)}s (interruptible by block)`);
    } else {
        targetAction.setEffectiveTimeScale(1.0);
        minAnimDuration = 0;
    }

    animationStartTime = performance.now();
    targetAction.play();
    currentKnightAction = targetAction;
    currentKnightAnimName = animName;
}

function updateKnightAnimation() {
    if (!knightModel || !knightModel.visible || !knightMixer) return;

    const isMoving = moveForward || moveBackward || moveLeft || moveRight;
    const isStrafing = (moveLeft || moveRight) && !moveForward && !moveBackward;
    const prevWasBlocking = wasBlocking;

    // Rispetta la durata minima per animazioni speciali (attack, whirlwind)
    // MA parata ha priorità assoluta
    if (minAnimDuration > 0 && !isBlocking) {
        const elapsed = (performance.now() - animationStartTime) / 1000;
        if (elapsed < minAnimDuration) {
            // Non cambiare animazione finché non è passato il tempo minimo
            return;
        }
    }

    // Determina quale animazione dovrebbe essere attiva
    let targetAnim = null;

    if (playerStats.isDead && knightAnimations.death) {
        targetAnim = 'death';
    }
    else if (isWhirlwinding && knightAnimations.whirlwind) {
        // Durante whirlwind lascia finire
        if (currentKnightAnimName === 'whirlwind') {
            return;
        }
        targetAnim = 'whirlwind';
    }
    else if (isAttacking) {
        // Durante l'attacco (full body o layered) lascia finire
        if (currentKnightAnimName === 'attack' || currentKnightAnimName === 'attack_layered') {
            return;
        }
        targetAnim = 'attack';
    }
    else if (isBlocking) {
        // Block ha priorità su jump - ma se salti mentre blocchi, usa layered
    }
    else if (!canJump && knightAnimations.jump) {
        // In aria SENZA bloccare: mostra jump normale
        targetAnim = 'jump';
        // Riproduci immediatamente l'animazione di salto e esci per evitare override
        if (currentKnightAnimName !== 'jump') {
            playKnightAnimation('jump');
        }
        return; // ESCI QUI per impedire che il movimento sovrascrivi l'animazione jump
    }

    if (isBlocking) {
        // LAYERING: se blocchi E salti, upper body = blockIdle, lower body = jump
        if (!canJump && knightAnimations.blockIdleUpper && knightAnimations.jumpLower) {
            // Stoppa altre animazioni che potrebbero causare conflitti
            if (knightAnimations.blockIdle && knightAnimations.blockIdle.isRunning()) {
                knightAnimations.blockIdle.stop();
            }
            if (knightAnimations.jump && knightAnimations.jump.isRunning()) {
                knightAnimations.jump.stop();
            }
            if (knightAnimations.strafeLower && knightAnimations.strafeLower.isRunning()) {
                knightAnimations.strafeLower.stop();
            }

            // CORRUPTION FIX: Ferma layer conflittuali
            if (knightAnimations.attackUpper && knightAnimations.attackUpper.isRunning()) knightAnimations.attackUpper.stop();
            if (knightAnimations.powerupUpper && knightAnimations.powerupUpper.isRunning()) knightAnimations.powerupUpper.stop();

            // Attiva i layer separati
            if (!knightAnimations.blockIdleUpper.isRunning()) {
                knightAnimations.blockIdleUpper.reset();
                knightAnimations.blockIdleUpper.play();
            }
            knightAnimations.blockIdleUpper.setEffectiveWeight(2.0); // Peso alto per upper body

            if (!knightAnimations.jumpLower.isRunning()) {
                knightAnimations.jumpLower.reset();
                knightAnimations.jumpLower.play();
            }
            knightAnimations.jumpLower.setEffectiveWeight(1.5); // Peso moderato per lower body

            currentKnightAnimName = 'blockIdle+jump_layered';
            return;
        }

        // PRIORITY: Stop Powerup if blocking starts
        if (knightAnimations.powerup && knightAnimations.powerup.isRunning()) {
            knightAnimations.powerup.stop();
            console.log('[KNIGHT] Blocking interrupted Powerup');
        }
        if (knightAnimations.powerupUpper && knightAnimations.powerupUpper.isRunning()) {
            knightAnimations.powerupUpper.stop();
            console.log('[KNIGHT] Blocking interrupted Powerup Upper');
        }

        // LAYERING: se blocchi E ti muovi, upper body = blockIdle, lower body = walk/run/strafe
        if (isMoving && knightAnimations.blockIdleUpper) {
            // Determine correct lower body animation
            let lowerAction = null;
            const isSprintingActive = isSprinting && moveForward && !sprintCooldown;

            if (moveForward || moveBackward) {
                lowerAction = isSprintingActive && knightAnimations.runLower ? knightAnimations.runLower : knightAnimations.walkLower;
            } else if ((moveLeft || moveRight) && knightAnimations.strafeLower) {
                lowerAction = knightAnimations.strafeLower;
            }

            if (lowerAction) {
                // Stoppa altre animazioni che potrebbero causare conflitti
                if (knightAnimations.blockIdle && knightAnimations.blockIdle.isRunning()) knightAnimations.blockIdle.stop();
                if (knightAnimations.strafe && knightAnimations.strafe.isRunning()) knightAnimations.strafe.stop();
                if (knightAnimations.walk && knightAnimations.walk.isRunning()) knightAnimations.walk.stop();
                if (knightAnimations.run && knightAnimations.run.isRunning()) knightAnimations.run.stop();

                // CORRUPTION FIX: Ferma layer conflittuali
                if (knightAnimations.attackUpper && knightAnimations.attackUpper.isRunning()) knightAnimations.attackUpper.stop();
                if (knightAnimations.powerupUpper && knightAnimations.powerupUpper.isRunning()) knightAnimations.powerupUpper.stop();

                // Attiva i layer separati
                if (!knightAnimations.blockIdleUpper.isRunning()) {
                    knightAnimations.blockIdleUpper.reset();
                    knightAnimations.blockIdleUpper.play();
                }
                knightAnimations.blockIdleUpper.setEffectiveWeight(2.0); // Peso alto per upper body

                if (!lowerAction.isRunning()) {
                    lowerAction.reset();
                    // SYNC: Sync with full body if it was running? (Optional, but good for smoothness)
                    lowerAction.play();
                }
                lowerAction.setEffectiveWeight(1.5); // Peso moderato per lower body

                currentKnightAnimName = 'blockIdle+move_layered';
                return;
            }
        }
        // Se stavi facendo blockIdle+strafe ma hai smesso di muoverti, passa a blockIdle normale
        else if (!isMoving && currentKnightAnimName === 'blockIdle+strafe_layered') {
            // Stoppa i layer
            if (knightAnimations.blockIdleUpper && knightAnimations.blockIdleUpper.isRunning()) {
                knightAnimations.blockIdleUpper.stop();
            }
            if (knightAnimations.strafeLower && knightAnimations.strafeLower.isRunning()) {
                knightAnimations.strafeLower.stop();
            }
            // Passa a blockIdle normale
            targetAnim = 'blockIdle';
        }
        // Click parata: block REVERSE -> poi blockIdle se tenuto premuto
        else if (currentKnightAnimName === 'block_reversing' && knightAnimations.block) {
            // Block reverse in esecuzione, controlla se è finito per passare a blockIdle
            const blockAction = knightAnimations.block;
            if (blockAction.time <= 0.05) {
                // Block reverse finito, passa a blockIdle
                if (knightAnimations.blockIdle) {
                    blockAction.stop();
                    blockAction.setEffectiveTimeScale(1.0);
                    targetAnim = 'blockIdle';
                }
            } else {
                return; // Block reverse ancora in corso
            }
        } else if (currentKnightAnimName === 'blockIdle') {
            return; // Mantieni blockIdle mentre è premuto
        } else if (currentKnightAnimName === 'block') {
            // Se stai rilasciando e ripremi, interrompi il forward e riavvia reverse
            const blockAction = knightAnimations.block;
            if (blockAction) {
                blockAction.stop();
            }
            // Avvia block reverse veloce
            if (knightAnimations.block) {
                const action = knightAnimations.block;
                action.reset();
                action.paused = false;
                action.setEffectiveTimeScale(-3.0); // 3x speed
                action.time = action.getClip().duration;
                action.play();
                currentKnightAnimName = 'block_reversing';
            }
            return;
        } else if (knightAnimations.block && !prevWasBlocking && !['block_reversing', 'blockIdle', 'block', 'blockIdle+strafe_layered'].includes(currentKnightAnimName) && currentKnightAnimName !== 'whirlwind') {
            // Inizio parata: avvia block REVERSE veloce
            // Interrompi jump immediatamente (parata ha priorità) ma non whirlwind
            if (currentKnightAnimName === 'jump' && knightAnimations.jump && knightAnimations.jump.isRunning()) {
                knightAnimations.jump.stop();
                console.log('[KNIGHT] Block pressed mid-jump: jump stopped for immediate parry');
            }
            const action = knightAnimations.block;
            action.reset();
            action.paused = false;
            action.setEffectiveTimeScale(-3.0); // 3x speed per reverse molto veloce
            action.time = action.getClip().duration;
            action.play();
            currentKnightAnimName = 'block_reversing';
            console.log('[KNIGHT] Starting block reverse (first frame of block)');
            return;
        }
    }
    // FORWARD block quando rilasci la parata
    else if (!isBlocking && (currentKnightAnimName === 'blockIdle' || currentKnightAnimName === 'block_reversing' || currentKnightAnimName === 'blockIdle+strafe_layered')) {
        const action = knightAnimations.block;
        if (action && currentKnightAnimName !== 'block') {
            console.log('[KNIGHT] Starting block forward animation on release');

            // Stoppa blockIdle e i layer se erano attivi
            if (knightAnimations.blockIdle && knightAnimations.blockIdle.isRunning()) {
                knightAnimations.blockIdle.stop();
            }
            if (knightAnimations.blockIdleUpper && knightAnimations.blockIdleUpper.isRunning()) {
                knightAnimations.blockIdleUpper.stop();
            }
            if (knightAnimations.strafeLower && knightAnimations.strafeLower.isRunning()) {
                knightAnimations.strafeLower.stop();
            }

            // Stoppa block reverse se stava andando
            if (action.isRunning()) {
                action.stop();
            }

            // Avvia forward dalla posizione corrente o dall'inizio
            const currentTime = action.time;

            action.reset();
            action.paused = false;
            action.setEffectiveTimeScale(1.0);
            action.time = currentTime > 0 ? currentTime : 0;
            action.play();

            currentKnightAnimName = 'block';
        }
        // Se è in forward e ha raggiunto la fine, fermalo
        else if (currentKnightAnimName === 'block' && action) {
            const duration = action.getClip().duration;
            if (action.time >= duration - 0.05) {
                console.log('[KNIGHT] Block forward completed');
                action.stop();
                action.setEffectiveTimeScale(1.0);
                action.setEffectiveWeight(1.0);

                // Resetta weights altre animazioni
                if (knightAnimations.walk) {
                    knightAnimations.walk.setEffectiveWeight(1.0);
                }
                if (knightAnimations.strafe) {
                    knightAnimations.strafe.setEffectiveWeight(1.0);
                }

                currentKnightAnimName = '';
                minAnimDuration = 0;
            } else {
                return; // Block forward ancora in corso
            }
        }
    }
    else if (isMoving) {
        // Movimento:
        // - Strafe: solo A, S o D (laterale/indietro)
        // - Walk: W senza sprint
        // - Run: Shift + W
        // Animazione segue l'input del giocatore, la stamina limita solo la velocità
        const isStrafing = (moveLeft || moveRight || moveBackward) && !moveForward;

        if (isStrafing && knightAnimations.strafe) {
            // A, S o D: usa strafe
            targetAnim = 'strafe';
        } else if (moveForward && isSprinting && !sprintCooldown && knightAnimations.run) {
            // W + Shift + Stamina OK: usa run
            targetAnim = 'run';
        } else if (moveForward && knightAnimations.walk) {
            // W senza sprint: usa walk
            targetAnim = 'walk';
        } else {
            // Fallback
            targetAnim = knightAnimations.walk ? 'walk' : 'idle';
        }
    }
    else if (knightAnimations.idle) {
        targetAnim = 'idle';

        // SMART RUNTIME CLEANUP: If we are consistently in IDLE, ensure nothing else is stealing resources
        if (currentKnightAnimName === 'idle') {
            Object.values(knightAnimations).forEach(action => {
                if (action && action !== knightAnimations.idle && action.isRunning()) {
                    // Force stop anything that isn't idle
                    action.stop();
                    action.setEffectiveWeight(0);
                }
            });
        }
    }

    if (targetAnim && currentKnightAnimName !== targetAnim) {
        playKnightAnimation(targetAnim);
    }
    // Aggiorna stato precedente blocco per prossimo frame
    wasBlocking = isBlocking;

    // Nessun flag jump da gestire (semplificato)

    // Safeguard: normalizza i timeScale delle azioni attive
    // Evita che clip mantengano timeScale errati dopo cambi di stato (es. stamina a zero)
    const normalizeScale = (action, scale) => { if (action && action.isRunning()) action.setEffectiveTimeScale(scale); };
    normalizeScale(knightAnimations.idle, 1.0);
    normalizeScale(knightAnimations.walk, 1.0);
    normalizeScale(knightAnimations.run, 1.0);
    normalizeScale(knightAnimations.strafe, 1.0);
    normalizeScale(knightAnimations.walkLower, 1.0);
    normalizeScale(knightAnimations.runLower, 1.0);
    normalizeScale(knightAnimations.strafeLower, 1.0);
    normalizeScale(knightAnimations.attack, 1.4); // SPEED FIX: 1.4x
    normalizeScale(knightAnimations.attackUpper, 1.4); // SPEED FIX: 1.4x
    normalizeScale(knightAnimations.whirlwind, 1.0);
    normalizeScale(knightAnimations.powerup, 1.0);
    normalizeScale(knightAnimations.powerupUpper, 1.0);
    normalizeScale(knightAnimations.jump, 0.6);
}

function createHelmet(parent) {
    const helmetGroup = new THREE.Group();
    const helmGeo = new THREE.BoxGeometry(3.2, 3.4, 3.4);
    const helmMat = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.8, roughness: 0.2 });
    const helm = new THREE.Mesh(helmGeo, helmMat);
    helmetGroup.add(helm);
    const visorGeo = new THREE.BoxGeometry(2.8, 0.5, 3.6);
    const visorMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.9 });
    const visor = new THREE.Mesh(visorGeo, visorMat);
    visor.position.set(0, 0.2, -0.2);
    helmetGroup.add(visor);
    const crestGeo = new THREE.BoxGeometry(0.4, 1.5, 3.8);
    const crestMat = new THREE.MeshLambertMaterial({ color: 0xc0392b });
    const crest = new THREE.Mesh(crestGeo, crestMat);
    crest.position.y = 2.2;
    helmetGroup.add(crest);
    helmetGroup.position.y = 8.5;
    parent.add(helmetGroup);
    return helmetGroup;
}

function createPlayer() {
    // Defensive: if a player mesh already exists (double init), remove it first
    if (typeof playerMesh !== 'undefined' && playerMesh) {
        try { scene.remove(playerMesh); } catch (e) { }
        playerMesh = null;
    }

    // Usa il colore di squadra corrente (già impostato dal menu o default)
    const teamColor = typeof myTeamColor !== 'undefined' ? myTeamColor : 0x2c3e50;
    console.log('[CREATE PLAYER] Using team color:', teamColor.toString(16));

    playerMesh = new THREE.Group();
    const armorMat = new THREE.MeshLambertMaterial({ // Lambert invece di Standard per FPS
        color: teamColor,
        emissive: teamColor,
        emissiveIntensity: 0.3,
        flatShading: true // Flat shading per FPS
    });
    const metalMat = new THREE.MeshLambertMaterial({ // Lambert per performance
        color: 0x95a5a6,
        flatShading: true
    });
    const torso = new THREE.Mesh(new THREE.BoxGeometry(4.5, 6.5, 3), armorMat); torso.position.y = 3.5; playerMesh.add(torso); playerLimbs.torso = torso;
    const chest = new THREE.Mesh(new THREE.BoxGeometry(4.7, 3.5, 3.2), metalMat); chest.position.y = 5.0; playerMesh.add(chest); chest.userData.isTorsoPart = true;

    playerLimbs.head = createHelmet(playerMesh);
    playerLimbs.helmet = playerLimbs.head;

    const legUpperGeo = new THREE.BoxGeometry(1.6, 3.25, 1.6);
    const legLowerGeo = new THREE.BoxGeometry(1.6, 3.25, 1.6);

    playerLimbs.legL = new THREE.Mesh(legUpperGeo, armorMat); playerLimbs.legL.geometry.translate(0, -3.25 / 2, 0);
    playerLimbs.legL.position.set(-1.4, 3.5, 0);
    const bootL = new THREE.Mesh(legLowerGeo, armorMat); bootL.geometry.translate(0, -3.25 / 2, 0);
    bootL.position.y = -3.25;
    playerLimbs.legL.add(bootL);
    playerMesh.add(playerLimbs.legL);
    playerLimbs.bootL = bootL;

    playerLimbs.legR = new THREE.Mesh(legUpperGeo, armorMat); playerLimbs.legR.geometry.translate(0, -3.25 / 2, 0);
    playerLimbs.legR.position.set(1.4, 3.5, 0);
    const bootR = new THREE.Mesh(legLowerGeo, armorMat); bootR.geometry.translate(0, -3.25 / 2, 0);
    bootR.position.y = -3.25;
    playerLimbs.legR.add(bootR);
    playerMesh.add(playerLimbs.legR);
    playerLimbs.bootR = bootR;

    const armGeo = new THREE.BoxGeometry(1.4, 6, 1.4);
    playerLimbs.armL = new THREE.Mesh(armGeo, armorMat); playerLimbs.armL.geometry.translate(0, -2.5, 0); playerLimbs.armL.position.set(-3, 8.0, 0);
    playerMesh.add(playerLimbs.armL);
    playerLimbs.armR = new THREE.Mesh(armGeo, armorMat); playerLimbs.armR.geometry.translate(0, -2.5, 0); playerLimbs.armR.position.set(3, 8.0, 0);
    playerMesh.add(playerLimbs.armR);

    // Posiziona il giocatore alla spawn corretta in base alla modalità
    const spawnPos = getSpawnPosition ? getSpawnPosition() : new THREE.Vector3(0, 6, 0);
    playerMesh.position.copy(spawnPos);

    // Aggiorna il colore dell'armatura con il colore della squadra
    updatePlayerColor();

    scene.add(playerMesh);

    // Carica il modello Knight dopo aver creato il player
    loadKnightModel();

    // Load FPS Archer Model
    loadArcherModel();
    // Load FPS Mage Model
    loadMageModel();
}

function updatePlayerColor() {
    if (!playerMesh) return;

    // Aggiorna il colore di tutti i pezzi dell'armatura
    const currentColor = typeof myTeamColor !== 'undefined' ? myTeamColor : 0x2c3e50;

    console.log('[PLAYER COLOR] Updating player color to:', currentColor.toString(16));

    playerMesh.traverse((child) => {
        if (child.isMesh && child.material) {
            // Salta solo il metallo grigio del petto (chest) e il visore/elmo
            const isMetalPiece = (child.material.color && child.material.color.getHex() === 0x95a5a6) ||
                (child.material.color && child.material.color.getHex() === 0x555555) ||
                (child.material.color && child.material.color.getHex() === 0x111111);

            if (!isMetalPiece && child.material.color) {
                child.material.color.setHex(currentColor);
                if (child.material.emissive) {
                    child.material.emissive.setHex(currentColor);
                }
                child.material.needsUpdate = true; // Forza aggiornamento materiale
            }
        }
    });
}

function createSword() {
    swordContainer = new THREE.Group();
    const blade = new THREE.Mesh(new THREE.BoxGeometry(0.8, 18, 0.2), new THREE.MeshStandardMaterial({ color: 0xecf0f1, metalness: 0.9 })); blade.position.y = 10; swordContainer.add(blade);
    const guard = new THREE.Mesh(new THREE.BoxGeometry(6, 0.8, 0.8), new THREE.MeshStandardMaterial({ color: 0xf39c12 })); guard.position.y = 1; swordContainer.add(guard);
    const hilt = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 4), new THREE.MeshStandardMaterial({ color: 0x5a3a22 })); hilt.position.y = -1.5; swordContainer.add(hilt);

    swordContainer.position.set(0, -5, 0.5);
    swordContainer.rotation.x = -Math.PI / 2;
    swordContainer.rotation.y = 0;
    swordContainer.rotation.z = Math.PI / 2;

    swordContainer.visible = false; playerLimbs.armR.add(swordContainer);
    const trailGeo = new THREE.RingGeometry(8, 12, 32, 1, 0, Math.PI);
    const trailMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.0, side: THREE.DoubleSide });
    const trail = new THREE.Mesh(trailGeo, trailMat); trail.rotation.x = -Math.PI / 2; trail.position.y = 10; swordContainer.add(trail); swordContainer.userData.trail = trail;
}

function createStaff() {
    staffContainer = new THREE.Group();
    staffContainer.add(new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.3, 22), new THREE.MeshStandardMaterial({ color: 0x3e2723 }))).position.y = 6;
    const head = new THREE.Mesh(new THREE.TorusGeometry(1.5, 0.3, 8, 20), new THREE.MeshStandardMaterial({ color: 0xffd700 })); head.position.y = 17; head.rotation.y = Math.PI / 2; staffContainer.add(head);
    const gem = new THREE.Mesh(new THREE.OctahedronGeometry(0.8), new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.9 })); gem.position.y = 17; staffContainer.add(gem);
    staffContainer.userData.gem = gem; staffContainer.position.set(0, -4, 0); staffContainer.rotation.x = -Math.PI / 6; playerLimbs.armR.add(staffContainer);
}

function createBow() {
    bowContainer = new THREE.Group();
    const bowCurve = new THREE.Mesh(new THREE.TorusGeometry(3, 0.2, 8, 12, Math.PI), new THREE.MeshStandardMaterial({ color: 0x8B4513 }));
    bowCurve.rotation.z = -Math.PI / 2;
    bowContainer.add(bowCurve);
    const stringGeo = new THREE.CylinderGeometry(0.05, 0.05, 6);
    const string = new THREE.Mesh(stringGeo, new THREE.MeshBasicMaterial({ color: 0xffffff }));
    string.rotation.z = -Math.PI / 2;
    string.position.x = -0.5;
    bowContainer.add(string);

    bowContainer.position.set(0, -2, 0);
    bowContainer.visible = false;
    playerLimbs.armL.add(bowContainer);
}

function createShield() {
    shieldMesh = new THREE.Mesh(new THREE.BoxGeometry(4, 8, 1), new THREE.MeshBasicMaterial({ color: 0x00aaff, transparent: true, opacity: 0.4, side: THREE.DoubleSide }));
    shieldMesh.position.set(3, -2, 0);
    shieldMesh.rotation.y = -Math.PI / 2;
    shieldMesh.visible = false;
    playerLimbs.armL.add(shieldMesh);
}

// FIX: Material Cache to prevent memory leaks (reusing materials for same colors)
const particleMaterials = {};

function spawnParticles(pos, color, count, speedBase, size, isGibs) {
    // FIX: Use cached material or create new one if needed
    let mat = particleMaterials[color];
    if (!mat) {
        mat = new THREE.MeshBasicMaterial({ color: color });
        particleMaterials[color] = mat;
    }

    for (let i = 0; i < count; i++) {
        const particleSize = isGibs ? (size * (0.5 + random() * 0.5)) : size;
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(particleSize, particleSize, particleSize), mat);
        mesh.position.copy(pos); mesh.position.add(new THREE.Vector3(random() - 0.5, random() - 0.5, random() - 0.5).multiplyScalar(2));
        scene.add(mesh);
        // Ridotto tempo di vita: gibs 2 secondi, particelle normali 0.5 secondi
        const lifeTime = isGibs ? 2.0 : 0.5;
        particles.push({ mesh: mesh, velocity: new THREE.Vector3(random() - 0.5, random() * 0.5 + 0.2, random() - 0.5).normalize().multiplyScalar(speedBase * (random() + 0.5)), life: lifeTime, maxLife: lifeTime, isGib: isGibs });
    }
}

function updateParticles(delta) {
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i]; p.life -= delta; p.velocity.y -= 50.0 * delta;
        p.mesh.position.addScaledVector(p.velocity, delta); p.mesh.rotation.x += delta * 5;
        const scale = p.life / p.maxLife;
        p.mesh.scale.setScalar(scale);
        // Le gibs a terra spariscono gradualmente tramite fade
        if (p.mesh.position.y < 0.5) {
            p.mesh.position.y = 0.5;
            if (p.isGib) {
                p.velocity.y *= -0.5;
                p.velocity.x *= 0.8;
                p.velocity.z *= 0.8;
                // Fade out più rapido quando sono a terra
                p.life -= delta * 2;
            } else {
                p.velocity.set(0, 0, 0);
            }
        }
        if (p.life <= 0) {
            // FIX: Dispose geometry to free GPU memory
            if (p.mesh.geometry) p.mesh.geometry.dispose();
            scene.remove(p.mesh);
            particles.splice(i, 1);
        }
    }
}

function createFloatingText(pos, text, color) {
    const el = document.createElement('div'); el.className = 'floating-text'; el.innerText = text; el.style.color = color; document.body.appendChild(el);
    updateFloatingElement(el, pos); floatingTexts.push({ element: el, pos: pos.clone(), life: 1.0 });
}

function updateFloatingTexts(delta) {
    for (let i = floatingTexts.length - 1; i >= 0; i--) {
        const ft = floatingTexts[i]; ft.life -= delta; ft.pos.y += 5 * delta; updateFloatingElement(ft.element, ft.pos);
        if (ft.life <= 0) { ft.element.remove(); floatingTexts.splice(i, 1); }
    }
}

function updateFloatingElement(el, pos) {
    const screenPos = pos.clone().project(camera);
    const x = (screenPos.x * .5 + .5) * window.innerWidth; const y = (-(screenPos.y * .5) + .5) * window.innerHeight;
    el.style.left = x + 'px'; el.style.top = y + 'px';
}

function spawnExplosionVisual(pos, color, radius) {
    const geometry = new THREE.SphereGeometry(radius, 16, 16);
    const material = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.6, wireframe: true });
    const sphere = new THREE.Mesh(geometry, material); sphere.position.copy(pos); scene.add(sphere);
    const light = new THREE.PointLight(color, 2, radius * 3); light.position.copy(pos); scene.add(light);
    let scale = 1.0;
    const expand = setInterval(() => {
        scale += 0.2; sphere.scale.setScalar(scale); sphere.material.opacity -= 0.05;
        if (sphere.material.opacity <= 0) { clearInterval(expand); scene.remove(sphere); scene.remove(light); geometry.dispose(); material.dispose(); }
    }, 30);
    setTimeout(() => { if (sphere.parent) scene.remove(sphere); if (light.parent) scene.remove(light); }, 1000);
}

function flashScreen(colorStr) { const flash = document.getElementById('screen-flash'); flash.style.backgroundColor = colorStr; flash.style.opacity = 0.4; setTimeout(() => { flash.style.opacity = 0; }, 150); }

function spawnGlowEffect(color) {
    let spawnPos;
    if (weaponMode === 'ranged' || weaponMode === 'bow') {
        const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);
        spawnPos = camera.position.clone().add(camDir.multiplyScalar(3));
        spawnParticles(spawnPos, color, 10, 5, 0.2, false);
    } else {
        spawnPos = playerMesh.position.clone().add(new THREE.Vector3(0, 5, 0));
        spawnParticles(playerMesh.position, color, 15, 15, 0.3, false);
    }
    const light = new THREE.PointLight(color, 8, 30); light.position.copy(spawnPos); scene.add(light);
    let intensity = 8;
    const fade = setInterval(() => { intensity -= 0.4; light.intensity = intensity; if (intensity <= 0) { clearInterval(fade); scene.remove(light); } }, 50);
}

function updateAnimations(delta) {
    const time = performance.now() * 0.005;
    const isMoving = moveForward || moveBackward || moveLeft || moveRight;

    if (playerStats.isDead) { playerMesh.position.y = 6; return; }

    // AGGIORNAMENTO ANIMAZIONI KNIGHT
    // AGGIORNAMENTO ANIMAZIONI KNIGHT
    if (knightModel && knightModel.visible) {
        // FIX: Logic FIRST, then Update Mixer. Prevents 1-frame lag/glitches.
        updateKnightAnimation();

        // DYNAMIC IDLE WEIGHT (Anti-T-Pose Core)
        // Calculate total weight of all other animations to fill gaps with idle
        if (knightAnimations.idle) {
            let totalWeight = 0;
            Object.values(knightAnimations).forEach(action => {
                if (action !== knightAnimations.idle && action.isRunning()) {
                    totalWeight += action.getEffectiveWeight();
                }
            });

            // Idle fills the void. If totalWeight > 1, idle becomes 0.
            // If totalWeight is 0.5 (blending), idle becomes 0.5.
            // If totalWeight is 0 (nothing running), idle becomes 1.0.
            const targetIdleWeight = Math.max(0, 1.0 - totalWeight);
            knightAnimations.idle.setEffectiveWeight(targetIdleWeight);

            // Ensure idle is playing if it has weight
            if (targetIdleWeight > 0.001 && !knightAnimations.idle.isRunning()) {
                knightAnimations.idle.play();
            }
        }

        if (knightMixer) knightMixer.update(delta);
    }

    // AGGIORNAMENTO ANIMAZIONI ARCHER FPS
    if (fpsMageMixer && fpsStaffContainer && fpsStaffContainer.visible) {
        fpsMageMixer.update(delta);

        // Adjust animation speed based on movement
        if (window.fpsMageAction) {
            if (isMoving) {
                const sprinting = (typeof isSprinting !== 'undefined' && isSprinting);
                if (sprinting) {
                    window.fpsMageAction.setEffectiveTimeScale(1.5); // Faster for run
                } else {
                    window.fpsMageAction.setEffectiveTimeScale(1.0); // Normal for walk
                }
            } else {
                window.fpsMageAction.setEffectiveTimeScale(1.0); // Normal for idle
            }
        }
    }

    if (fpsArcherMixer && fpsBowContainer && fpsBowContainer.visible) {
        fpsArcherMixer.update(delta);


        // Smooth Position Transition (ADS - Aim Down Sights)
        if (fpsBowContainer.children.length > 0) {
            const model = fpsBowContainer.children[0];
            if (model.userData && model.userData.targetPosition) {
                // Slower lerp to match the 0.6s cast time (approx 5 * delta)
                model.position.lerp(model.userData.targetPosition, 5 * delta);
            }
        }

        // Logic to switch animations based on mouse input (Aiming) and Movement
        // Priority: Fire > Jump > Aiming > Running > Walking > Idle

        // Let's add a global 'isBowAiming' flag to track mouse state
        if (typeof isBowAiming === 'undefined') window.isBowAiming = false;
        if (typeof archerWasOnGround === 'undefined') window.archerWasOnGround = true;

        // Check Jump State
        const isOnGround = (typeof canJump !== 'undefined' && canJump); // canJump is true when on ground

        // Detect Jump Start
        if (archerWasOnGround && !isOnGround) {
            // Just jumped (or fell)
            if (velocity.y > 0) {
                switchArcherAnimation('Bow_JUMP_START');
            }
        }

        // Detect Jump End (Landing)
        if (!archerWasOnGround && isOnGround) {
            // switchArcherAnimation('Bow_JUMP_END'); // Disabled by user request
        }

        window.archerWasOnGround = isOnGround;

        // Check Priority Animations
        const currentActionName = fpsArcherCurrentAction ? fpsArcherCurrentAction.getClip().name : '';
        const isPriorityAnim = (currentActionName === 'Bow_FIRE' || currentActionName === 'Bow_JUMP_START' || currentActionName === 'Bow_JUMP_END');

        // If a priority animation is playing and running, skip standard movement logic
        if (isPriorityAnim && fpsArcherCurrentAction.isRunning()) {
            // Do nothing, let it play
        } else {
            if (isBowAiming) {
                switchArcherAnimation('Bow_AIM_IDLE');
            } else {
                if (isMoving) {
                    const sprinting = (typeof isSprinting !== 'undefined' && isSprinting);
                    if (sprinting) {
                        switchArcherAnimation('Bow_RUN');
                    } else {
                        switchArcherAnimation('Bow_WALK');
                    }
                } else {
                    switchArcherAnimation('Bow_IDLE');
                }
            }
        }
    }

    const neutralArmY = 8.0;

    if (weaponMode === 'ranged') {
        playerLimbs.armR.position.y = 6.0; playerLimbs.armL.position.y = 6.0;
        playerLimbs.armR.rotation.x = -Math.PI / 2 + Math.sin(time) * 0.05 - (isAttacking ? Math.sin(attackTimer * 2) * 0.5 : 0);
        playerLimbs.armR.rotation.z = 0;
        if (staffContainer.userData.gem) staffContainer.userData.gem.scale.setScalar(isAttacking ? 1.5 : 1.0);
        playerLimbs.armL.rotation.x = -0.5 + Math.cos(time) * 0.1;
        playerLimbs.legL.rotation.x = isMoving ? Math.sin(time * 3) * 0.8 : 0; playerLimbs.legR.rotation.x = isMoving ? -Math.sin(time * 3) * 0.8 : 0;
    } else if (weaponMode === 'bow') {
        playerLimbs.armR.position.y = 6.0; playerLimbs.armL.position.y = 6.0;
        // Braccio sx tiene l'arco (teso in avanti, ma spostato al centro per visuale)
        playerLimbs.armL.rotation.x = -Math.PI / 2;
        playerLimbs.armL.rotation.y = -0.2; // slight adjustment
        playerLimbs.armL.position.x = -0.5; // Center more
        playerLimbs.armL.position.y = 5.5; // Lower slightly
        playerLimbs.armL.position.z = 1.5; // Push forward

        if (castingState.active && castingState.type === 'bow_shot') {
            playerLimbs.armR.rotation.x = -Math.PI / 2;
            playerLimbs.armR.position.z = -Math.sin(castingState.timer * 2) * 1.5 + 1; // Tira indietro
        } else {
            playerLimbs.armR.rotation.x = -0.5;
            playerLimbs.armR.position.z = 0;
        }
        playerLimbs.legL.rotation.x = isMoving ? Math.sin(time * 3) * 0.8 : 0; playerLimbs.legR.rotation.x = isMoving ? -Math.sin(time * 3) * 0.8 : 0;
    } else {
        // Reset positions for melee
        playerLimbs.armL.position.x = -3; playerLimbs.armL.position.z = 0;

        playerLimbs.armR.position.y = neutralArmY; playerLimbs.armL.position.y = neutralArmY;
        if (!canJump && !playerStats.isFalling) {
            playerLimbs.legL.rotation.x = 0.8; playerLimbs.legR.rotation.x = 0.8; playerLimbs.armL.rotation.x = -0.8;
            if (!isAttacking) playerLimbs.armR.rotation.x = -0.8;
        } else if (isMoving) {
            const isSprintingActive = isSprinting && playerStats.stamina > 0; const speedMulti = isSprintingActive ? 8 : 4;
            const armAmp = isSprintingActive ? 1.2 : 0.6; const legAmp = isSprintingActive ? 1.4 : 0.8; const angle = Math.sin(time * speedMulti);
            playerLimbs.legL.rotation.x = angle * legAmp; playerLimbs.legR.rotation.x = -angle * legAmp;
            if (playerLimbs.bootL) playerLimbs.bootL.rotation.x = -playerLimbs.legL.rotation.x * 0.6;
            if (playerLimbs.bootR) playerLimbs.bootR.rotation.x = -playerLimbs.legR.rotation.x * 0.6;
            if (!isAttacking && !isWhirlwinding && !isBlocking) {
                playerLimbs.armL.rotation.x = -angle * armAmp; playerLimbs.armR.rotation.x = angle * armAmp;
            }
            playerLimbs.torso.rotation.x = isSprintingActive ? 0.3 : 0.1;
        } else {
            playerLimbs.legL.rotation.x = 0; playerLimbs.legR.rotation.x = 0;
            if (playerLimbs.bootL) playerLimbs.bootL.rotation.x = 0;
            if (playerLimbs.bootR) playerLimbs.bootR.rotation.x = 0;
            if (!isAttacking && !isWhirlwinding && !isBlocking) {
                playerLimbs.armL.rotation.x = Math.sin(time) * 0.05; playerLimbs.armR.rotation.x = -0.1;
            }
            playerLimbs.torso.rotation.x = 0;
        }
    }

    if (isBlocking) {
        playerLimbs.armL.rotation.set(-Math.PI / 2, 0, Math.PI / 2);
        shieldMesh.visible = true;
    } else {
        playerLimbs.armL.rotation.z = 0;
        shieldMesh.visible = false;
    }

    Object.entries(otherPlayers).forEach(([id, p]) => {
        const mesh = p.mesh;
        if (p.isDead) return;
        const enemyNeutralArmY = p.mesh.userData.weaponMode === 'melee' ? neutralArmY : 6.0;
        p.limbs.armR.position.y = enemyNeutralArmY; p.limbs.armL.position.y = enemyNeutralArmY;
        const distMoved = mesh.position.distanceTo(p.lastStepPos || mesh.position);
        if (distMoved > 4.0) { playSound('step', mesh.position); p.lastStepPos.copy(mesh.position); }

        // INTERPOLATION FIX
        if (typeof window.interpolatePosition === 'function') {
            const smoothPos = window.interpolatePosition(id);
            if (smoothPos) {
                mesh.position.copy(smoothPos);
            } else if (mesh.userData.targetPos) {
                // Fallback (legacy)
                mesh.position.lerp(mesh.userData.targetPos, 0.3);
            }
        }

        if (mesh.userData.targetRot) { mesh.rotation.set(mesh.userData.targetRot.x, mesh.userData.targetRot.y, mesh.userData.targetRot.z); }
        const state = mesh.userData.animState; const limbs = p.limbs; let isEnemyAttacking = false;
        if (mesh.userData.isWhirlwinding) {
            // Only rotate manually if Knight model is NOT visible (legacy behavior)
            if (!p.knightModel || !p.knightModel.visible) {
                mesh.rotation.y += delta * 20;
            }
            limbs.armR.rotation.x = -Math.PI / 2; limbs.armL.rotation.x = -Math.PI / 2;
            // Don't return here, let the Knight animation update happen in updateOtherPlayersAnimations
            // But we need to skip the rest of the low-poly limb updates
            return;
        }
        if (mesh.userData.isAttacking) {
            mesh.userData.attackTimer += delta * 15;
            if (mesh.userData.attackTimer > Math.PI) { mesh.userData.isAttacking = false; mesh.userData.attackTimer = 0; } else {
                isEnemyAttacking = true; const progress = mesh.userData.attackTimer / Math.PI; limbs.armR.rotation.x = -Math.PI / 4 - Math.sin(progress * Math.PI) * 1.5;
            }
        }
        if (!isEnemyAttacking) {
            if (mesh.userData.isBlocking) {
                limbs.armL.rotation.set(-Math.PI / 2, 0, Math.PI / 2);
            } else if (state === 'run' || state === 'walk') {
                const speed = state === 'run' ? 8 : 4; const angle = Math.sin(time * speed);
                limbs.legL.rotation.x = angle; limbs.legR.rotation.x = -angle;
                if (limbs.bootL) limbs.bootL.rotation.x = -limbs.legL.rotation.x * 0.6;
                if (limbs.bootR) limbs.bootR.rotation.x = -limbs.legR.rotation.x * 0.6;
                limbs.armL.rotation.x = -angle; limbs.armR.rotation.x = angle;
                if (p.mesh.userData.weaponMode === 'bow') limbs.armL.rotation.x = -Math.PI / 2; // Enemy bow pose
            } else {
                limbs.legL.rotation.x = 0; limbs.legR.rotation.x = 0;
                if (limbs.bootL) limbs.bootL.rotation.x = 0; if (limbs.bootR) limbs.bootR.rotation.x = 0;
                limbs.armL.rotation.x = Math.sin(time) * 0.05; limbs.armR.rotation.x = -Math.sin(time) * 0.05;
                if (p.mesh.userData.weaponMode === 'bow') limbs.armL.rotation.x = -Math.PI / 2; // Enemy bow pose
            }
        }
        if (mesh.userData.hpBar) mesh.userData.hpBar.parent.lookAt(camera.position);
    });
}

function toggleWeaponManual() { toggleWeapon(); }

function toggleWeapon(force) {
    // Logic updated: Q cycles Melee/Ranged, E selects Bow
    // This function is now mainly for visual updates based on current `weaponMode`

    const isMelee = weaponMode === 'melee';
    const isRanged = weaponMode === 'ranged';
    const isBow = weaponMode === 'bow';

    swordContainer.visible = isMelee;
    staffContainer.visible = isRanged;
    bowContainer.visible = false; // Hide old bow container

    // Manage FPS Archer Model visibility
    if (fpsBowContainer) {
        fpsBowContainer.visible = isBow;
    }
    // Manage FPS Mage Model visibility
    if (fpsStaffContainer) {
        fpsStaffContainer.visible = isRanged;
        console.log('[TOGGLE WEAPON] Mage FPS Container visibility set to:', isRanged);
    } else {
        console.warn('[TOGGLE WEAPON] fpsStaffContainer is NULL');
    }

    // FIX: In prima persona NON mostrare MAI il playerMesh
    playerMesh.visible = isMelee; // Solo in terza persona (melee)

    if (isRanged || isBow) {
        stopBlocking();
        euler.x = 0;
    }

    // NASCONDI SEMPRE il personaggio low-poly - NON DEVE MAI ESSERE VISIBILE
    if (playerLimbs.helmet) playerLimbs.helmet.visible = false;
    if (playerLimbs.torso) playerLimbs.torso.visible = false;
    if (playerLimbs.legL) playerLimbs.legL.visible = false;
    if (playerLimbs.legR) playerLimbs.legR.visible = false;
    playerLimbs.armL.visible = false;
    playerLimbs.armR.visible = false;
    playerMesh.children.forEach(c => { if (c.userData.isTorsoPart) c.visible = false; });

    // Gestisci Knight model
    if (isMelee) {
        // In melee: mostra Knight model in terza persona
        if (knightModel) {
            knightModel.visible = true;
            // Aggiorna colore Knight con team color
            const teamColor = typeof myTeamColor !== 'undefined' ? myTeamColor : 0x2c3e50;
            knightModel.traverse((child) => {
                if (child.isMesh && child.material) {
                    child.material.color.setHex(teamColor);
                }
            });
        }
    } else {
        // In ranged/bow: nascondi Knight, mostra solo arma (staff/bow è già visibile)
        if (knightModel) {
            knightModel.visible = false;
        }
    }

    const modeText = isMelee ? "MELEE" : (isRanged ? "RANGED" : "BOW");
    document.getElementById('weapon-mode-text').innerText = modeText;
    document.getElementById('weapon-mode-text').style.color = isMelee ? "orange" : (isRanged ? "cyan" : "lightgreen");

    const opacity = isMelee ? '0.4' : '1';
    document.querySelectorAll('.action-slot:not(.slot-q):not(.slot-e):not(.slot-r):not(#slot-5):not(#slot-6):not(#slot-7)').forEach(s => s.style.opacity = opacity);

    // Highlight Active Weapon Slot
    document.getElementById('slot-q').classList.remove('active');
    document.getElementById('slot-e').classList.remove('active');

    if (isMelee || isRanged) {
        document.getElementById('slot-q').classList.add('active');
        // FIX: Restore standard near plane for map Z-fighting fix
        if (camera) {
            camera.near = 0.1;
            camera.updateProjectionMatrix();
        }
    } else if (isBow) {
        document.getElementById('slot-e').classList.add('active');
        // FIX: Reduce near plane for Bow to avoid clipping when aiming
        if (camera) {
            camera.near = 0.01;
            camera.updateProjectionMatrix();
        }
    }
}

function updateSwordAnimation(delta) {
    if (isWhirlwinding) {
        const speed = 20; swordContainer.rotation.z = -Math.PI / 2; swordContainer.rotation.y += delta * speed; swordContainer.rotation.x = Math.PI / 2;
        playerLimbs.armR.rotation.x = -Math.PI / 2; playerLimbs.armL.rotation.x = -Math.PI / 2; return;
    }
    if (isAttacking && weaponMode !== 'bow') {
        attackTimer += delta * swordAnimationSpeed; // SYNC FIX: Usa velocità calcolata
        if (attackTimer > Math.PI) {
            isAttacking = false;
            // CORRUPTION FIX: Ferma forzatamente il layer upper quando l'attacco finisce
            if (knightAnimations.attackUpper && knightAnimations.attackUpper.isRunning()) {
                knightAnimations.attackUpper.stop();
                knightAnimations.attackUpper.setEffectiveWeight(0);
            }
        }
    }
    if (weaponMode === 'melee') {
        let targetRotZ = 0;
        let targetRotY = 0;
        let armRotX = 0;

        if (isAttacking) {
            const progress = attackTimer / Math.PI;
            const sweep = Math.cos(progress * Math.PI);
            armRotX = -Math.PI / 4;
            targetRotZ = Math.PI / 2;
            targetRotY = sweep * 1.5;
            swordContainer.rotation.z = targetRotZ;
            swordContainer.rotation.y = targetRotY + Math.PI;
            swordContainer.rotation.x = Math.PI / 2;
            playerLimbs.armR.rotation.x = armRotX;
        } else {
            swordContainer.rotation.set(-Math.PI / 2, Math.PI, 0);
        }
    }
}

function updatePhysics(delta) {
    if (playerStats.mana < playerStats.maxMana) playerStats.mana += SETTINGS.manaRegen * delta;
    if (playerStats.hp < playerStats.maxHp && SETTINGS.hpRegen > 0) playerStats.hp += SETTINGS.hpRegen * delta;

    // FIX: Sprint Cooldown Hysteresis
    if (playerStats.stamina <= 0) {
        if (!sprintCooldown) addToLog("Esausto!", "#ff0000");
        sprintCooldown = true;
    } else if (playerStats.stamina > playerStats.maxStamina * 0.10) { // Reduced to 10%
        sprintCooldown = false;
    }

    let isRegenStaminaBlocked = isBlocking || isWhirlwinding;
    // FIX: Use sprintCooldown check instead of raw stamina > 0
    // ENABLE SPRINT WHILE BLOCKING: Removed !isBlocking check
    if (isSprinting && (moveForward || moveBackward || moveLeft || moveRight) && !sprintCooldown) {
        playerStats.stamina -= SETTINGS.sprintStaminaCostPerSec * delta; isRegenStaminaBlocked = true;
    }
    if (isBlocking) {
        playerStats.stamina -= SETTINGS.blockStaminaCost * delta * 10; if (playerStats.stamina <= 0) stopBlocking(); isRegenStaminaBlocked = true;
    }
    if (!isRegenStaminaBlocked) {
        if (playerStats.stamina < playerStats.maxStamina) playerStats.stamina += SETTINGS.staminaRegen * delta;
    }
    let speed = SETTINGS.speed;
    if (velocity.y != 0) playerStats.isFalling = true;
    // BLOCK PENALTY: Only slow down if NOT sprinting (allows "Running Guard")
    if (isBlocking && !isSprinting) speed *= 0.5;

    // FIX: Use sprintCooldown check
    // ENABLE SPRINT WHILE BLOCKING: Removed !isBlocking check
    if (isSprinting && (moveForward || moveBackward || moveLeft || moveRight) && !sprintCooldown) { speed *= SETTINGS.sprintMulti; }

    velocity.x -= velocity.x * 5 * delta; velocity.z -= velocity.z * 5 * delta; velocity.y -= SETTINGS.gravity * delta;

    const rotY = playerMesh.rotation.y;
    let moving = false;
    const moveVec = new THREE.Vector3();
    if (moveForward) { moveVec.add(new THREE.Vector3(-Math.sin(rotY), 0, -Math.cos(rotY))); moving = true; }
    if (moveBackward) { moveVec.add(new THREE.Vector3(-Math.sin(rotY), 0, -Math.cos(rotY)).negate()); moving = true; }
    if (moveRight) { moveVec.add(new THREE.Vector3(Math.cos(rotY), 0, -Math.sin(rotY))); moving = true; }
    if (moveLeft) { moveVec.add(new THREE.Vector3(Math.cos(rotY), 0, -Math.sin(rotY)).negate()); moving = true; }
    if (moving) {
        moveVec.normalize(); velocity.addScaledVector(moveVec, speed * delta);
        if (!playerStats.isFalling) { distanceSinceStep += speed * delta; if (distanceSinceStep > 400.0) { playSound('step'); distanceSinceStep = 0; } }
    }
    playerMesh.position.addScaledVector(velocity, delta);
    if (playerMesh.position.y <= 6) {
        if (velocity.y <= 0) {
            playerMesh.position.y = 6;
            velocity.y = 0;
            canJump = true;
            playerStats.isFalling = false;
        }
    } else {
        canJump = false;
    }
    playerStats.stamina = Math.max(0, Math.min(playerStats.maxStamina, playerStats.stamina));



    obstacles.forEach(o => {
        const box = new THREE.Box3().setFromObject(o);
        // Check collision at player's feet level (y + 2) and head level (y + 10)
        const playerFeetPos = playerMesh.position.clone();
        playerFeetPos.y += 2;
        const playerHeadPos = playerMesh.position.clone();
        playerHeadPos.y += 10;

        // Only collide if obstacle is tall enough (above feet but below head)
        const obstacleHeight = box.max.y - box.min.y;
        const playerBaseY = playerMesh.position.y;

        // Check if player horizontally overlaps with obstacle
        const tempBox = box.clone();
        tempBox.min.y = playerBaseY;
        tempBox.max.y = playerBaseY + 12; // Player height

        if (tempBox.containsPoint(playerFeetPos) || tempBox.containsPoint(playerHeadPos)) {
            // Only push back if obstacle is taller than jump height (>8 units)
            if (obstacleHeight > 8 || box.max.y > playerBaseY + 5) {
                const dir = new THREE.Vector3().subVectors(playerMesh.position, o.position).normalize().setY(0);
                playerMesh.position.addScaledVector(dir, 10 * delta * 60);
            }
        }
    });

    // NUOVO: Collisioni player-to-player (previene che i giocatori si attraversino)
    Object.values(otherPlayers).forEach(op => {
        if (!op.mesh) return;

        const otherPos = op.mesh.position;
        const myPos = playerMesh.position;

        // Calcola distanza orizzontale (XZ) e verticale (Y)
        const dx = myPos.x - otherPos.x;
        const dz = myPos.z - otherPos.z;
        const distXZ = Math.sqrt(dx * dx + dz * dz);
        const dy = Math.abs(myPos.y - otherPos.y);

        // Parametri di collisione
        const collisionRadius = 8.0; // Raggio di collisione tra giocatori
        const collisionHeight = 12.0; // Altezza del cilindro di collisione

        // Verifica se i giocatori si sovrappongono
        if (distXZ < collisionRadius && dy < collisionHeight) {
            // Calcola direzione di separazione (solo XZ, mantieni Y)
            const pushDir = new THREE.Vector3(dx, 0, dz);

            // Se i giocatori sono esattamente nella stessa posizione, usa direzione casuale
            if (pushDir.lengthSq() < 0.001) {
                pushDir.set(Math.random() - 0.5, 0, Math.random() - 0.5);
            }

            pushDir.normalize();

            // Calcola quanto devono essere separati
            const overlap = collisionRadius - distXZ;
            const pushStrength = overlap * 5 * delta * 60; // Forza ridotta per evitare rimbalzi scattosi

            // Sposta il giocatore locale gradualmente
            playerMesh.position.addScaledVector(pushDir, pushStrength);

            // Applica resistenza al movimento per collisione più fluida
            velocity.x *= 0.8;
            velocity.z *= 0.8;
        }
    });
    if (socket && myId) {
        // FIX: Anim state should reflect actual speed (walk if cooldown)
        const animState = !canJump ? 'jump' : ((isSprinting && !sprintCooldown) ? 'run' : (moving) ? 'walk' : 'idle');
        socket.emit('playerMovement', { position: playerMesh.position, rotation: { x: playerMesh.rotation.x, y: playerMesh.rotation.y, z: playerMesh.rotation.z }, animState: animState, weaponMode: weaponMode });
    }
}

function updateCamera() {
    const headPos = playerMesh.position.clone().add(new THREE.Vector3(0, 8.5, 0));
    if (weaponMode === 'ranged' || weaponMode === 'bow') {
        // FIX: Prima persona - posiziona camera nella testa, NON mostrare playerMesh
        camera.position.copy(headPos).addScaledVector(new THREE.Vector3(0, 0, -1).applyEuler(euler), 0.5);
        camera.quaternion.setFromEuler(euler);
        // playerMesh.visible = false; // GIÀ gestito in toggleWeapon
    } else {
        // Terza persona per melee - FIX: Camera più bassa per mirare più in alto
        // Offset Y a 5 - mirino punta verso l'orizzonte
        const offset = new THREE.Vector3(0, 5, 25).applyEuler(new THREE.Euler(euler.x, euler.y, 0, 'YXZ'));
        camera.position.copy(headPos).add(offset);
        const lookAtPoint = playerMesh.position.clone().add(new THREE.Vector3(0, 12, 0));
        camera.lookAt(lookAtPoint);
    }
}

// --- ENEMY KNIGHT MODEL IMPLEMENTATION ---

function loadEnemyKnightModel(playerObj) {
    if (playerObj.knightModel) return; // Già caricato

    const loader = new THREE.GLTFLoader();
    const cacheBuster = Date.now();
    loader.load(`./models/Knight_Met_2.glb?v=${cacheBuster}`, (gltf) => {
        // DEFENSIVE LOADING: Cleanup existing model if present
        if (playerObj.knightModel) {
            console.warn('[ENEMY] Existing model detected for', playerObj.username, '! Cleaning up...');
            if (playerObj.knightMixer) {
                playerObj.knightMixer.stopAllAction();
                playerObj.knightMixer.uncacheRoot(playerObj.knightModel);
                playerObj.knightMixer = null; // FIX: Prevent access to disposed mixer
                playerObj.knightAnimations = {}; // FIX: Clear old animations
            }
            if (playerObj.mesh) playerObj.mesh.remove(playerObj.knightModel);
            playerObj.knightModel.traverse((child) => {
                if (child.isMesh) {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) child.material.forEach(m => m.dispose());
                        else child.material.dispose();
                    }
                }
            });
            playerObj.knightModel = null;
        }

        const model = gltf.scene;

        model.scale.set(10, 10, 10);
        model.position.set(0, -6.0, 0); // Lowered to touch ground (Player pivot is at y=6)
        model.rotation.y = Math.PI;

        // ALWAYS VISIBLE - Hide low poly parts permanently
        model.visible = true;
        if (playerObj.limbs) {
            if (playerObj.limbs.torso) playerObj.limbs.torso.visible = false;
            if (playerObj.limbs.chest) playerObj.limbs.chest.visible = false;
            if (playerObj.limbs.legL) playerObj.limbs.legL.visible = false;
            if (playerObj.limbs.legR) playerObj.limbs.legR.visible = false;
            if (playerObj.limbs.armL) playerObj.limbs.armL.visible = false;
            if (playerObj.limbs.armR) playerObj.limbs.armR.visible = false;
            if (playerObj.limbs.head) playerObj.limbs.head.visible = false;
        }

        // Apply Team Color
        const teamColor = playerObj.teamColor || 0x2c3e50;
        console.log(`[ENEMY-COLOR] Applying color to ${playerObj.username}:`, teamColor);
        model.traverse((child) => {
            if (child.isMesh && child.material) {
                // Match Local Player Settings: 100% tint (Full Color)
                const tintColor = new THREE.Color(0xffffff).lerp(new THREE.Color(teamColor), 1.0);
                child.material.color.copy(tintColor);

                // Remove emissive to avoid washing out texture (same as local player)
                child.material.emissive = new THREE.Color(0x000000);
                child.material.emissiveIntensity = 0.0;

                child.material.metalness = 0.5;
                child.material.roughness = 0.5;

                // FIX: Disabilita frustum culling per evitare scomparsa quando vicino alla camera
                child.frustumCulled = false;
            }
        });

        playerObj.mesh.add(model);
        playerObj.knightModel = model;

        // Setup Animation Mixer
        const mixer = new THREE.AnimationMixer(model);
        playerObj.knightMixer = mixer;
        playerObj.knightAnimations = {};
        playerObj.currentKnightAction = null;

        // MAP ANIMATIONS EXACTLY LIKE LOCAL PLAYER
        if (gltf.animations && gltf.animations.length > 0) {
            console.log(`[ENEMY-LOAD] Animations found for ${playerObj.username}:`, gltf.animations.map(c => c.name));
            gltf.animations.forEach((clip) => {
                const name = clip.name.toLowerCase();
                if (name.includes('.001') || name.includes('mixamo.com')) return; // SKIP DUPLICATES & JUNK
                let action = null;

                if (name.includes('walk') && !name.includes('block') || name.includes('wal')) {
                    // Remove root motion for walk
                    const tracks = clip.tracks.filter(t => !t.name.includes('.position') || (!t.name.toLowerCase().includes('hips') && !t.name.toLowerCase().includes('mixamorig')));
                    const newClip = new THREE.AnimationClip(clip.name, clip.duration, tracks);
                    action = mixer.clipAction(newClip);
                    action.setLoop(THREE.LoopRepeat);
                    playerObj.knightAnimations.walk = action;
                } else if (name.includes('run')) {
                    const tracks = clip.tracks.filter(t => !t.name.includes('.position') || (!t.name.toLowerCase().includes('hips') && !t.name.toLowerCase().includes('mixamorig')));
                    const newClip = new THREE.AnimationClip(clip.name, clip.duration, tracks);
                    action = mixer.clipAction(newClip);
                    action.setLoop(THREE.LoopRepeat);
                    playerObj.knightAnimations.run = action;
                } else if (name.includes('idle') && !name.includes('block')) {
                    action = mixer.clipAction(clip);
                    action.setLoop(THREE.LoopRepeat);
                    playerObj.knightAnimations.idle = action;
                } else if (name.includes('jump')) {
                    // Remove root motion for jump (as requested)
                    const tracks = clip.tracks.filter(t => !t.name.includes('.position') || (!t.name.toLowerCase().includes('hips') && !t.name.toLowerCase().includes('mixamorig')));
                    const newClip = new THREE.AnimationClip(clip.name, clip.duration, tracks);
                    action = mixer.clipAction(newClip);
                    action.setLoop(THREE.LoopOnce);
                    action.clampWhenFinished = true;
                    playerObj.knightAnimations.jump = action;
                } else if ((name.includes('cast') && name.includes('1')) || name === 'cast 1' || name === 'cast1') {
                    action = mixer.clipAction(clip);
                    action.setLoop(THREE.LoopOnce);
                    action.clampWhenFinished = true; // FIX T-POSE: Hold final pose until transition
                    action.repetitions = 1;
                    playerObj.knightAnimations.cast = action;
                    console.log(`[ENEMY-LOAD] Mapped cast animation for ${playerObj.username}`);
                } else if (name.includes('attack') || name.includes('slash')) {
                    // Use the first attack found or specific one if needed
                    if (!playerObj.knightAnimations.attack) {
                        action = mixer.clipAction(clip);
                        action.setLoop(THREE.LoopOnce);
                        action.clampWhenFinished = true; // FIX T-POSE
                        action.timeScale = 1.5; // Match local player speed
                        playerObj.knightAnimations.attack = action;
                    }
                } else if (name.includes('spin') || name.includes('whirlwind')) {
                    // Remove root motion
                    const tracks = clip.tracks.filter(t => !t.name.includes('.position') || (!t.name.toLowerCase().includes('hips') && !t.name.toLowerCase().includes('mixamorig')));
                    const newClip = new THREE.AnimationClip(clip.name, clip.duration, tracks);
                    action = mixer.clipAction(newClip);
                    action.setLoop(THREE.LoopOnce);
                    action.clampWhenFinished = true; // FIX T-POSE
                    action.timeScale = 1.5;
                    playerObj.knightAnimations.whirlwind = action;
                } else if (name.includes('powerup') || name.includes('roar') || name.includes('buff') || name.includes('shout')) {
                    // Use original clip to match local player and avoid bugs
                    action = mixer.clipAction(clip);
                    action.setLoop(THREE.LoopOnce);
                    action.clampWhenFinished = true;
                    playerObj.knightAnimations.powerup = action;
                } else if (name.includes('strafe')) {
                    // Remove root motion for strafe
                    const tracks = clip.tracks.filter(t => !t.name.includes('.position') || (!t.name.toLowerCase().includes('hips') && !t.name.toLowerCase().includes('mixamorig')));
                    const newClip = new THREE.AnimationClip(clip.name, clip.duration, tracks);
                    action = mixer.clipAction(newClip);
                    action.setLoop(THREE.LoopRepeat);
                    playerObj.knightAnimations.strafe = action;
                } else if (name.includes('idle') && name.includes('block')) {
                    action = mixer.clipAction(clip);
                    action.setLoop(THREE.LoopRepeat);
                    playerObj.knightAnimations.blockIdle = action;
                } else if (name.includes('block') || name.includes('shield')) {
                    action = mixer.clipAction(clip);
                    action.setLoop(THREE.LoopRepeat);
                    playerObj.knightAnimations.block = action;
                } else if (name.includes('death') || name.includes('die')) {
                    // Animazione morte
                    action = mixer.clipAction(clip);
                    action.setLoop(THREE.LoopOnce);
                    action.clampWhenFinished = true;
                    playerObj.knightAnimations.death = action;
                    console.log(`[ENEMY-LOAD] Mapped death animation for ${playerObj.username}`);
                }
            });

            // --- LAYERED ANIMATION SETUP FOR ENEMY ---
            const upperBodyBones = [];
            const lowerBodyBones = [];

            model.traverse((node) => {
                if (node.isBone) {
                    const boneName = node.name.toLowerCase();
                    if (boneName.includes('spine') || boneName.includes('chest') ||
                        boneName.includes('neck') || boneName.includes('head') ||
                        boneName.includes('shoulder') || boneName.includes('arm') ||
                        boneName.includes('hand') || boneName.includes('finger') ||
                        boneName.includes('clavicle')) {
                        upperBodyBones.push(node);
                    } else if (boneName.includes('hips') || boneName.includes('leg') ||
                        boneName.includes('thigh') || boneName.includes('calf') ||
                        boneName.includes('foot') || boneName.includes('toe')) {
                        lowerBodyBones.push(node);
                    }
                }
            });

            // Create Layered Clips
            // 1. Block Upper (from blockIdle if available, else block)
            if (playerObj.knightAnimations.blockIdle && upperBodyBones.length > 0) {
                const originalClip = playerObj.knightAnimations.blockIdle.getClip();
                const upperClip = createLayeredClip(originalClip, upperBodyBones, 'blockIdle_upperBody');
                playerObj.knightAnimations.blockUpper = mixer.clipAction(upperClip);
                playerObj.knightAnimations.blockUpper.setLoop(THREE.LoopRepeat);
                console.log(`[ENEMY-LOAD] Created blockUpper from blockIdle for ${playerObj.username}`);
            } else if (playerObj.knightAnimations.block && upperBodyBones.length > 0) {
                const originalClip = playerObj.knightAnimations.block.getClip();
                const upperClip = createLayeredClip(originalClip, upperBodyBones, 'block_upperBody');
                playerObj.knightAnimations.blockUpper = mixer.clipAction(upperClip);
                playerObj.knightAnimations.blockUpper.setLoop(THREE.LoopRepeat);
                console.log(`[ENEMY-LOAD] Created blockUpper from block for ${playerObj.username}`);
            }

            // 2. Strafe Lower
            if (playerObj.knightAnimations.strafe && lowerBodyBones.length > 0) {
                const originalClip = playerObj.knightAnimations.strafe.getClip();
                const lowerClip = createLayeredClip(originalClip, lowerBodyBones, 'strafe_lowerBody');
                playerObj.knightAnimations.strafeLower = mixer.clipAction(lowerClip);
                playerObj.knightAnimations.strafeLower.setLoop(THREE.LoopRepeat);
                console.log(`[ENEMY-LOAD] Created strafeLower for ${playerObj.username}`);
            } else {
                console.warn(`[ENEMY-LOAD] Failed to create strafeLower for ${playerObj.username}. Strafe: ${!!playerObj.knightAnimations.strafe}, Bones: ${lowerBodyBones.length}`);
            }

            // 3. Walk/Run Lower (for Powerup layering)
            if (playerObj.knightAnimations.walk && lowerBodyBones.length > 0) {
                const originalClip = playerObj.knightAnimations.walk.getClip();
                const lowerClip = createLayeredClip(originalClip, lowerBodyBones, 'walk_lowerBody');
                playerObj.knightAnimations.walkLower = mixer.clipAction(lowerClip);
                playerObj.knightAnimations.walkLower.setLoop(THREE.LoopRepeat);
                console.log(`[ENEMY-LOAD] Created walkLower for ${playerObj.username}`);
            }
            if (playerObj.knightAnimations.run && lowerBodyBones.length > 0) {
                const originalClip = playerObj.knightAnimations.run.getClip();
                const lowerClip = createLayeredClip(originalClip, lowerBodyBones, 'run_lowerBody');
                playerObj.knightAnimations.runLower = mixer.clipAction(lowerClip);
                playerObj.knightAnimations.runLower.setLoop(THREE.LoopRepeat);
                console.log(`[ENEMY-LOAD] Created runLower for ${playerObj.username}`);
            }

            // 5. Cast Upper
            if (playerObj.knightAnimations.cast && upperBodyBones.length > 0) {
                const originalClip = playerObj.knightAnimations.cast.getClip();
                const upperClip = createLayeredClip(originalClip, upperBodyBones, 'cast_upperBody');
                playerObj.knightAnimations.castUpper = mixer.clipAction(upperClip);
                playerObj.knightAnimations.castUpper.setLoop(THREE.LoopOnce);
                playerObj.knightAnimations.castUpper.clampWhenFinished = true;
                console.log(`[ENEMY-LOAD] Created castUpper for ${playerObj.username}`);
            }

            // --- LOAD ARCHER MODEL (NESTED) ---
            const archerLoader = new THREE.GLTFLoader();
            archerLoader.load(`./models/Knight_archer_4.glb?v=${cacheBuster}`, (archerGltf) => {
                console.log(`[ENEMY-LOAD] Loaded Knight_archer_4 for ${playerObj.username}`);
                const archerModel = archerGltf.scene;

                // Align with Knight Model
                archerModel.scale.set(10, 10, 10);
                archerModel.position.set(0, -6.0, 0); // Same level as Knight Met
                archerModel.rotation.y = Math.PI;
                archerModel.visible = false; // Hidden by default

                // Apply Team Color to Archer
                archerModel.traverse((child) => {
                    if (child.isMesh && child.material) {
                        const tintColor = new THREE.Color(0xffffff).lerp(new THREE.Color(teamColor), 1.0);
                        child.material.color.copy(tintColor);
                        child.material.emissive = new THREE.Color(0x000000);
                        child.material.emissiveIntensity = 0.0;
                        child.material.metalness = 0.5;
                        child.material.roughness = 0.5;
                        child.frustumCulled = false;
                    }
                });

                playerObj.mesh.add(archerModel);
                playerObj.archerModel = archerModel;

                // Setup Archer Mixer
                const archerMixer = new THREE.AnimationMixer(archerModel);
                playerObj.archerMixer = archerMixer;
                playerObj.archerAnimations = {};

                // LISTEN FOR FINISHED EVENT
                archerMixer.addEventListener('finished', (e) => {
                    // If attack finishes, go back to idle/run
                    if (playerObj.archerAnimations.attack && e.action === playerObj.archerAnimations.attack) {
                        // console.log(`[ARCHER] Attack finished for ${playerObj.username}`);
                        // Force transition back to base state
                        const baseAnim = (playerObj.mesh.userData.animState === 'run') ? playerObj.archerAnimations.run :
                            (playerObj.mesh.userData.animState === 'walk') ? playerObj.archerAnimations.walk :
                                playerObj.archerAnimations.idle;

                        if (baseAnim) {
                            if (playerObj.currentArcherAction) playerObj.currentArcherAction.fadeOut(0.2);
                            baseAnim.reset().fadeIn(0.2).play();
                            playerObj.currentArcherAction = baseAnim;
                        }

                        // IMPORTANT: Clear the attacking flag so update loop doesn't force attack again
                        playerObj.mesh.userData.isAttacking = false;
                    }
                });

                if (archerGltf.animations) {
                    archerGltf.animations.forEach((clip) => {
                        const name = clip.name.toLowerCase();
                        let action = null;

                        if (name.includes('bow_run')) {
                            // 1. Run Animation
                            action = archerMixer.clipAction(clip);
                            action.setLoop(THREE.LoopRepeat);
                            playerObj.archerAnimations.run = action;
                            playerObj.archerAnimations.walk = action; // Use run for walk too

                        } else if (name.includes('bow_walk')) {
                            // 2. Walk Animation
                            action = archerMixer.clipAction(clip);
                            action.setLoop(THREE.LoopRepeat);
                            playerObj.archerAnimations.walk = action;

                        } else if (name.includes('bowidle_2')) {
                            // 2. Native Bow Idle
                            action = archerMixer.clipAction(clip);
                            action.setLoop(THREE.LoopRepeat);
                            playerObj.archerAnimations.idle = action;
                            console.log(`[ENEMY-LOAD] Mapped native bowidle_2 for ${playerObj.username}`);

                        } else if (name.includes('bowjump_2')) {
                            // 4. Jump Animation
                            action = archerMixer.clipAction(clip);
                            action.setLoop(THREE.LoopOnce);
                            action.clampWhenFinished = true;
                            playerObj.archerAnimations.jump = action;

                        } else if (name.includes('bowaimidle_2')) {
                            // 5. Aim Hold Animation (Charging)
                            action = archerMixer.clipAction(clip);
                            action.setLoop(THREE.LoopRepeat);
                            playerObj.archerAnimations.aimHold = action;

                        } else if (name.includes('bowaimwalk')) {
                            // 7. Aim Walk Animation (Moving while aiming)
                            action = archerMixer.clipAction(clip);
                            action.setLoop(THREE.LoopRepeat);
                            playerObj.archerAnimations.aimWalk = action;

                        } else if (name.includes('bowfire_2')) {
                            // 6. Attack Animation (Fire)
                            action = archerMixer.clipAction(clip);
                            action.setLoop(THREE.LoopOnce);
                            action.clampWhenFinished = true;

                            // Sync speed with bowCastTime
                            // If castTime is 0.6s, we want the animation to feel responsive.
                            // Usually fire animation is fast. Let's keep it 1.0 or scale it if needed.
                            // User request: "velocity based on bow cast time".
                            // If clip duration is D, and we want it to take T seconds: timeScale = D / T.
                            // But usually fire is instant. Let's assume they want it to match the rhythm.
                            // For now, let's calculate it based on SETTINGS.bowCastTime if available, else 1.0.
                            const castTime = (typeof SETTINGS !== 'undefined' && SETTINGS.bowCastTime) ? SETTINGS.bowCastTime : 0.6;
                            // If clip is 1.2s and castTime is 0.6s, speed = 2.0.
                            // Let's assume standard speed 1.0 is fine, but if user insists on "based on cast time":
                            if (clip.duration > 0) {
                                // Make the fire animation take exactly the cast time? That might be too slow for an arrow release.
                                // Maybe they mean the AIMING? But they said "bowfire_2".
                                // Let's try to make it slightly faster than cast time to be snappy.
                                // Let's just set it to 1.0 for now as per previous instruction "revert to 1.0", 
                                // but since they asked "speed based on cast time", I will add a comment or logic if needed.
                                // Actually, let's set it to match the cast time for consistency if that's what they want.
                                // action.timeScale = clip.duration / castTime; 
                                // But release should be fast. Let's stick to 1.0 unless explicitly told to slow down again.
                                // User said: "vorrei che l animazione bowfire_2 abbia la velocità in base al tempo di cast dell arco"
                                // Let's try to scale it to be fast but related. 
                                // Let's leave it at 1.0 for now to avoid "cut off" issues, as 0.8 caused issues.
                                action.timeScale = 1.0;
                            }
                            playerObj.archerAnimations.attack = action;
                        }
                    });
                }
            });

        }

        // Evento quando finisce un'animazione one-shot (FIX T-POSE)
        mixer.addEventListener('finished', (e) => {
            // Se finisce un'animazione che non è loop, torna a idle/run
            if (e.action === playerObj.knightAnimations.cast ||
                e.action === playerObj.knightAnimations.attack ||
                e.action === playerObj.knightAnimations.powerup ||
                e.action === playerObj.knightAnimations.whirlwind) {

                console.log(`[ENEMY-ANIM] Finished ${e.action.getClip().name}, returning to state...`);

                // Se il player sta ancora facendo qualcosa (es. hold), non interrompere
                if (playerObj.mesh.userData.isHoldingSpell) return;

                // Altrimenti torna all'animazione di base (idle o run)
                const baseAnim = (playerObj.mesh.userData.animState === 'run') ? 'run' :
                    (playerObj.mesh.userData.animState === 'walk') ? 'walk' : 'idle';

                playEnemyKnightAnimation(playerObj, baseAnim, false);
            }
        });

        // Start Idle
        if (playerObj.knightAnimations.idle) {
            playerObj.knightAnimations.idle.play();
            playerObj.currentKnightAction = playerObj.knightAnimations.idle;
        }

        console.log(`[ENEMY] Knight model loaded for ${playerObj.username}`);
    });
}

function playEnemyKnightAnimation(playerObj, name, isOneShot = false, forceRestart = false) {
    // SPECIAL HANDLING: CAST HOLD (Pause cast animation in middle)
    // Must be before check for knightAnimations[name] because castHold is not in the list
    if (name === 'castHold') {
        let action = playerObj.knightAnimations ? playerObj.knightAnimations.cast : null;

        // Fallback to attack if cast is missing (Safety net)
        if (!action && playerObj.knightAnimations && playerObj.knightAnimations.attack) {
            console.warn(`[ANIM-DEBUG] castHold: 'cast' missing for ${playerObj.username}, using 'attack' fallback.`);
            action = playerObj.knightAnimations.attack;
        }

        if (action) {
            // Se stiamo già facendo cast/attack, non resettare, ma congela
            if (playerObj.currentKnightAction !== action) {
                console.log(`[ANIM-DEBUG] Starting castHold for ${playerObj.username} (Action: ${action.getClip().name})`);
                if (playerObj.currentKnightAction) playerObj.currentKnightAction.fadeOut(0.2);
                action.reset();
                action.fadeIn(0.2);
                action.play();
                playerObj.currentKnightAction = action;
            }

            // Congela a metà (FORCE EVERY FRAME)
            // Fix: Ensure we are not at 0 time if we just reset
            if (action.time === 0) action.time = action.getClip().duration * 0.5;

            action.timeScale = 0;
            return true;
        }
        console.error(`[ANIM-DEBUG] castHold failed: No suitable animation found for ${playerObj.username}`);
        return false;
    }

    if (!playerObj.knightAnimations) {
        // console.warn(`[ANIM-DEBUG] No knightAnimations for ${playerObj.username}`);
        return false;
    }
    if (!playerObj.knightAnimations[name]) {
        // console.warn(`[ANIM-DEBUG] Animation '${name}' not found for ${playerObj.username}. Trying fallbacks.`);

        // FALLBACK CHAIN
        let fallbackName = 'idle';
        if (name === 'powerup') fallbackName = 'attack'; // If powerup missing, try attack
        else if (name === 'whirlwind') fallbackName = 'attack'; // If whirlwind missing, try attack
        else if (name === 'cast') fallbackName = 'attack'; // If cast missing, try attack
        else if (name === 'jump') fallbackName = 'idle'; // If jump missing, use idle

        // Try fallback
        if (playerObj.knightAnimations[fallbackName]) {
            // console.log(`[ANIM-DEBUG] Using fallback '${fallbackName}' for '${name}'`);
            // Recursive call with fallback, but ensure we don't loop infinitely
            if (fallbackName !== name) {
                return playEnemyKnightAnimation(playerObj, fallbackName, isOneShot);
            }
        }

        // FINAL RESORT: FORCE IDLE
        if (playerObj.knightAnimations.idle) {
            const idleAction = playerObj.knightAnimations.idle;
            if (playerObj.currentKnightAction !== idleAction) {
                if (playerObj.currentKnightAction) playerObj.currentKnightAction.fadeOut(0.2);
                idleAction.reset();
                idleAction.fadeIn(0.2);
                idleAction.play();
                playerObj.currentKnightAction = idleAction;
            }
        }
        return false;
    }

    console.log(`[ANIM-DEBUG] Playing '${name}' for ${playerObj.username} (OneShot: ${isOneShot})`);

    // DUPLICATE REMOVED

    const newAction = playerObj.knightAnimations[name];

    // Prevent restarting if already playing (unless forced)
    // This fixes the T-pose/glitch when 'jump' state is sent continuously
    if (playerObj.currentKnightAction === newAction && newAction.isRunning() && !forceRestart) {
        // Se è cast ed era congelato (hold), scongelalo!
        if (name === 'cast' && newAction.timeScale === 0) {
            newAction.timeScale = 1;
        }
        return true;
    }

    if (playerObj.currentKnightAction && playerObj.currentKnightAction !== newAction) {
        playerObj.currentKnightAction.fadeOut(0.2);
    }

    newAction.reset();

    // Default timeScale
    let timeScale = 1.0;
    if (name === 'death') timeScale = 0.7; // Slow down death as requested

    newAction.timeScale = timeScale;
    newAction.setEffectiveTimeScale(timeScale);
    newAction.setEffectiveWeight(1);

    // FIX T-POSE: Don't fade in combat animations, snap to them for responsiveness and to avoid low-weight gaps
    const isCombatAnim = (name === 'attack' || name === 'cast' || name === 'whirlwind' || name === 'powerup');
    if (!isCombatAnim) {
        newAction.fadeIn(0.2);
    }

    newAction.play();
    playerObj.currentKnightAction = newAction;

    if (isOneShot) {
        playerObj.isPerformingOneShot = true;
        const onFinished = (e) => {
            if (e.action === newAction) {
                playerObj.knightMixer.removeEventListener('finished', onFinished);
                playerObj.isPerformingOneShot = false;
                // Fallback to idle will happen in update loop
            }
        };
        playerObj.knightMixer.addEventListener('finished', onFinished);
    } else {
        playerObj.isPerformingOneShot = false;
    }
    return true;
}

function updateOtherPlayersAnimations(delta) {
    Object.values(otherPlayers).forEach(p => {
        // --- ARCHER ANIMATION UPDATE ---
        if (p.archerMixer && p.archerModel && p.archerModel.visible) {
            p.archerMixer.update(delta);

            const anims = p.archerAnimations;
            if (anims) {
                let desiredAction = anims.idle;

                // Determine desired animation
                // Note: isAttacking is set by network events (enemyAttacked)
                // We might need to handle one-shot attack logic similar to Knight if needed,
                // but for now simple state check:

                // Determine desired animation
                const isMoving = (p.mesh.userData.animState === 'run' || p.mesh.userData.animState === 'walk');

                if (p.mesh.userData.isHoldingSpell) {
                    if (isMoving && anims.aimWalk) {
                        desiredAction = anims.aimWalk;
                    } else if (anims.aimHold) {
                        desiredAction = anims.aimHold;
                    }
                } else if (p.mesh.userData.isAttacking) {
                    desiredAction = anims.attack;
                } else if (p.mesh.userData.animState === 'jump') {
                    desiredAction = anims.jump;
                } else if (p.mesh.userData.animState === 'run') {
                    desiredAction = anims.run;
                } else if (p.mesh.userData.animState === 'walk') {
                    desiredAction = anims.walk;
                }

                // Transition
                if (desiredAction && p.currentArcherAction !== desiredAction) {
                    if (p.currentArcherAction) p.currentArcherAction.fadeOut(0.2);
                    desiredAction.reset().fadeIn(0.2).play();
                    p.currentArcherAction = desiredAction;
                }

                // Handle Attack One-Shot finish
                if (desiredAction === anims.attack) {
                    // If attack finished, reset isAttacking (or rely on network/timer?)
                    // Network usually sends 'isAttacking' state or we trigger it.
                    // The existing knight logic uses p.mesh.userData.isAttacking which comes from network updates?
                    // Actually p.mesh.userData.isAttacking is set in network.js or game.js?
                    // Let's check knight logic. Knight logic uses playEnemyKnightAnimation which handles one-shots.
                    // For simplicity, if attack finishes, we should probably go back to idle.
                    // But let's stick to the simple state machine for now.
                }
            }
        }

        if (p.knightMixer && p.knightModel && p.knightModel.visible) {
            // FIX: Dead players should not update animations (prevents pop-up glitch)
            if (p.mesh.userData.isDead) {
                p.knightMixer.update(delta);
                return;
            }

            // FIX: Se il player sta caricando una magia (Hold), non aggiornare animazioni di movimento
            if (p.mesh.userData.isHoldingSpell) {
                // Assicurati che l'animazione corrente sia castHold (o cast in pausa)
                // Se per qualche motivo non lo è, forzala
                if (p.currentKnightAction !== p.knightAnimations.cast) {
                    playEnemyKnightAnimation(p, 'castHold');
                }
                // Skip movement animation update
                p.knightMixer.update(delta);
                return;
            }
            p.knightMixer.update(delta);

            // Logic to update state based on p.mesh.userData
            const state = p.mesh.userData.animState; // idle, walk, run
            const isAttacking = p.mesh.userData.isAttacking;
            const isWhirlwinding = p.mesh.userData.isWhirlwinding;
            const isBlocking = p.mesh.userData.isBlocking;

            // Handle Powerup Timer locally since it's not in the main loop
            if (p.mesh.userData.isPoweringUp) {
                p.mesh.userData.powerupTimer = (p.mesh.userData.powerupTimer || 0) + delta * 15;
                if (p.mesh.userData.powerupTimer > Math.PI) { // Approx 1s duration
                    p.mesh.userData.isPoweringUp = false;
                    p.mesh.userData.powerupTimer = 0;
                }
            }
            const isPoweringUp = p.mesh.userData.isPoweringUp;

            // Priority: Whirlwind > Block > Powerup > Attack > Movement > Idle
            // REORDERED: Block is now higher priority than Powerup/Attack/OneShot

            // 1. Whirlwind (High Priority State)
            if (isWhirlwinding) {
                if (playEnemyKnightAnimation(p, 'whirlwind', true)) return;
            }

            // 2. Blocking (High Priority - Interrupts Powerup/Attack)
            if (isBlocking) {
                // Stop conflicting one-shot animations (Powerup, Attack)
                // FIX T-POSE: Use fadeOut instead of stop to avoid frame with no animation
                if (p.knightAnimations.powerup && p.knightAnimations.powerup.isRunning()) p.knightAnimations.powerup.fadeOut(0.2);
                if (p.knightAnimations.powerupUpper && p.knightAnimations.powerupUpper.isRunning()) p.knightAnimations.powerupUpper.fadeOut(0.2);
                if (p.knightAnimations.attack && p.knightAnimations.attack.isRunning()) p.knightAnimations.attack.fadeOut(0.2);

                // Force exit one-shot mode
                p.isPerformingOneShot = false;

                // Layered Blocking Logic (Upper Block + Lower Strafe)
                // console.log(`[ANIM-DEBUG] Blocking check for ${p.username}: BlockUpper=${!!p.knightAnimations.blockUpper}, StrafeLower=${!!p.knightAnimations.strafeLower}, State=${state}`);

                if (p.knightAnimations.blockUpper && p.knightAnimations.strafeLower && (state === 'run' || state === 'walk')) {
                    // console.log(`[ANIM-DEBUG] ${p.username} is blocking and moving. Activating layered animations.`);

                    // Stop conflicting full-body animations
                    if (p.knightAnimations.blockIdle && p.knightAnimations.blockIdle.isRunning()) p.knightAnimations.blockIdle.fadeOut(0.2);
                    if (p.knightAnimations.block && p.knightAnimations.block.isRunning()) p.knightAnimations.block.fadeOut(0.2);
                    if (p.knightAnimations.walk && p.knightAnimations.walk.isRunning()) p.knightAnimations.walk.fadeOut(0.2);
                    if (p.knightAnimations.run && p.knightAnimations.run.isRunning()) p.knightAnimations.run.fadeOut(0.2);
                    if (p.knightAnimations.strafe && p.knightAnimations.strafe.isRunning()) p.knightAnimations.strafe.fadeOut(0.2);

                    // Activate Upper Layer
                    if (!p.knightAnimations.blockUpper.isRunning()) {
                        p.knightAnimations.blockUpper.reset();
                        p.knightAnimations.blockUpper.play();
                    }
                    p.knightAnimations.blockUpper.setEffectiveWeight(2.0);

                    // Activate Lower Layer
                    if (!p.knightAnimations.strafeLower.isRunning()) {
                        p.knightAnimations.strafeLower.reset();
                        p.knightAnimations.strafeLower.play();
                    }
                    p.knightAnimations.strafeLower.setEffectiveTimeScale(1.0); // Ensure it moves
                    p.knightAnimations.strafeLower.setEffectiveWeight(1.5);

                    p.currentKnightAction = p.knightAnimations.blockUpper;
                    return;

                } else {
                    // Not moving or missing layers -> Full Block
                    // Stop layers if running
                    if (p.knightAnimations.blockUpper && p.knightAnimations.blockUpper.isRunning()) p.knightAnimations.blockUpper.fadeOut(0.2);

                    // Freeze and Fade lower body
                    if (p.knightAnimations.strafeLower && p.knightAnimations.strafeLower.isRunning()) {
                        p.knightAnimations.strafeLower.setEffectiveTimeScale(0);
                        p.knightAnimations.strafeLower.fadeOut(0.2);
                    }
                    if (p.knightAnimations.walkLower && p.knightAnimations.walkLower.isRunning()) {
                        p.knightAnimations.walkLower.setEffectiveTimeScale(0);
                        p.knightAnimations.walkLower.fadeOut(0.2);
                    }
                    if (p.knightAnimations.runLower && p.knightAnimations.runLower.isRunning()) {
                        p.knightAnimations.runLower.setEffectiveTimeScale(0);
                        p.knightAnimations.runLower.fadeOut(0.2);
                    }

                    // Prefer blockIdle if available
                    if (p.knightAnimations.blockIdle) {
                        // SYNC: If blockUpper was running, start blockIdle at the same time
                        let startTime = 0;
                        if (p.knightAnimations.blockUpper && p.knightAnimations.blockUpper.isRunning()) {
                            startTime = p.knightAnimations.blockUpper.time;
                        }

                        playEnemyKnightAnimation(p, 'blockIdle');

                        if (startTime > 0 && p.knightAnimations.blockIdle.isRunning()) {
                            p.knightAnimations.blockIdle.time = startTime;
                        }
                    } else {
                        playEnemyKnightAnimation(p, 'block');
                    }
                    return;
                }
            }

            // 3. Locked One-Shot Animations (Attack, Powerup, Jump landing)
            // Checked AFTER blocking, so blocking can interrupt them
            if (p.isPerformingOneShot) {
                return; // Let animation finish
            }

            // 4. Trigger New Actions
            if (isPoweringUp) {
                // Layered Powerup Logic (Upper Powerup + Lower Run/Walk)
                if (p.knightAnimations.powerupUpper && (state === 'run' || state === 'walk')) {
                    console.log(`[ANIM-DEBUG] ${p.username} is powering up and moving (${state}). Activating layered animations.`);

                    // Stop conflicting full-body animations
                    if (p.knightAnimations.powerup && p.knightAnimations.powerup.isRunning()) p.knightAnimations.powerup.stop();
                    if (p.knightAnimations.walk && p.knightAnimations.walk.isRunning()) p.knightAnimations.walk.fadeOut(0.2);
                    if (p.knightAnimations.run && p.knightAnimations.run.isRunning()) p.knightAnimations.run.fadeOut(0.2);

                    // Activate Upper Layer
                    if (!p.knightAnimations.powerupUpper.isRunning()) {
                        p.knightAnimations.powerupUpper.reset();
                        p.knightAnimations.powerupUpper.play();
                    }
                    p.knightAnimations.powerupUpper.setEffectiveWeight(2.0);

                    // Activate Lower Layer
                    let lowerAction = (state === 'run') ? p.knightAnimations.runLower : p.knightAnimations.walkLower;
                    if (lowerAction) {
                        if (!lowerAction.isRunning()) {
                            lowerAction.reset();
                            lowerAction.play();
                        }
                        lowerAction.setEffectiveTimeScale(1.0);
                        lowerAction.setEffectiveWeight(1.5);
                    }
                    p.currentKnightAction = p.knightAnimations.powerupUpper;
                    return;
                } else {
                    // Not moving or missing layers -> Full Powerup
                    if (p.knightAnimations.walkLower && p.knightAnimations.walkLower.isRunning()) {
                        p.knightAnimations.walkLower.setEffectiveTimeScale(0);
                        p.knightAnimations.walkLower.fadeOut(0.2);
                    }
                    if (p.knightAnimations.runLower && p.knightAnimations.runLower.isRunning()) {
                        p.knightAnimations.runLower.setEffectiveTimeScale(0);
                        p.knightAnimations.runLower.fadeOut(0.2);
                    }
                    if (playEnemyKnightAnimation(p, 'powerup', true)) return;
                }
            }

            if (isAttacking) {
                if (playEnemyKnightAnimation(p, 'attack', true)) return;
            }

            // 5. Movement States (if not blocking/attacking/powering up) else {
            // Stop layers if running
            if (p.knightAnimations.blockUpper && p.knightAnimations.blockUpper.isRunning()) p.knightAnimations.blockUpper.fadeOut(0.2);
            // Freeze and Fade lower body
            if (p.knightAnimations.strafeLower && p.knightAnimations.strafeLower.isRunning()) {
                p.knightAnimations.strafeLower.setEffectiveTimeScale(0);
                p.knightAnimations.strafeLower.fadeOut(0.2);
            }
            if (p.knightAnimations.walkLower && p.knightAnimations.walkLower.isRunning()) {
                p.knightAnimations.walkLower.setEffectiveTimeScale(0);
                p.knightAnimations.walkLower.fadeOut(0.2);
            }
            if (p.knightAnimations.runLower && p.knightAnimations.runLower.isRunning()) {
                p.knightAnimations.runLower.setEffectiveTimeScale(0);
                p.knightAnimations.runLower.fadeOut(0.2);
            }

            // 4. Movement States
            if (state === 'jump') {
                playEnemyKnightAnimation(p, 'jump', true);
            }
            else if (state === 'run') playEnemyKnightAnimation(p, 'run');
            else if (state === 'walk') playEnemyKnightAnimation(p, 'walk');
            else playEnemyKnightAnimation(p, 'idle');
        }

        // SAFETY CHECK: If no action is running, force IDLE
        if (!p.currentKnightAction || !p.currentKnightAction.isRunning()) {
            playEnemyKnightAnimation(p, 'idle');
        }
    });
}

// Expose to window
window.loadEnemyKnightModel = loadEnemyKnightModel;
window.playEnemyKnightAnimation = playEnemyKnightAnimation;
window.updateOtherPlayersAnimations = updateOtherPlayersAnimations;
window.switchArcherAnimation = switchArcherAnimation;

// Helper to switch Archer FPS animations
function switchArcherAnimation(name) {
    if (!fpsArcherAnimations || !fpsArcherAnimations[name]) return;

    // --- HARD RESET FUNCTION FOR RESPAWN ---
    const newAction = fpsArcherAnimations[name];
    if (fpsArcherCurrentAction === newAction) return; // Already playing

    // Crossfade
    newAction.reset();
    newAction.play();
    // Determine transition duration
    // If aiming, sync with Bow Cast Time (drawing the bow)
    // If releasing, fast return to idle
    let transitionDuration = 0.2;
    if (name === 'Bow_AIM_IDLE' && typeof SETTINGS !== 'undefined') {
        // FIX: If we are already holding the bow drawn (isBowAiming is true) and we just landed/jumped,
        // we want to SNAP to the end of the animation, not replay the draw.
        // But 'newAction' is reset() above.

        // If we are switching TO Aim Idle, and we were ALREADY aiming (e.g. coming from Jump),
        // we should skip the transition or make it instant.
        if (window.isBowAiming) {
            // Check if we were playing Jump or something else that interrupted Aim
            // If so, we might want to snap back to full draw.
            transitionDuration = 0.1; // Fast snap back to aim
            // Optionally, we could seek to end of animation?
            // newAction.time = newAction.getClip().duration;
        } else {
            transitionDuration = SETTINGS.bowCastTime;
        }
    }

    if (fpsArcherCurrentAction) {
        fpsArcherCurrentAction.crossFadeTo(newAction, transitionDuration);
    }
    fpsArcherCurrentAction = newAction;

    // Set Target Position for ADS
    if (fpsBowContainer && fpsBowContainer.children[0]) {
        const model = fpsBowContainer.children[0];
        // FIX: Reverted Bow_FIRE to use Idle Position as requested
        const targetPos = (name === 'Bow_AIM_IDLE') ? model.userData.aimPos : model.userData.idlePos;
        if (targetPos) {
            model.userData.targetPosition = targetPos;
        }
    }
}

// --- HARD RESET FUNCTION FOR RESPAWN ---
function resetKnightAnimations() {
    try {
        console.log('[KNIGHT] Executing Hard Animation Reset...');
        if (knightMixer) {
            knightMixer.stopAllAction();
            // Uncache root to be safe
            const root = knightMixer.getRoot();
            knightMixer.uncacheRoot(root);
        }

        currentKnightAnimName = '';
        currentKnightAction = null;
        isAttacking = false;
        isWhirlwinding = false;
        attackTimer = 0;

        // Restart Idle immediately
        if (knightAnimations.idle) {
            knightAnimations.idle.reset();
            knightAnimations.idle.play();
            knightAnimations.idle.setEffectiveWeight(1.0);
            currentKnightAnimName = 'idle';
            currentKnightAction = knightAnimations.idle;
        }

        // FIX: Ensure Casting Bar is gone
        if (typeof window.resetCastingState === 'function') {
            window.resetCastingState();
        }
    } catch (e) {
        console.error('[KNIGHT] Error in resetKnightAnimations:', e);
    }
}
window.resetKnightAnimations = resetKnightAnimations;

// Global input listeners for Bow Aiming
document.addEventListener('mousedown', (e) => {
    if (typeof weaponMode !== 'undefined' && weaponMode === 'bow' && e.button === 0) { // Left Click
        window.isBowAiming = true;
        // switchArcherAnimation('Bow_AIM_IDLE'); // Handled in update loop now
    }
});

document.addEventListener('mouseup', (e) => {
    if (typeof weaponMode !== 'undefined' && weaponMode === 'bow' && e.button === 0) {
        window.isBowAiming = false;
        // switchArcherAnimation('Bow_IDLE'); // Handled in update loop now
    }
});
