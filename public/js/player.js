// player.js - autogenerated module from original game.js

// GLB Knight Model - Sistema Completo
let knightModel = null;
let knightMixer = null;
let knightAnimations = {
    idle: null,
    walk: null,
    run: null,
    strafe: null,
    jump: null,
    attack: null,
    whirlwind: null,
    block: null,
    blockIdle: null,
    powerup: null,
    death: null
};
let currentKnightAction = null;
let currentKnightAnimName = '';
// Stato precedente di blocco per evitare ri-trigger del reverse su cambi rapidi di movimento
let wasBlocking = false;
let isKnightLoaded = false;
let animationStartTime = 0;
let minAnimDuration = 0; // Durata minima per animazioni speciali
let upperBodyBones = []; // Bone della parte superiore (spine/chest in su)
let lowerBodyBones = []; // Bone della parte inferiore (hips/gambe)
// Flag dedicato per salto (mantiene animazione jump anche se canJump torna true anticipatamente)
// Jump semplificato: nessun flag, si usa solo canJump per mostrare animazione in aria

function loadKnightModel(callback) {
    if (isKnightLoaded) {
        if (callback) callback();
        return;
    }

    console.log('=== LOADING KNIGHT MET.GLB ===');
    const loader = new THREE.GLTFLoader();

    loader.load('./models/Knight Met.glb', (gltf) => {
        knightModel = gltf.scene;
        knightModel.scale.set(10, 10, 10);
        knightModel.position.set(0, -6.0, 0); // Lowered to touch ground (Player pivot is at y=6)
        knightModel.rotation.y = Math.PI; // Gira verso il mirino
        knightModel.visible = false;

        console.log('[KNIGHT] ✓ Model loaded');
        console.log('[KNIGHT] Animations found:', gltf.animations.length);

        // Applica colore team
        const teamColor = typeof myTeamColor !== 'undefined' ? myTeamColor : 0x2c3e50;
        knightModel.traverse((child) => {
            if (child.isMesh) {
                if (child.material) {
                    child.material = child.material.clone();
                    child.material.color.setHex(teamColor);
                    // Apply 30% tint of team color to preserve texture
                    child.material.color.setHex(0xffffff).lerp(new THREE.Color(teamColor), 0.3);

                    // Remove emissive to avoid washing out texture
                    child.material.emissive = new THREE.Color(0x000000);
                    child.material.emissiveIntensity = 0.0;

                    child.material.metalness = 0.5; // Standard metalness
                    child.material.roughness = 0.5; // Standard roughness
                }
                child.castShadow = true;
                child.receiveShadow = true;
                
                // FIX: Disabilita frustum culling per evitare scomparsa quando vicino alla camera
                child.frustumCulled = false;
            }
        });

        if (playerMesh) {
            playerMesh.add(knightModel);
            console.log('[KNIGHT] ✓ Added to player');
        }

        // Crea mixer per le animazioni
        knightMixer = new THREE.AnimationMixer(knightModel);
        console.log('[KNIGHT] ✓ Mixer created');

        // MAPPA TUTTE LE ANIMAZIONI DAL GLB
        console.log('[KNIGHT] === MAPPING ANIMATIONS ===');

        if (gltf.animations && gltf.animations.length > 0) {
            console.log('[KNIGHT] Total animations:', gltf.animations.length);

            gltf.animations.forEach((clip, index) => {
                const name = clip.name.toLowerCase();
                console.log(`  [${index}] "${clip.name}" (${clip.duration.toFixed(2)}s)`);

                // Mappa in base al nome e configura loop appropriati
                if (name.includes('walk') && !name.includes('block') || name.includes('wal')) {
                    // WALK: animazione per tasto W, rimuove root motion
                    const originalClip = clip;
                    const tracks = [];

                    for (let i = 0; i < originalClip.tracks.length; i++) {
                        const track = originalClip.tracks[i];
                        const trackName = track.name;
                        const boneName = trackName.split('.')[0];
                        const propertyName = trackName.split('.')[1];

                        // Filtra tracce di posizione da hips/mixamorig per evitare movimento in avanti
                        if (propertyName === 'position' &&
                            (boneName.toLowerCase().includes('hips') || boneName.toLowerCase().includes('mixamorig'))) {
                            console.log(`      [Walk] Filtrata traccia root motion: ${trackName}`);
                            continue;
                        }

                        tracks.push(track);
                    }

                    const walkClip = new THREE.AnimationClip(originalClip.name, originalClip.duration, tracks);
                    knightAnimations.walk = knightMixer.clipAction(walkClip);
                    knightAnimations.walk.setLoop(THREE.LoopRepeat);
                    knightAnimations.walk.clampWhenFinished = false;
                    console.log('    → WALK (loop, root motion removed - tasto W)');
                }
                else if (name.includes('strafe')) {
                    // Crea una copia del clip senza root motion
                    const originalClip = clip;
                    const tracks = [];

                    for (let i = 0; i < originalClip.tracks.length; i++) {
                        const track = originalClip.tracks[i];
                        const trackName = track.name;

                        if (trackName.includes('.position') &&
                            (trackName.toLowerCase().includes('hips') ||
                                trackName.toLowerCase().includes('mixamorig') ||
                                trackName === 'position')) {
                            console.log('    [STRAFE] Skipping root motion track:', trackName);
                            continue;
                        }

                        tracks.push(track);
                    }

                    const noRootMotionClip = new THREE.AnimationClip(originalClip.name + '_NoRootMotion', originalClip.duration, tracks);

                    knightAnimations.strafe = knightMixer.clipAction(noRootMotionClip);
                    knightAnimations.strafe.setLoop(THREE.LoopRepeat);
                    knightAnimations.strafe.clampWhenFinished = false;
                    console.log('    → STRAFE (loop, no root motion)');
                }
                else if (name.includes('idle') && !name.includes('block')) {
                    knightAnimations.idle = knightMixer.clipAction(clip);
                    knightAnimations.idle.setLoop(THREE.LoopRepeat);
                    knightAnimations.idle.clampWhenFinished = false;
                    console.log('    → IDLE (loop)');
                }
                else if (name.includes('run')) {
                    // Crea una copia del clip senza root motion (traslazione)
                    const originalClip = clip;
                    const tracks = [];

                    for (let i = 0; i < originalClip.tracks.length; i++) {
                        const track = originalClip.tracks[i];
                        const trackName = track.name;

                        // Escludi i track di posizione del root/hips che causano il movimento in avanti
                        if (trackName.includes('.position') &&
                            (trackName.toLowerCase().includes('hips') ||
                                trackName.toLowerCase().includes('mixamorig') ||
                                trackName === 'position')) {
                            console.log('    [RUN] Skipping root motion track:', trackName);
                            continue; // Skip questo track
                        }

                        tracks.push(track);
                    }

                    // Crea nuovo clip senza root motion
                    const noRootMotionClip = new THREE.AnimationClip(originalClip.name + '_NoRootMotion', originalClip.duration, tracks);

                    knightAnimations.run = knightMixer.clipAction(noRootMotionClip);
                    knightAnimations.run.setLoop(THREE.LoopRepeat);
                    knightAnimations.run.clampWhenFinished = false;
                    console.log('    → RUN (loop, no root motion)');
                }
                else if (name.includes('jump') || name.includes('leap')) {
                    // Jump originale + variante sul posto (senza root motion) per uso durante powerup
                    knightAnimations.jumpOriginal = knightMixer.clipAction(clip);
                    knightAnimations.jumpOriginal.setLoop(THREE.LoopOnce);
                    knightAnimations.jumpOriginal.clampWhenFinished = false;
                    knightAnimations.jumpOriginal.repetitions = 1;
                    // Crea versione spot filtrando position dei bone root/hips/mixamorig
                    const originalClip = clip;
                    const spotTracks = [];
                    for (let t = 0; t < originalClip.tracks.length; t++) {
                        const track = originalClip.tracks[t];
                        const tl = track.name.toLowerCase();
                        if (tl.includes('.position') && (tl.includes('hips') || tl.includes('mixamorig') || tl === 'position')) {
                            continue;
                        }
                        spotTracks.push(track);
                    }
                    const spotClip = new THREE.AnimationClip(originalClip.name + '_Spot', originalClip.duration, spotTracks);
                    knightAnimations.jumpSpot = knightMixer.clipAction(spotClip);
                    knightAnimations.jumpSpot.setLoop(THREE.LoopOnce);
                    knightAnimations.jumpSpot.clampWhenFinished = false;
                    knightAnimations.jumpSpot.repetitions = 1;
                    // Imposta di default jump = variante sul posto (sempre sul posto)
                    knightAnimations.jump = knightAnimations.jumpSpot;
                    console.log('    → JUMP (once, SPOT variant always used)');
                }
                else if ((name.includes('attack') && name.includes('1')) || name === 'attack 1' || name === 'attack1') {
                    knightAnimations.attack = knightMixer.clipAction(clip);
                    knightAnimations.attack.setLoop(THREE.LoopOnce);
                    knightAnimations.attack.clampWhenFinished = true;
                    knightAnimations.attack.repetitions = 1;
                    console.log('    → ATTACK 1 (once, clamp finish - no T-pose)');
                }
                else if (name.includes('whirlwind') || name.includes('180') || name.includes('spin')) {
                    // Whirlwind sul posto: rimuovi root motion (tracce position di hips/root)
                    const originalClip = clip;
                    const tracks = [];
                    for (let i = 0; i < originalClip.tracks.length; i++) {
                        const track = originalClip.tracks[i];
                        const trackName = track.name.toLowerCase();
                        // Filtra qualsiasi position su root/hips/mixamorig
                        if (trackName.includes('.position') && (trackName.includes('hips') || trackName.includes('mixamorig') || trackName === 'position')) {
                            console.log('    [WHIRLWIND] Removed root motion track:', track.name);
                            continue;
                        }
                        tracks.push(track);
                    }
                    const spotClip = new THREE.AnimationClip(originalClip.name + '_Spot', originalClip.duration, tracks);
                    knightAnimations.whirlwind = knightMixer.clipAction(spotClip);
                    knightAnimations.whirlwind.setLoop(THREE.LoopOnce);
                    knightAnimations.whirlwind.clampWhenFinished = false;
                    knightAnimations.whirlwind.repetitions = 1;
                    console.log('    → WHIRLWIND (once, SPOT spin, no root motion)');
                }
                else if (name.includes('block') && name.includes('idle')) {
                    knightAnimations.blockIdle = knightMixer.clipAction(clip);
                    knightAnimations.blockIdle.setLoop(THREE.LoopRepeat);
                    knightAnimations.blockIdle.clampWhenFinished = false;
                    console.log('    → BLOCK IDLE (loop)');
                }
                else if (name.includes('block') || name.includes('parry')) {
                    knightAnimations.block = knightMixer.clipAction(clip);
                    knightAnimations.block.setLoop(THREE.LoopRepeat);
                    knightAnimations.block.clampWhenFinished = false;
                    console.log('    → BLOCK (loop)');
                }
                else if (name.includes('powerup') || name.includes('power up')) {
                    knightAnimations.powerup = knightMixer.clipAction(clip);
                    knightAnimations.powerup.setLoop(THREE.LoopOnce);
                    knightAnimations.powerup.clampWhenFinished = true; // Mantiene la posa finale
                    knightAnimations.powerup.repetitions = 1;
                    console.log('    → POWERUP (once, clamp finish)');
                }
                else if (name.includes('death') || name.includes('die')) {
                    knightAnimations.death = knightMixer.clipAction(clip);
                    knightAnimations.death.setLoop(THREE.LoopOnce);
                    knightAnimations.death.clampWhenFinished = true;
                    console.log('    → DEATH (once+hold)');
                }
                else {
                    console.log('    → (unmapped)');
                }
            });

            // Evento quando finisce un'animazione one-shot
            knightMixer.addEventListener('finished', (e) => {
                if (e.action === knightAnimations.attack) {
                    console.log('[KNIGHT] ✓ Attack complete');
                    isAttacking = false;
                    minAnimDuration = 0;
                    // Non resettare subito currentKnightAnimName per evitare scatti
                    setTimeout(() => {
                        if (currentKnightAnimName === 'attack') {
                            currentKnightAnimName = '';
                        }
                    }, 50);
                } else if (e.action === knightAnimations.attackUpper) {
                    console.log('[KNIGHT] ✓ Layered attack upper complete');
                    isAttacking = false;
                    minAnimDuration = 0;
                    setTimeout(() => {
                        if (currentKnightAnimName === 'attack_layered') {
                            currentKnightAnimName = '';
                        }
                    }, 50);
                } else if (e.action === knightAnimations.whirlwind) {
                    console.log('[KNIGHT] ✓ Whirlwind complete');
                    minAnimDuration = 0;
                    // Delay per transizione fluida
                    setTimeout(() => {
                        if (currentKnightAnimName === 'whirlwind') {
                            currentKnightAnimName = '';
                        }
                    }, 50);
                } else if (e.action === knightAnimations.powerup) {
                    console.log('[KNIGHT] ✓ Powerup complete');
                    minAnimDuration = 0;
                    setTimeout(() => {
                        if (currentKnightAnimName === 'powerup') {
                            currentKnightAnimName = '';
                        }
                    }, 50);
                } else if (e.action === knightAnimations.powerupUpper) {
                    console.log('[KNIGHT] ✓ Layered powerup complete');
                    minAnimDuration = 0;
                    setTimeout(() => {
                        if (currentKnightAnimName === 'powerup_layered') {
                            currentKnightAnimName = '';
                        }
                    }, 50);
                }
            });

            // Identifica bone per layering upper/lower body
            knightModel.traverse((node) => {
                if (node.isBone) {
                    const boneName = node.name.toLowerCase();
                    // Upper body: spine, chest, neck, head, shoulders, arms
                    if (boneName.includes('spine') || boneName.includes('chest') ||
                        boneName.includes('neck') || boneName.includes('head') ||
                        boneName.includes('shoulder') || boneName.includes('arm') ||
                        boneName.includes('hand') || boneName.includes('finger') ||
                        boneName.includes('clavicle')) {
                        upperBodyBones.push(node);
                    }
                    // Lower body: hips, legs, feet
                    else if (boneName.includes('hips') || boneName.includes('leg') ||
                        boneName.includes('thigh') || boneName.includes('calf') ||
                        boneName.includes('foot') || boneName.includes('toe')) {
                        lowerBodyBones.push(node);
                    }
                }
            });
            console.log(`[KNIGHT] Bone layering: ${upperBodyBones.length} upper, ${lowerBodyBones.length} lower`);

            // Crea clip layered per blockIdle (upper body only) e strafe (lower body only)
            if (knightAnimations.blockIdle && upperBodyBones.length > 0) {
                const originalClip = knightAnimations.blockIdle.getClip();
                const upperClip = createLayeredClip(originalClip, upperBodyBones, 'blockIdle_upperBody');
                knightAnimations.blockIdleUpper = knightMixer.clipAction(upperClip);
                knightAnimations.blockIdleUpper.setLoop(THREE.LoopRepeat);
                console.log('[KNIGHT] ✓ Created blockIdle upper body layer');
            }
            if (knightAnimations.strafe && lowerBodyBones.length > 0) {
                const originalClip = knightAnimations.strafe.getClip();
                const lowerClip = createLayeredClip(originalClip, lowerBodyBones, 'strafe_lowerBody');
                knightAnimations.strafeLower = knightMixer.clipAction(lowerClip);
                knightAnimations.strafeLower.setLoop(THREE.LoopRepeat);
                console.log('[KNIGHT] ✓ Created strafe lower body layer');
            }
            // Layer per ATTACK (upper body) e WALK/RUN (lower body)
            if (knightAnimations.attack && upperBodyBones.length > 0) {
                const attackClip = knightAnimations.attack.getClip();
                const attackUpperClip = createLayeredClip(attackClip, upperBodyBones, 'attack_upperBody');
                knightAnimations.attackUpper = knightMixer.clipAction(attackUpperClip);
                knightAnimations.attackUpper.setLoop(THREE.LoopOnce);
                knightAnimations.attackUpper.clampWhenFinished = true;
                knightAnimations.attackUpper.repetitions = 1;
                console.log('[KNIGHT] ✓ Created attack upper body layer');
            }
            if (knightAnimations.walk && lowerBodyBones.length > 0) {
                const walkClip = knightAnimations.walk.getClip();
                const walkLowerClip = createLayeredClip(walkClip, lowerBodyBones, 'walk_lowerBody');
                knightAnimations.walkLower = knightMixer.clipAction(walkLowerClip);
                knightAnimations.walkLower.setLoop(THREE.LoopRepeat);
                console.log('[KNIGHT] ✓ Created walk lower body layer');
            }
            if (knightAnimations.run && lowerBodyBones.length > 0) {
                const runClip = knightAnimations.run.getClip();
                const runLowerClip = createLayeredClip(runClip, lowerBodyBones, 'run_lowerBody');
                knightAnimations.runLower = knightMixer.clipAction(runLowerClip);
                knightAnimations.runLower.setLoop(THREE.LoopRepeat);
                console.log('[KNIGHT] ✓ Created run lower body layer');
            }
            // Layer per POWERUP (upper body)
            if (knightAnimations.powerup && upperBodyBones.length > 0) {
                const puClip = knightAnimations.powerup.getClip();
                const puUpperClip = createLayeredClip(puClip, upperBodyBones, 'powerup_upperBody');
                knightAnimations.powerupUpper = knightMixer.clipAction(puUpperClip);
                knightAnimations.powerupUpper.setLoop(THREE.LoopOnce);
                knightAnimations.powerupUpper.clampWhenFinished = true;
                knightAnimations.powerupUpper.repetitions = 1;
                console.log('[KNIGHT] ✓ Created powerup upper body layer');
            }

            // Avvia idle se disponibile - SEMPRE RUNNING per evitare T-pose
            if (knightAnimations.idle) {
                knightAnimations.idle.reset();
                knightAnimations.idle.setEffectiveWeight(1.0); // Peso completo
                knightAnimations.idle.play();
                currentKnightAction = knightAnimations.idle;
                currentKnightAnimName = 'idle';
                console.log('[KNIGHT] ▶ Started IDLE (always active)');
            } else if (knightAnimations.walk) {
                knightAnimations.walk.play();
                currentKnightAction = knightAnimations.walk;
                currentKnightAnimName = 'walk';
                console.log('[KNIGHT] ▶ Started WALK (no idle)');
            }

            console.log('[KNIGHT] ✓ Animations ready:', {
                idle: !!knightAnimations.idle,
                walk: !!knightAnimations.walk,
                run: !!knightAnimations.run,
                strafe: !!knightAnimations.strafe,
                jump: !!knightAnimations.jump,
                attack: !!knightAnimations.attack,
                whirlwind: !!knightAnimations.whirlwind,
                block: !!knightAnimations.block,
                blockIdle: !!knightAnimations.blockIdle,
                death: !!knightAnimations.death
            });
        } else {
            console.error('[KNIGHT] ✗ No animations in GLB!');
        }

        isKnightLoaded = true;
        if (callback) callback();

    }, undefined, (error) => {
        console.error('[KNIGHT] ✗ Load error:', error);
    });
}

function createLayeredClip(originalClip, includeBones, clipName) {
    // Crea un nuovo clip che include SOLO i track dei bone specificati
    if (!originalClip || !includeBones || includeBones.length === 0) return originalClip;

    const filteredTracks = [];
    originalClip.tracks.forEach((track) => {
        const boneName = track.name.split('.')[0];
        // Includi solo track dei bone nella lista
        const shouldInclude = includeBones.some(bone => bone.name === boneName);
        if (shouldInclude) {
            filteredTracks.push(track);
        }
    });

    if (filteredTracks.length === 0) return originalClip;
    return new THREE.AnimationClip(clipName, originalClip.duration, filteredTracks);
}

function playKnightAnimation(animName, forceRestart = false) {
    if (!knightMixer || !knightAnimations[animName]) return;

    if (currentKnightAnimName === animName && !forceRestart) return;

    console.log(`[KNIGHT] ▶ ${animName}`);

    // SPECIAL CASE: layered attack while moving
    if (animName === 'attack' && (moveForward || moveBackward || moveLeft || moveRight) && knightAnimations.attackUpper && (knightAnimations.walkLower || knightAnimations.runLower)) {
        const fadeTime = 0.15;
        // Determina clip gambe (run se sprint, altrimenti walk)
        const isSprintingActive = isSprinting && playerStats.stamina > 0 && moveForward;
        const legsAction = isSprintingActive && knightAnimations.runLower ? knightAnimations.runLower : knightAnimations.walkLower;
        // Fade out altri layer (eccetto idle)
        Object.entries(knightAnimations).forEach(([k, action]) => {
            if (action && action.isRunning() && action !== legsAction && action !== knightAnimations.idle && action !== knightAnimations.attackUpper) {
                action.fadeOut(fadeTime);
            }
        });
        // Avvia gambe
        if (legsAction) {
            if (!legsAction.isRunning()) legsAction.reset();
            legsAction.setEffectiveWeight(1.3);
            legsAction.fadeIn(fadeTime).play();
        }
        // Avvia upper attack
        const upper = knightAnimations.attackUpper;
        upper.reset();
        upper.setEffectiveTimeScale(2.0); // stesso speed boost
        upper.setEffectiveWeight(2.2);
        upper.fadeIn(fadeTime).play();
        const naturalDuration = upper.getClip().duration;
        const actualDuration = naturalDuration / 2.0;
        minAnimDuration = actualDuration;
        animationStartTime = performance.now();
        currentKnightAnimName = 'attack_layered';
        console.log(`  [Attack Layered] Upper+Legs (${legsAction === knightAnimations.runLower ? 'RUN' : 'WALK'}) Duration: ${actualDuration.toFixed(2)}s`);
        isAttacking = true;
        return;
    }
    // SPECIAL CASE: layered powerup while moving
    if (animName === 'powerup' && (moveForward || moveBackward || moveLeft || moveRight) && knightAnimations.powerupUpper && (knightAnimations.walkLower || knightAnimations.runLower)) {
        const fadeTime = 0.2;
        const isSprintingActive = isSprinting && playerStats.stamina > 0 && moveForward;
        const legsAction = isSprintingActive && knightAnimations.runLower ? knightAnimations.runLower : knightAnimations.walkLower;
        Object.entries(knightAnimations).forEach(([k, action]) => {
            if (action && action.isRunning() && action !== legsAction && action !== knightAnimations.idle && action !== knightAnimations.powerupUpper) {
                action.fadeOut(fadeTime);
            }
        });
        if (legsAction) {
            if (!legsAction.isRunning()) legsAction.reset();
            legsAction.setEffectiveWeight(1.2);
            legsAction.fadeIn(fadeTime).play();
        }
        const upper = knightAnimations.powerupUpper;
        upper.reset();
        upper.setEffectiveTimeScale(1.0);
        upper.setEffectiveWeight(2.0);
        upper.fadeIn(fadeTime).play();
        const naturalDuration = upper.getClip().duration;
        minAnimDuration = naturalDuration;
        animationStartTime = performance.now();
        currentKnightAnimName = 'powerup_layered';
        console.log(`  [Powerup Layered] Upper+Legs (${legsAction === knightAnimations.runLower ? 'RUN' : 'WALK'}) Duration: ${naturalDuration.toFixed(2)}s`);
        return;
    }

    let targetAction = knightAnimations[animName];
    // Jump sempre sul posto: nessuna sostituzione condizionale necessaria
    const fadeTime = 0.2; // 200ms di crossfade

    // SISTEMA ANTI T-POSE: Mantieni idle sempre attiva
    if (knightAnimations.idle) {
        if (!knightAnimations.idle.isRunning()) {
            knightAnimations.idle.reset();
            knightAnimations.idle.play();
        }
        // Idle sempre a weight 1.0, le altre animazioni la sovrascriveranno
        knightAnimations.idle.setEffectiveWeight(1.0);
    }

    // Fade out delle altre animazioni (eccetto idle) e fade in della nuova
    Object.values(knightAnimations).forEach(action => {
        if (action && action !== targetAction && action !== knightAnimations.idle && action.isRunning()) {
            action.fadeOut(fadeTime);
        }
    });

    targetAction.reset();
    targetAction.fadeIn(fadeTime);

    // Se non è idle, imposta weight maggiore dell'animazione target per sovrascrivere idle
    if (animName !== 'idle') {
        targetAction.setEffectiveWeight(2.0); // Peso doppio per sovrascrivere idle
    }

    // Imposta timeScale appropriato
    if (animName === 'attack') {
        // Velocizza del doppio (2x speed)
        targetAction.setEffectiveTimeScale(2.0);
        const naturalDuration = targetAction.getClip().duration;
        const actualDuration = naturalDuration / 2.0;
        minAnimDuration = actualDuration;
        console.log(`  [Attack] Speed: 2x, Duration: ${actualDuration.toFixed(2)}s`);
    } else if (animName === 'whirlwind') {
        // Whirlwind a velocità naturale per massima fluidità
        targetAction.setEffectiveTimeScale(1.0);
        const naturalDuration = targetAction.getClip().duration;
        minAnimDuration = naturalDuration;
        console.log(`  [Whirlwind] Natural speed, Duration: ${naturalDuration.toFixed(2)}s`);
    } else if (animName === 'jump') {
        // Rallenta il salto per renderlo più leggibile
        targetAction.setEffectiveTimeScale(0.6);
        console.log('  [Jump] Slowed: timeScale 0.6');
    } else if (animName === 'powerup') {
        // Powerup: imposta durata completa ma sarà bypassabile dalla parata
        targetAction.setEffectiveTimeScale(1.0);
        const naturalDuration = targetAction.getClip().duration;
        minAnimDuration = naturalDuration;
        console.log(`  [Powerup] Duration: ${naturalDuration.toFixed(2)}s (interruptible by block)`);
    } else {
        targetAction.setEffectiveTimeScale(1.0);
        minAnimDuration = 0;
    }

    animationStartTime = performance.now();
    targetAction.play();
    currentKnightAction = targetAction;
    currentKnightAnimName = animName;
}

function updateKnightAnimation() {
    if (!knightModel || !knightModel.visible || !knightMixer) return;

    const isMoving = moveForward || moveBackward || moveLeft || moveRight;
    const isStrafing = (moveLeft || moveRight) && !moveForward && !moveBackward;
    const prevWasBlocking = wasBlocking;

    // Rispetta la durata minima per animazioni speciali (attack, whirlwind)
    // MA parata ha priorità assoluta
    if (minAnimDuration > 0 && !isBlocking) {
        const elapsed = (performance.now() - animationStartTime) / 1000;
        if (elapsed < minAnimDuration) {
            // Non cambiare animazione finché non è passato il tempo minimo
            return;
        }
    }

    // Determina quale animazione dovrebbe essere attiva
    let targetAnim = null;

    if (playerStats.isDead && knightAnimations.death) {
        targetAnim = 'death';
    }
    else if (isWhirlwinding && knightAnimations.whirlwind) {
        // Durante whirlwind lascia finire
        if (currentKnightAnimName === 'whirlwind') {
            return;
        }
        targetAnim = 'whirlwind';
    }
    else if (isAttacking) {
        // Durante l'attacco (full body o layered) lascia finire
        if (currentKnightAnimName === 'attack' || currentKnightAnimName === 'attack_layered') {
            return;
        }
        targetAnim = 'attack';
    }
    else if (isBlocking) {
        // Block ha priorità su jump - gestito sotto
    }
    else if (!canJump && knightAnimations.jump) {
        // In aria: mostra jump
        targetAnim = 'jump';
    }

    if (isBlocking) {
        // PRIORITY: Stop Powerup if blocking starts
        if (knightAnimations.powerup && knightAnimations.powerup.isRunning()) {
            knightAnimations.powerup.stop();
            console.log('[KNIGHT] Blocking interrupted Powerup');
        }
        if (knightAnimations.powerupUpper && knightAnimations.powerupUpper.isRunning()) {
            knightAnimations.powerupUpper.stop();
            console.log('[KNIGHT] Blocking interrupted Powerup Upper');
        }

        // LAYERING: se blocchi E ti muovi, upper body = blockIdle, lower body = strafe
        if (isMoving && knightAnimations.blockIdleUpper && knightAnimations.strafeLower) {
            // Stoppa altre animazioni che potrebbero causare conflitti
            if (knightAnimations.blockIdle && knightAnimations.blockIdle.isRunning()) {
                knightAnimations.blockIdle.stop();
            }
            if (knightAnimations.strafe && knightAnimations.strafe.isRunning()) {
                knightAnimations.strafe.stop();
            }
            if (knightAnimations.walk && knightAnimations.walk.isRunning()) {
                knightAnimations.walk.stop();
            }

            // Attiva i layer separati
            if (!knightAnimations.blockIdleUpper.isRunning()) {
                knightAnimations.blockIdleUpper.reset();
                knightAnimations.blockIdleUpper.play();
            }
            knightAnimations.blockIdleUpper.setEffectiveWeight(2.0); // Peso alto per upper body

            if (!knightAnimations.strafeLower.isRunning()) {
                knightAnimations.strafeLower.reset();
                knightAnimations.strafeLower.play();
            }
            knightAnimations.strafeLower.setEffectiveWeight(1.5); // Peso moderato per lower body

            currentKnightAnimName = 'blockIdle+strafe_layered';
            return;
        }
        // Click parata: block REVERSE -> poi blockIdle se tenuto premuto
        else if (currentKnightAnimName === 'block_reversing' && knightAnimations.block) {
            // Block reverse in esecuzione, controlla se è finito per passare a blockIdle
            const blockAction = knightAnimations.block;
            if (blockAction.time <= 0.05) {
                // Block reverse finito, passa a blockIdle
                if (knightAnimations.blockIdle) {
                    blockAction.stop();
                    blockAction.setEffectiveTimeScale(1.0);
                    targetAnim = 'blockIdle';
                }
            } else {
                return; // Block reverse ancora in corso
            }
        } else if (currentKnightAnimName === 'blockIdle') {
            return; // Mantieni blockIdle mentre è premuto
        } else if (currentKnightAnimName === 'block') {
            // Se stai rilasciando e ripremi, interrompi il forward e riavvia reverse
            const blockAction = knightAnimations.block;
            if (blockAction) {
                blockAction.stop();
            }
            // Avvia block reverse veloce
            if (knightAnimations.block) {
                const action = knightAnimations.block;
                action.reset();
                action.paused = false;
                action.setEffectiveTimeScale(-3.0); // 3x speed
                action.time = action.getClip().duration;
                action.play();
                currentKnightAnimName = 'block_reversing';
            }
            return;
        } else if (knightAnimations.block && !prevWasBlocking && !['block_reversing', 'blockIdle', 'block', 'blockIdle+strafe_layered'].includes(currentKnightAnimName) && currentKnightAnimName !== 'whirlwind') {
            // Inizio parata: avvia block REVERSE veloce
            // Interrompi jump immediatamente (parata ha priorità) ma non whirlwind
            if (currentKnightAnimName === 'jump' && knightAnimations.jump && knightAnimations.jump.isRunning()) {
                knightAnimations.jump.stop();
                console.log('[KNIGHT] Block pressed mid-jump: jump stopped for immediate parry');
            }
            const action = knightAnimations.block;
            action.reset();
            action.paused = false;
            action.setEffectiveTimeScale(-3.0); // 3x speed per reverse molto veloce
            action.time = action.getClip().duration;
            action.play();
            currentKnightAnimName = 'block_reversing';
            console.log('[KNIGHT] Starting block reverse (first frame of block)');
            return;
        }
    }
    // FORWARD block quando rilasci la parata
    else if (!isBlocking && (currentKnightAnimName === 'blockIdle' || currentKnightAnimName === 'block_reversing' || currentKnightAnimName === 'blockIdle+strafe_layered')) {
        const action = knightAnimations.block;
        if (action && currentKnightAnimName !== 'block') {
            console.log('[KNIGHT] Starting block forward animation on release');

            // Stoppa blockIdle e i layer se erano attivi
            if (knightAnimations.blockIdle && knightAnimations.blockIdle.isRunning()) {
                knightAnimations.blockIdle.stop();
            }
            if (knightAnimations.blockIdleUpper && knightAnimations.blockIdleUpper.isRunning()) {
                knightAnimations.blockIdleUpper.stop();
            }
            if (knightAnimations.strafeLower && knightAnimations.strafeLower.isRunning()) {
                knightAnimations.strafeLower.stop();
            }

            // Stoppa block reverse se stava andando
            if (action.isRunning()) {
                action.stop();
            }

            // Avvia forward dalla posizione corrente o dall'inizio
            const currentTime = action.time;

            action.reset();
            action.paused = false;
            action.setEffectiveTimeScale(1.0);
            action.time = currentTime > 0 ? currentTime : 0;
            action.play();

            currentKnightAnimName = 'block';
        }
        // Se è in forward e ha raggiunto la fine, fermalo
        else if (currentKnightAnimName === 'block' && action) {
            const duration = action.getClip().duration;
            if (action.time >= duration - 0.05) {
                console.log('[KNIGHT] Block forward completed');
                action.stop();
                action.setEffectiveTimeScale(1.0);
                action.setEffectiveWeight(1.0);

                // Resetta weights altre animazioni
                if (knightAnimations.walk) {
                    knightAnimations.walk.setEffectiveWeight(1.0);
                }
                if (knightAnimations.strafe) {
                    knightAnimations.strafe.setEffectiveWeight(1.0);
                }

                currentKnightAnimName = '';
                minAnimDuration = 0;
            } else {
                return; // Block forward ancora in corso
            }
        }
    }
    else if (isMoving) {
        // Movimento:
        // - Strafe: solo A, S o D (laterale/indietro)
        // - Walk: W senza sprint
        // - Run: Shift + W
        const isSprintingActive = isSprinting && playerStats.stamina > 0;
        const isStrafing = (moveLeft || moveRight || moveBackward) && !moveForward;

        if (isStrafing && knightAnimations.strafe) {
            // A, S o D: usa strafe
            targetAnim = 'strafe';
        } else if (moveForward && isSprintingActive && knightAnimations.run) {
            // W + Shift: usa run
            targetAnim = 'run';
        } else if (moveForward && knightAnimations.walk) {
            // W senza sprint: usa walk
            targetAnim = 'walk';
        } else {
            // Fallback
            targetAnim = knightAnimations.walk ? 'walk' : 'idle';
        }
    }
    else if (knightAnimations.idle) {
        targetAnim = 'idle';
    }

    if (targetAnim && currentKnightAnimName !== targetAnim) {
        playKnightAnimation(targetAnim);
    }
    // Aggiorna stato precedente blocco per prossimo frame
    wasBlocking = isBlocking;

    // Nessun flag jump da gestire (semplificato)

    // Safeguard: normalizza i timeScale delle azioni attive
    // Evita che clip mantengano timeScale errati dopo cambi di stato (es. stamina a zero)
    const normalizeScale = (action, scale) => { if (action && action.isRunning()) action.setEffectiveTimeScale(scale); };
    normalizeScale(knightAnimations.idle, 1.0);
    normalizeScale(knightAnimations.walk, 1.0);
    normalizeScale(knightAnimations.run, 1.0);
    normalizeScale(knightAnimations.strafe, 1.0);
    normalizeScale(knightAnimations.walkLower, 1.0);
    normalizeScale(knightAnimations.runLower, 1.0);
    normalizeScale(knightAnimations.strafeLower, 1.0);
    normalizeScale(knightAnimations.attack, 2.0);
    normalizeScale(knightAnimations.attackUpper, 2.0);
    normalizeScale(knightAnimations.whirlwind, 1.0);
    normalizeScale(knightAnimations.powerup, 1.0);
    normalizeScale(knightAnimations.powerupUpper, 1.0);
    normalizeScale(knightAnimations.jump, 0.6);
}

function createHelmet(parent) {
    const helmetGroup = new THREE.Group();
    const helmGeo = new THREE.BoxGeometry(3.2, 3.4, 3.4);
    const helmMat = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.8, roughness: 0.2 });
    const helm = new THREE.Mesh(helmGeo, helmMat);
    helmetGroup.add(helm);
    const visorGeo = new THREE.BoxGeometry(2.8, 0.5, 3.6);
    const visorMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.9 });
    const visor = new THREE.Mesh(visorGeo, visorMat);
    visor.position.set(0, 0.2, -0.2);
    helmetGroup.add(visor);
    const crestGeo = new THREE.BoxGeometry(0.4, 1.5, 3.8);
    const crestMat = new THREE.MeshLambertMaterial({ color: 0xc0392b });
    const crest = new THREE.Mesh(crestGeo, crestMat);
    crest.position.y = 2.2;
    helmetGroup.add(crest);
    helmetGroup.position.y = 8.5;
    parent.add(helmetGroup);
    return helmetGroup;
}

function createPlayer() {
    // Defensive: if a player mesh already exists (double init), remove it first
    if (typeof playerMesh !== 'undefined' && playerMesh) {
        try { scene.remove(playerMesh); } catch (e) { }
        playerMesh = null;
    }

    // Usa il colore di squadra corrente (già impostato dal menu o default)
    const teamColor = typeof myTeamColor !== 'undefined' ? myTeamColor : 0x2c3e50;
    console.log('[CREATE PLAYER] Using team color:', teamColor.toString(16));

    playerMesh = new THREE.Group();
    const armorMat = new THREE.MeshLambertMaterial({ // Lambert invece di Standard per FPS
        color: teamColor,
        emissive: teamColor,
        emissiveIntensity: 0.3,
        flatShading: true // Flat shading per FPS
    });
    const metalMat = new THREE.MeshLambertMaterial({ // Lambert per performance
        color: 0x95a5a6,
        flatShading: true
    });
    const torso = new THREE.Mesh(new THREE.BoxGeometry(4.5, 6.5, 3), armorMat); torso.position.y = 3.5; playerMesh.add(torso); playerLimbs.torso = torso;
    const chest = new THREE.Mesh(new THREE.BoxGeometry(4.7, 3.5, 3.2), metalMat); chest.position.y = 5.0; playerMesh.add(chest); chest.userData.isTorsoPart = true;

    playerLimbs.head = createHelmet(playerMesh);
    playerLimbs.helmet = playerLimbs.head;

    const legUpperGeo = new THREE.BoxGeometry(1.6, 3.25, 1.6);
    const legLowerGeo = new THREE.BoxGeometry(1.6, 3.25, 1.6);

    playerLimbs.legL = new THREE.Mesh(legUpperGeo, armorMat); playerLimbs.legL.geometry.translate(0, -3.25 / 2, 0);
    playerLimbs.legL.position.set(-1.4, 3.5, 0);
    const bootL = new THREE.Mesh(legLowerGeo, armorMat); bootL.geometry.translate(0, -3.25 / 2, 0);
    bootL.position.y = -3.25;
    playerLimbs.legL.add(bootL);
    playerMesh.add(playerLimbs.legL);
    playerLimbs.bootL = bootL;

    playerLimbs.legR = new THREE.Mesh(legUpperGeo, armorMat); playerLimbs.legR.geometry.translate(0, -3.25 / 2, 0);
    playerLimbs.legR.position.set(1.4, 3.5, 0);
    const bootR = new THREE.Mesh(legLowerGeo, armorMat); bootR.geometry.translate(0, -3.25 / 2, 0);
    bootR.position.y = -3.25;
    playerLimbs.legR.add(bootR);
    playerMesh.add(playerLimbs.legR);
    playerLimbs.bootR = bootR;

    const armGeo = new THREE.BoxGeometry(1.4, 6, 1.4);
    playerLimbs.armL = new THREE.Mesh(armGeo, armorMat); playerLimbs.armL.geometry.translate(0, -2.5, 0); playerLimbs.armL.position.set(-3, 8.0, 0);
    playerMesh.add(playerLimbs.armL);
    playerLimbs.armR = new THREE.Mesh(armGeo, armorMat); playerLimbs.armR.geometry.translate(0, -2.5, 0); playerLimbs.armR.position.set(3, 8.0, 0);
    playerMesh.add(playerLimbs.armR);

    // Posiziona il giocatore alla spawn corretta in base alla modalità
    const spawnPos = getSpawnPosition ? getSpawnPosition() : new THREE.Vector3(0, 6, 0);
    playerMesh.position.copy(spawnPos);

    // Aggiorna il colore dell'armatura con il colore della squadra
    updatePlayerColor();

    scene.add(playerMesh);

    // Carica il modello Knight dopo aver creato il player
    loadKnightModel();
}

function updatePlayerColor() {
    if (!playerMesh) return;

    // Aggiorna il colore di tutti i pezzi dell'armatura
    const currentColor = typeof myTeamColor !== 'undefined' ? myTeamColor : 0x2c3e50;

    console.log('[PLAYER COLOR] Updating player color to:', currentColor.toString(16));

    playerMesh.traverse((child) => {
        if (child.isMesh && child.material) {
            // Salta solo il metallo grigio del petto (chest) e il visore/elmo
            const isMetalPiece = (child.material.color && child.material.color.getHex() === 0x95a5a6) ||
                (child.material.color && child.material.color.getHex() === 0x555555) ||
                (child.material.color && child.material.color.getHex() === 0x111111);

            if (!isMetalPiece && child.material.color) {
                child.material.color.setHex(currentColor);
                if (child.material.emissive) {
                    child.material.emissive.setHex(currentColor);
                }
                child.material.needsUpdate = true; // Forza aggiornamento materiale
            }
        }
    });
}

function createSword() {
    swordContainer = new THREE.Group();
    const blade = new THREE.Mesh(new THREE.BoxGeometry(0.8, 18, 0.2), new THREE.MeshStandardMaterial({ color: 0xecf0f1, metalness: 0.9 })); blade.position.y = 10; swordContainer.add(blade);
    const guard = new THREE.Mesh(new THREE.BoxGeometry(6, 0.8, 0.8), new THREE.MeshStandardMaterial({ color: 0xf39c12 })); guard.position.y = 1; swordContainer.add(guard);
    const hilt = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 4), new THREE.MeshStandardMaterial({ color: 0x5a3a22 })); hilt.position.y = -1.5; swordContainer.add(hilt);

    swordContainer.position.set(0, -5, 0.5);
    swordContainer.rotation.x = -Math.PI / 2;
    swordContainer.rotation.y = 0;
    swordContainer.rotation.z = Math.PI / 2;

    swordContainer.visible = false; playerLimbs.armR.add(swordContainer);
    const trailGeo = new THREE.RingGeometry(8, 12, 32, 1, 0, Math.PI);
    const trailMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.0, side: THREE.DoubleSide });
    const trail = new THREE.Mesh(trailGeo, trailMat); trail.rotation.x = -Math.PI / 2; trail.position.y = 10; swordContainer.add(trail); swordContainer.userData.trail = trail;
}

function createStaff() {
    staffContainer = new THREE.Group();
    staffContainer.add(new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.3, 22), new THREE.MeshStandardMaterial({ color: 0x3e2723 }))).position.y = 6;
    const head = new THREE.Mesh(new THREE.TorusGeometry(1.5, 0.3, 8, 20), new THREE.MeshStandardMaterial({ color: 0xffd700 })); head.position.y = 17; head.rotation.y = Math.PI / 2; staffContainer.add(head);
    const gem = new THREE.Mesh(new THREE.OctahedronGeometry(0.8), new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.9 })); gem.position.y = 17; staffContainer.add(gem);
    staffContainer.userData.gem = gem; staffContainer.position.set(0, -4, 0); staffContainer.rotation.x = -Math.PI / 6; playerLimbs.armR.add(staffContainer);
}

function createBow() {
    bowContainer = new THREE.Group();
    const bowCurve = new THREE.Mesh(new THREE.TorusGeometry(3, 0.2, 8, 12, Math.PI), new THREE.MeshStandardMaterial({ color: 0x8B4513 }));
    bowCurve.rotation.z = -Math.PI / 2;
    bowContainer.add(bowCurve);
    const stringGeo = new THREE.CylinderGeometry(0.05, 0.05, 6);
    const string = new THREE.Mesh(stringGeo, new THREE.MeshBasicMaterial({ color: 0xffffff }));
    string.rotation.z = -Math.PI / 2;
    string.position.x = -0.5;
    bowContainer.add(string);

    bowContainer.position.set(0, -2, 0);
    bowContainer.visible = false;
    playerLimbs.armL.add(bowContainer);
}

function createShield() {
    shieldMesh = new THREE.Mesh(new THREE.BoxGeometry(4, 8, 1), new THREE.MeshBasicMaterial({ color: 0x00aaff, transparent: true, opacity: 0.4, side: THREE.DoubleSide }));
    shieldMesh.position.set(3, -2, 0);
    shieldMesh.rotation.y = -Math.PI / 2;
    shieldMesh.visible = false;
    playerLimbs.armL.add(shieldMesh);
}

function spawnParticles(pos, color, count, speedBase, size, isGibs) {
    const mat = new THREE.MeshBasicMaterial({ color: color });
    for (let i = 0; i < count; i++) {
        const particleSize = isGibs ? (size * (0.5 + random() * 0.5)) : size;
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(particleSize, particleSize, particleSize), mat);
        mesh.position.copy(pos); mesh.position.add(new THREE.Vector3(random() - 0.5, random() - 0.5, random() - 0.5).multiplyScalar(2));
        scene.add(mesh);
        // Ridotto tempo di vita: gibs 2 secondi, particelle normali 0.5 secondi
        const lifeTime = isGibs ? 2.0 : 0.5;
        particles.push({ mesh: mesh, velocity: new THREE.Vector3(random() - 0.5, random() * 0.5 + 0.2, random() - 0.5).normalize().multiplyScalar(speedBase * (random() + 0.5)), life: lifeTime, maxLife: lifeTime, isGib: isGibs });
    }
}

function updateParticles(delta) {
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i]; p.life -= delta; p.velocity.y -= 50.0 * delta;
        p.mesh.position.addScaledVector(p.velocity, delta); p.mesh.rotation.x += delta * 5;
        const scale = p.life / p.maxLife;
        p.mesh.scale.setScalar(scale);
        // Le gibs a terra spariscono gradualmente tramite fade
        if (p.mesh.position.y < 0.5) {
            p.mesh.position.y = 0.5;
            if (p.isGib) {
                p.velocity.y *= -0.5;
                p.velocity.x *= 0.8;
                p.velocity.z *= 0.8;
                // Fade out più rapido quando sono a terra
                p.life -= delta * 2;
            } else {
                p.velocity.set(0, 0, 0);
            }
        }
        if (p.life <= 0) { scene.remove(p.mesh); particles.splice(i, 1); }
    }
}

function createFloatingText(pos, text, color) {
    const el = document.createElement('div'); el.className = 'floating-text'; el.innerText = text; el.style.color = color; document.body.appendChild(el);
    updateFloatingElement(el, pos); floatingTexts.push({ element: el, pos: pos.clone(), life: 1.0 });
}

function updateFloatingTexts(delta) {
    for (let i = floatingTexts.length - 1; i >= 0; i--) {
        const ft = floatingTexts[i]; ft.life -= delta; ft.pos.y += 5 * delta; updateFloatingElement(ft.element, ft.pos);
        if (ft.life <= 0) { ft.element.remove(); floatingTexts.splice(i, 1); }
    }
}

function updateFloatingElement(el, pos) {
    const screenPos = pos.clone().project(camera);
    const x = (screenPos.x * .5 + .5) * window.innerWidth; const y = (-(screenPos.y * .5) + .5) * window.innerHeight;
    el.style.left = x + 'px'; el.style.top = y + 'px';
}

function spawnExplosionVisual(pos, color, radius) {
    const geometry = new THREE.SphereGeometry(radius, 16, 16);
    const material = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.6, wireframe: true });
    const sphere = new THREE.Mesh(geometry, material); sphere.position.copy(pos); scene.add(sphere);
    const light = new THREE.PointLight(color, 2, radius * 3); light.position.copy(pos); scene.add(light);
    let scale = 1.0;
    const expand = setInterval(() => {
        scale += 0.2; sphere.scale.setScalar(scale); sphere.material.opacity -= 0.05;
        if (sphere.material.opacity <= 0) { clearInterval(expand); scene.remove(sphere); scene.remove(light); geometry.dispose(); material.dispose(); }
    }, 30);
    setTimeout(() => { if (sphere.parent) scene.remove(sphere); if (light.parent) scene.remove(light); }, 1000);
}

function flashScreen(colorStr) { const flash = document.getElementById('screen-flash'); flash.style.backgroundColor = colorStr; flash.style.opacity = 0.4; setTimeout(() => { flash.style.opacity = 0; }, 150); }

function spawnGlowEffect(color) {
    let spawnPos;
    if (weaponMode === 'ranged' || weaponMode === 'bow') {
        const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);
        spawnPos = camera.position.clone().add(camDir.multiplyScalar(3));
        spawnParticles(spawnPos, color, 10, 5, 0.2, false);
    } else {
        spawnPos = playerMesh.position.clone().add(new THREE.Vector3(0, 5, 0));
        spawnParticles(playerMesh.position, color, 15, 15, 0.3, false);
    }
    const light = new THREE.PointLight(color, 8, 30); light.position.copy(spawnPos); scene.add(light);
    let intensity = 8;
    const fade = setInterval(() => { intensity -= 0.4; light.intensity = intensity; if (intensity <= 0) { clearInterval(fade); scene.remove(light); } }, 50);
}

function updateAnimations(delta) {
    const time = performance.now() * 0.005;
    const isMoving = moveForward || moveBackward || moveLeft || moveRight;

    if (playerStats.isDead) { playerMesh.position.y = 6; return; }

    // AGGIORNAMENTO ANIMAZIONI KNIGHT
    if (knightModel && knightModel.visible) {
        if (knightMixer) knightMixer.update(delta);
        updateKnightAnimation();
    }

    const neutralArmY = 8.0;

    if (weaponMode === 'ranged') {
        playerLimbs.armR.position.y = 6.0; playerLimbs.armL.position.y = 6.0;
        playerLimbs.armR.rotation.x = -Math.PI / 2 + Math.sin(time) * 0.05 - (isAttacking ? Math.sin(attackTimer * 2) * 0.5 : 0);
        playerLimbs.armR.rotation.z = 0;
        if (staffContainer.userData.gem) staffContainer.userData.gem.scale.setScalar(isAttacking ? 1.5 : 1.0);
        playerLimbs.armL.rotation.x = -0.5 + Math.cos(time) * 0.1;
        playerLimbs.legL.rotation.x = isMoving ? Math.sin(time * 3) * 0.8 : 0; playerLimbs.legR.rotation.x = isMoving ? -Math.sin(time * 3) * 0.8 : 0;
    } else if (weaponMode === 'bow') {
        playerLimbs.armR.position.y = 6.0; playerLimbs.armL.position.y = 6.0;
        // Braccio sx tiene l'arco (teso in avanti, ma spostato al centro per visuale)
        playerLimbs.armL.rotation.x = -Math.PI / 2;
        playerLimbs.armL.rotation.y = -0.2; // slight adjustment
        playerLimbs.armL.position.x = -0.5; // Center more
        playerLimbs.armL.position.y = 5.5; // Lower slightly
        playerLimbs.armL.position.z = 1.5; // Push forward

        if (castingState.active && castingState.type === 'bow_shot') {
            playerLimbs.armR.rotation.x = -Math.PI / 2;
            playerLimbs.armR.position.z = -Math.sin(castingState.timer * 2) * 1.5 + 1; // Tira indietro
        } else {
            playerLimbs.armR.rotation.x = -0.5;
            playerLimbs.armR.position.z = 0;
        }
        playerLimbs.legL.rotation.x = isMoving ? Math.sin(time * 3) * 0.8 : 0; playerLimbs.legR.rotation.x = isMoving ? -Math.sin(time * 3) * 0.8 : 0;
    } else {
        // Reset positions for melee
        playerLimbs.armL.position.x = -3; playerLimbs.armL.position.z = 0;

        playerLimbs.armR.position.y = neutralArmY; playerLimbs.armL.position.y = neutralArmY;
        if (!canJump && !playerStats.isFalling) {
            playerLimbs.legL.rotation.x = 0.8; playerLimbs.legR.rotation.x = 0.8; playerLimbs.armL.rotation.x = -0.8;
            if (!isAttacking) playerLimbs.armR.rotation.x = -0.8;
        } else if (isMoving) {
            const isSprintingActive = isSprinting && playerStats.stamina > 0; const speedMulti = isSprintingActive ? 8 : 4;
            const armAmp = isSprintingActive ? 1.2 : 0.6; const legAmp = isSprintingActive ? 1.4 : 0.8; const angle = Math.sin(time * speedMulti);
            playerLimbs.legL.rotation.x = angle * legAmp; playerLimbs.legR.rotation.x = -angle * legAmp;
            if (playerLimbs.bootL) playerLimbs.bootL.rotation.x = -playerLimbs.legL.rotation.x * 0.6;
            if (playerLimbs.bootR) playerLimbs.bootR.rotation.x = -playerLimbs.legR.rotation.x * 0.6;
            if (!isAttacking && !isWhirlwinding && !isBlocking) {
                playerLimbs.armL.rotation.x = -angle * armAmp; playerLimbs.armR.rotation.x = angle * armAmp;
            }
            playerLimbs.torso.rotation.x = isSprintingActive ? 0.3 : 0.1;
        } else {
            playerLimbs.legL.rotation.x = 0; playerLimbs.legR.rotation.x = 0;
            if (playerLimbs.bootL) playerLimbs.bootL.rotation.x = 0;
            if (playerLimbs.bootR) playerLimbs.bootR.rotation.x = 0;
            if (!isAttacking && !isWhirlwinding && !isBlocking) {
                playerLimbs.armL.rotation.x = Math.sin(time) * 0.05; playerLimbs.armR.rotation.x = -0.1;
            }
            playerLimbs.torso.rotation.x = 0;
        }
    }

    if (isBlocking) {
        playerLimbs.armL.rotation.set(-Math.PI / 2, 0, Math.PI / 2);
        shieldMesh.visible = true;
    } else {
        playerLimbs.armL.rotation.z = 0;
        shieldMesh.visible = false;
    }

    Object.values(otherPlayers).forEach(p => {
        const mesh = p.mesh;
        if (p.isDead) return;
        const enemyNeutralArmY = p.mesh.userData.weaponMode === 'melee' ? neutralArmY : 6.0;
        p.limbs.armR.position.y = enemyNeutralArmY; p.limbs.armL.position.y = enemyNeutralArmY;
        const distMoved = mesh.position.distanceTo(p.lastStepPos || mesh.position);
        if (distMoved > 4.0) { playSound('step', mesh.position); p.lastStepPos.copy(mesh.position); }
        if (mesh.userData.targetPos) mesh.position.lerp(mesh.userData.targetPos, 0.3);
        if (mesh.userData.targetRot) { mesh.rotation.set(mesh.userData.targetRot.x, mesh.userData.targetRot.y, mesh.userData.targetRot.z); }
        const state = mesh.userData.animState; const limbs = p.limbs; let isEnemyAttacking = false;
        if (mesh.userData.isWhirlwinding) {
            // Only rotate manually if Knight model is NOT visible (legacy behavior)
            if (!p.knightModel || !p.knightModel.visible) {
                mesh.rotation.y += delta * 20;
            }
            limbs.armR.rotation.x = -Math.PI / 2; limbs.armL.rotation.x = -Math.PI / 2;
            // Don't return here, let the Knight animation update happen in updateOtherPlayersAnimations
            // But we need to skip the rest of the low-poly limb updates
            return;
        }
        if (mesh.userData.isAttacking) {
            mesh.userData.attackTimer += delta * 15;
            if (mesh.userData.attackTimer > Math.PI) { mesh.userData.isAttacking = false; mesh.userData.attackTimer = 0; } else {
                isEnemyAttacking = true; const progress = mesh.userData.attackTimer / Math.PI; limbs.armR.rotation.x = -Math.PI / 4 - Math.sin(progress * Math.PI) * 1.5;
            }
        }
        if (!isEnemyAttacking) {
            if (mesh.userData.isBlocking) {
                limbs.armL.rotation.set(-Math.PI / 2, 0, Math.PI / 2);
            } else if (state === 'run' || state === 'walk') {
                const speed = state === 'run' ? 8 : 4; const angle = Math.sin(time * speed);
                limbs.legL.rotation.x = angle; limbs.legR.rotation.x = -angle;
                if (limbs.bootL) limbs.bootL.rotation.x = -limbs.legL.rotation.x * 0.6;
                if (limbs.bootR) limbs.bootR.rotation.x = -limbs.legR.rotation.x * 0.6;
                limbs.armL.rotation.x = -angle; limbs.armR.rotation.x = angle;
                if (p.mesh.userData.weaponMode === 'bow') limbs.armL.rotation.x = -Math.PI / 2; // Enemy bow pose
            } else {
                limbs.legL.rotation.x = 0; limbs.legR.rotation.x = 0;
                if (limbs.bootL) limbs.bootL.rotation.x = 0; if (limbs.bootR) limbs.bootR.rotation.x = 0;
                limbs.armL.rotation.x = Math.sin(time) * 0.05; limbs.armR.rotation.x = -Math.sin(time) * 0.05;
                if (p.mesh.userData.weaponMode === 'bow') limbs.armL.rotation.x = -Math.PI / 2; // Enemy bow pose
            }
        }
        if (mesh.userData.hpBar) mesh.userData.hpBar.parent.lookAt(camera.position);
    });
}

function toggleWeaponManual() { toggleWeapon(); }

function toggleWeapon(force) {
    // Logic updated: Q cycles Melee/Ranged, E selects Bow
    // This function is now mainly for visual updates based on current `weaponMode`

    const isMelee = weaponMode === 'melee';
    const isRanged = weaponMode === 'ranged';
    const isBow = weaponMode === 'bow';

    swordContainer.visible = isMelee;
    staffContainer.visible = isRanged;
    bowContainer.visible = isBow;

    // FIX: In prima persona NON mostrare MAI il playerMesh
    playerMesh.visible = isMelee; // Solo in terza persona (melee)
    
    if (isRanged || isBow) {
        stopBlocking();
        euler.x = 0;
    }

    // NASCONDI SEMPRE il personaggio low-poly - NON DEVE MAI ESSERE VISIBILE
    if (playerLimbs.helmet) playerLimbs.helmet.visible = false;
    if (playerLimbs.torso) playerLimbs.torso.visible = false;
    if (playerLimbs.legL) playerLimbs.legL.visible = false;
    if (playerLimbs.legR) playerLimbs.legR.visible = false;
    playerLimbs.armL.visible = false;
    playerLimbs.armR.visible = false;
    playerMesh.children.forEach(c => { if (c.userData.isTorsoPart) c.visible = false; });

    // Gestisci Knight model
    if (isMelee) {
        // In melee: mostra Knight model in terza persona
        if (knightModel) {
            knightModel.visible = true;
            // Aggiorna colore Knight con team color
            const teamColor = typeof myTeamColor !== 'undefined' ? myTeamColor : 0x2c3e50;
            knightModel.traverse((child) => {
                if (child.isMesh && child.material) {
                    child.material.color.setHex(teamColor);
                }
            });
        }
    } else {
        // In ranged/bow: nascondi Knight, mostra solo arma (staff/bow è già visibile)
        if (knightModel) {
            knightModel.visible = false;
        }
    }

    const modeText = isMelee ? "MELEE" : (isRanged ? "RANGED" : "ARCO");
    document.getElementById('weapon-mode-text').innerText = modeText;
    document.getElementById('weapon-mode-text').style.color = isMelee ? "orange" : (isRanged ? "cyan" : "lightgreen");

    const opacity = isMelee ? '0.4' : '1';
    document.querySelectorAll('.action-slot:not(.slot-q):not(.slot-e):not(.slot-r):not(#slot-5):not(#slot-6):not(#slot-7)').forEach(s => s.style.opacity = opacity);

    // Highlight Active Weapon Slot
    document.getElementById('slot-q').classList.remove('active');
    document.getElementById('slot-e').classList.remove('active');

    if (isMelee || isRanged) {
        document.getElementById('slot-q').classList.add('active');
    } else if (isBow) {
        document.getElementById('slot-e').classList.add('active');
    }
}

function updateSwordAnimation(delta) {
    if (isWhirlwinding) {
        const speed = 20; swordContainer.rotation.z = -Math.PI / 2; swordContainer.rotation.y += delta * speed; swordContainer.rotation.x = Math.PI / 2;
        playerLimbs.armR.rotation.x = -Math.PI / 2; playerLimbs.armL.rotation.x = -Math.PI / 2; return;
    }
    if (isAttacking && weaponMode !== 'bow') { attackTimer += delta * 15; if (attackTimer > Math.PI) isAttacking = false; }
    if (weaponMode === 'melee') {
        let targetRotZ = 0;
        let targetRotY = 0;
        let armRotX = 0;

        if (isAttacking) {
            const progress = attackTimer / Math.PI;
            const sweep = Math.cos(progress * Math.PI);
            armRotX = -Math.PI / 4;
            targetRotZ = Math.PI / 2;
            targetRotY = sweep * 1.5;
            swordContainer.rotation.z = targetRotZ;
            swordContainer.rotation.y = targetRotY + Math.PI;
            swordContainer.rotation.x = Math.PI / 2;
            playerLimbs.armR.rotation.x = armRotX;
        } else {
            swordContainer.rotation.set(-Math.PI / 2, Math.PI, 0);
        }
    }
}

function updatePhysics(delta) {
    if (playerStats.mana < playerStats.maxMana) playerStats.mana += SETTINGS.manaRegen * delta;
    let isRegenStaminaBlocked = isBlocking || isWhirlwinding;
    if (isSprinting && (moveForward || moveBackward || moveLeft || moveRight) && playerStats.stamina > 0 && !isBlocking) {
        playerStats.stamina -= SETTINGS.sprintStaminaCostPerSec * delta; isRegenStaminaBlocked = true;
    }
    if (isBlocking) {
        playerStats.stamina -= SETTINGS.blockStaminaCost * delta * 10; if (playerStats.stamina <= 0) stopBlocking(); isRegenStaminaBlocked = true;
    }
    if (!isRegenStaminaBlocked) {
        if (playerStats.stamina < playerStats.maxStamina) playerStats.stamina += SETTINGS.staminaRegen * delta;
    }
    let speed = SETTINGS.speed;
    if (velocity.y != 0) playerStats.isFalling = true;
    if (isBlocking) speed *= 0.5;
    if (isSprinting && (moveForward || moveBackward || moveLeft || moveRight) && playerStats.stamina > 0 && !isBlocking) { speed *= SETTINGS.sprintMulti; }

    velocity.x -= velocity.x * 5 * delta; velocity.z -= velocity.z * 5 * delta; velocity.y -= SETTINGS.gravity * delta;

    const rotY = playerMesh.rotation.y;
    let moving = false;
    const moveVec = new THREE.Vector3();
    if (moveForward) { moveVec.add(new THREE.Vector3(-Math.sin(rotY), 0, -Math.cos(rotY))); moving = true; }
    if (moveBackward) { moveVec.add(new THREE.Vector3(-Math.sin(rotY), 0, -Math.cos(rotY)).negate()); moving = true; }
    if (moveRight) { moveVec.add(new THREE.Vector3(Math.cos(rotY), 0, -Math.sin(rotY))); moving = true; }
    if (moveLeft) { moveVec.add(new THREE.Vector3(Math.cos(rotY), 0, -Math.sin(rotY)).negate()); moving = true; }
    if (moving) {
        moveVec.normalize(); velocity.addScaledVector(moveVec, speed * delta);
        if (!playerStats.isFalling) { distanceSinceStep += speed * delta; if (distanceSinceStep > 400.0) { playSound('step'); distanceSinceStep = 0; } }
    }
    playerMesh.position.addScaledVector(velocity, delta);
    if (playerMesh.position.y <= 6) {
        if (velocity.y <= 0) {
            playerMesh.position.y = 6;
            velocity.y = 0;
            canJump = true;
            playerStats.isFalling = false;
        }
    } else {
        canJump = false;
    }
    playerStats.stamina = Math.max(0, Math.min(playerStats.maxStamina, playerStats.stamina));

    // Check healing temple proximity
    if (window.healingTotemPos) {
        const dist = playerMesh.position.distanceTo(window.healingTotemPos);
        if (dist < 40) {
            playerStats.hp = playerStats.maxHp;
            playerStats.mana = playerStats.maxMana;
            playerStats.stamina = playerStats.maxStamina;
            if (!window.lastHealMessage || Date.now() - window.lastHealMessage > 2000) {
                addFloatingText(playerMesh.position.clone().add(new THREE.Vector3(0, 12, 0)), '✨ COMPLETAMENTE GUARITO ✨', 0x00ffff, 2.0);
                window.lastHealMessage = Date.now();
            }
        }
    }

    obstacles.forEach(o => {
        const box = new THREE.Box3().setFromObject(o);
        // Check collision at player's feet level (y + 2) and head level (y + 10)
        const playerFeetPos = playerMesh.position.clone();
        playerFeetPos.y += 2;
        const playerHeadPos = playerMesh.position.clone();
        playerHeadPos.y += 10;

        // Only collide if obstacle is tall enough (above feet but below head)
        const obstacleHeight = box.max.y - box.min.y;
        const playerBaseY = playerMesh.position.y;

        // Check if player horizontally overlaps with obstacle
        const tempBox = box.clone();
        tempBox.min.y = playerBaseY;
        tempBox.max.y = playerBaseY + 12; // Player height

        if (tempBox.containsPoint(playerFeetPos) || tempBox.containsPoint(playerHeadPos)) {
            // Only push back if obstacle is taller than jump height (>8 units)
            if (obstacleHeight > 8 || box.max.y > playerBaseY + 5) {
                const dir = new THREE.Vector3().subVectors(playerMesh.position, o.position).normalize().setY(0);
                playerMesh.position.addScaledVector(dir, 10 * delta * 60);
            }
        }
    });

    // NUOVO: Collisioni player-to-player (previene che i giocatori si attraversino)
    Object.values(otherPlayers).forEach(op => {
        if (!op.mesh) return;
        
        const otherPos = op.mesh.position;
        const myPos = playerMesh.position;
        
        // Calcola distanza orizzontale (XZ) e verticale (Y)
        const dx = myPos.x - otherPos.x;
        const dz = myPos.z - otherPos.z;
        const distXZ = Math.sqrt(dx * dx + dz * dz);
        const dy = Math.abs(myPos.y - otherPos.y);
        
        // Parametri di collisione
        const collisionRadius = 8.0; // Raggio di collisione tra giocatori
        const collisionHeight = 12.0; // Altezza del cilindro di collisione
        
        // Verifica se i giocatori si sovrappongono
        if (distXZ < collisionRadius && dy < collisionHeight) {
            // Calcola direzione di separazione (solo XZ, mantieni Y)
            const pushDir = new THREE.Vector3(dx, 0, dz);
            
            // Se i giocatori sono esattamente nella stessa posizione, usa direzione casuale
            if (pushDir.lengthSq() < 0.001) {
                pushDir.set(Math.random() - 0.5, 0, Math.random() - 0.5);
            }
            
            pushDir.normalize();
            
            // Calcola quanto devono essere separati
            const overlap = collisionRadius - distXZ;
            const pushStrength = overlap * 20 * delta * 60; // Forza proporzionale alla sovrapposizione
            
            // Sposta il giocatore locale
            playerMesh.position.addScaledVector(pushDir, pushStrength);
            
            // Applica anche una leggera resistenza al movimento
            velocity.x *= 0.5;
            velocity.z *= 0.5;
        }
    });
    if (socket && myId) {
        const animState = !canJump ? 'jump' : (isSprinting ? 'run' : (moving) ? 'walk' : 'idle');
        socket.emit('playerMovement', { position: playerMesh.position, rotation: { x: playerMesh.rotation.x, y: playerMesh.rotation.y, z: playerMesh.rotation.z }, animState: animState, weaponMode: weaponMode });
    }
}

function updateCamera() {
    const headPos = playerMesh.position.clone().add(new THREE.Vector3(0, 8.5, 0));
    if (weaponMode === 'ranged' || weaponMode === 'bow') {
        // FIX: Prima persona - posiziona camera nella testa, NON mostrare playerMesh
        camera.position.copy(headPos).addScaledVector(new THREE.Vector3(0, 0, -1).applyEuler(euler), 0.5);
        camera.quaternion.setFromEuler(euler);
        // playerMesh.visible = false; // GIÀ gestito in toggleWeapon
    } else {
        // Terza persona per melee
        const offset = new THREE.Vector3(0, 16, 25).applyEuler(new THREE.Euler(euler.x, euler.y, 0, 'YXZ'));
        camera.position.copy(headPos).add(offset);
        const lookAtPoint = playerMesh.position.clone().add(new THREE.Vector3(0, 12, 0));
        camera.lookAt(lookAtPoint);
    }
}

// --- ENEMY KNIGHT MODEL IMPLEMENTATION ---

function loadEnemyKnightModel(playerObj) {
    if (playerObj.knightModel) return; // Già caricato

    const loader = new THREE.GLTFLoader();
    loader.load('./models/Knight Met.glb', (gltf) => {
        const model = gltf.scene;

        model.scale.set(10, 10, 10);
        model.position.set(0, -6.0, 0); // Lowered to touch ground (Player pivot is at y=6)
        model.rotation.y = Math.PI;

        // ALWAYS VISIBLE - Hide low poly parts permanently
        model.visible = true;
        if (playerObj.limbs) {
            if (playerObj.limbs.torso) playerObj.limbs.torso.visible = false;
            if (playerObj.limbs.chest) playerObj.limbs.chest.visible = false;
            if (playerObj.limbs.legL) playerObj.limbs.legL.visible = false;
            if (playerObj.limbs.legR) playerObj.limbs.legR.visible = false;
            if (playerObj.limbs.armL) playerObj.limbs.armL.visible = false;
            if (playerObj.limbs.armR) playerObj.limbs.armR.visible = false;
            if (playerObj.limbs.head) playerObj.limbs.head.visible = false;
        }

        // Apply Team Color
        const teamColor = playerObj.teamColor || 0x2c3e50;
        model.traverse((child) => {
            if (child.isMesh && child.material) {
                child.material = child.material.clone();
                child.material.color.setHex(teamColor);
                // Apply 30% tint of team color to preserve texture
                child.material.color.setHex(0xffffff).lerp(new THREE.Color(teamColor), 0.3);

                // Remove emissive to avoid washing out texture
                child.material.emissive = new THREE.Color(0x000000);
                child.material.emissiveIntensity = 0.0;

                child.material.metalness = 0.5;
                child.material.roughness = 0.5;
                
                // FIX: Disabilita frustum culling per evitare scomparsa quando vicino alla camera
                child.frustumCulled = false;
            }
        });

        playerObj.mesh.add(model);
        playerObj.knightModel = model;

        // Setup Animation Mixer
        const mixer = new THREE.AnimationMixer(model);
        playerObj.knightMixer = mixer;
        playerObj.knightAnimations = {};
        playerObj.currentKnightAction = null;

        // MAP ANIMATIONS EXACTLY LIKE LOCAL PLAYER
        if (gltf.animations && gltf.animations.length > 0) {
            console.log(`[ENEMY-LOAD] Animations found for ${playerObj.username}:`, gltf.animations.map(c => c.name));
            gltf.animations.forEach((clip) => {
                const name = clip.name.toLowerCase();
                let action = null;

                if (name.includes('walk') && !name.includes('block') || name.includes('wal')) {
                    // Remove root motion for walk
                    const tracks = clip.tracks.filter(t => !t.name.includes('.position') || (!t.name.toLowerCase().includes('hips') && !t.name.toLowerCase().includes('mixamorig')));
                    const newClip = new THREE.AnimationClip(clip.name, clip.duration, tracks);
                    action = mixer.clipAction(newClip);
                    action.setLoop(THREE.LoopRepeat);
                    playerObj.knightAnimations.walk = action;
                } else if (name.includes('run')) {
                    const tracks = clip.tracks.filter(t => !t.name.includes('.position') || (!t.name.toLowerCase().includes('hips') && !t.name.toLowerCase().includes('mixamorig')));
                    const newClip = new THREE.AnimationClip(clip.name, clip.duration, tracks);
                    action = mixer.clipAction(newClip);
                    action.setLoop(THREE.LoopRepeat);
                    playerObj.knightAnimations.run = action;
                } else if (name.includes('idle') && !name.includes('block')) {
                    action = mixer.clipAction(clip);
                    action.setLoop(THREE.LoopRepeat);
                    playerObj.knightAnimations.idle = action;
                } else if (name.includes('jump')) {
                    // Remove root motion for jump (as requested)
                    const tracks = clip.tracks.filter(t => !t.name.includes('.position') || (!t.name.toLowerCase().includes('hips') && !t.name.toLowerCase().includes('mixamorig')));
                    const newClip = new THREE.AnimationClip(clip.name, clip.duration, tracks);
                    action = mixer.clipAction(newClip);
                    action.setLoop(THREE.LoopOnce);
                    action.clampWhenFinished = true;
                    playerObj.knightAnimations.jump = action;
                } else if (name.includes('attack') || name.includes('slash')) {
                    // Use the first attack found or specific one if needed
                    if (!playerObj.knightAnimations.attack) {
                        action = mixer.clipAction(clip);
                        action.setLoop(THREE.LoopOnce);
                        action.clampWhenFinished = true;
                        action.timeScale = 1.5; // Match local player speed
                        playerObj.knightAnimations.attack = action;
                    }
                } else if (name.includes('spin') || name.includes('whirlwind')) {
                    // Remove root motion
                    const tracks = clip.tracks.filter(t => !t.name.includes('.position') || (!t.name.toLowerCase().includes('hips') && !t.name.toLowerCase().includes('mixamorig')));
                    const newClip = new THREE.AnimationClip(clip.name, clip.duration, tracks);
                    action = mixer.clipAction(newClip);
                    action.setLoop(THREE.LoopOnce);
                    action.clampWhenFinished = true;
                    action.timeScale = 1.5;
                    playerObj.knightAnimations.whirlwind = action;
                } else if (name.includes('powerup') || name.includes('roar') || name.includes('buff') || name.includes('shout')) {
                    // Use original clip to match local player and avoid bugs
                    action = mixer.clipAction(clip);
                    action.setLoop(THREE.LoopOnce);
                    action.clampWhenFinished = true;
                    playerObj.knightAnimations.powerup = action;
                } else if (name.includes('strafe')) {
                    // Remove root motion for strafe
                    const tracks = clip.tracks.filter(t => !t.name.includes('.position') || (!t.name.toLowerCase().includes('hips') && !t.name.toLowerCase().includes('mixamorig')));
                    const newClip = new THREE.AnimationClip(clip.name, clip.duration, tracks);
                    action = mixer.clipAction(newClip);
                    action.setLoop(THREE.LoopRepeat);
                    playerObj.knightAnimations.strafe = action;
                } else if (name.includes('idle') && name.includes('block')) {
                    action = mixer.clipAction(clip);
                    action.setLoop(THREE.LoopRepeat);
                    playerObj.knightAnimations.blockIdle = action;
                } else if (name.includes('block') || name.includes('shield')) {
                    action = mixer.clipAction(clip);
                    action.setLoop(THREE.LoopRepeat);
                    playerObj.knightAnimations.block = action;
                } else if (name.includes('death') || name.includes('die')) {
                    // Animazione morte
                    action = mixer.clipAction(clip);
                    action.setLoop(THREE.LoopOnce);
                    action.clampWhenFinished = true;
                    playerObj.knightAnimations.death = action;
                    console.log(`[ENEMY-LOAD] Mapped death animation for ${playerObj.username}`);
                }
            });

            // --- LAYERED ANIMATION SETUP FOR ENEMY ---
            const upperBodyBones = [];
            const lowerBodyBones = [];

            model.traverse((node) => {
                if (node.isBone) {
                    const boneName = node.name.toLowerCase();
                    if (boneName.includes('spine') || boneName.includes('chest') ||
                        boneName.includes('neck') || boneName.includes('head') ||
                        boneName.includes('shoulder') || boneName.includes('arm') ||
                        boneName.includes('hand') || boneName.includes('finger') ||
                        boneName.includes('clavicle')) {
                        upperBodyBones.push(node);
                    } else if (boneName.includes('hips') || boneName.includes('leg') ||
                        boneName.includes('thigh') || boneName.includes('calf') ||
                        boneName.includes('foot') || boneName.includes('toe')) {
                        lowerBodyBones.push(node);
                    }
                }
            });

            // Create Layered Clips
            // 1. Block Upper (from blockIdle if available, else block)
            if (playerObj.knightAnimations.blockIdle && upperBodyBones.length > 0) {
                const originalClip = playerObj.knightAnimations.blockIdle.getClip();
                const upperClip = createLayeredClip(originalClip, upperBodyBones, 'blockIdle_upperBody');
                playerObj.knightAnimations.blockUpper = mixer.clipAction(upperClip);
                playerObj.knightAnimations.blockUpper.setLoop(THREE.LoopRepeat);
                console.log(`[ENEMY-LOAD] Created blockUpper from blockIdle for ${playerObj.username}`);
            } else if (playerObj.knightAnimations.block && upperBodyBones.length > 0) {
                const originalClip = playerObj.knightAnimations.block.getClip();
                const upperClip = createLayeredClip(originalClip, upperBodyBones, 'block_upperBody');
                playerObj.knightAnimations.blockUpper = mixer.clipAction(upperClip);
                playerObj.knightAnimations.blockUpper.setLoop(THREE.LoopRepeat);
                console.log(`[ENEMY-LOAD] Created blockUpper from block for ${playerObj.username}`);
            }

            // 2. Strafe Lower
            if (playerObj.knightAnimations.strafe && lowerBodyBones.length > 0) {
                const originalClip = playerObj.knightAnimations.strafe.getClip();
                const lowerClip = createLayeredClip(originalClip, lowerBodyBones, 'strafe_lowerBody');
                playerObj.knightAnimations.strafeLower = mixer.clipAction(lowerClip);
                playerObj.knightAnimations.strafeLower.setLoop(THREE.LoopRepeat);
                console.log(`[ENEMY-LOAD] Created strafeLower for ${playerObj.username}`);
            } else {
                console.warn(`[ENEMY-LOAD] Failed to create strafeLower for ${playerObj.username}. Strafe: ${!!playerObj.knightAnimations.strafe}, Bones: ${lowerBodyBones.length}`);
            }

            // 3. Walk/Run Lower (for Powerup layering)
            if (playerObj.knightAnimations.walk && lowerBodyBones.length > 0) {
                const originalClip = playerObj.knightAnimations.walk.getClip();
                const lowerClip = createLayeredClip(originalClip, lowerBodyBones, 'walk_lowerBody');
                playerObj.knightAnimations.walkLower = mixer.clipAction(lowerClip);
                playerObj.knightAnimations.walkLower.setLoop(THREE.LoopRepeat);
                console.log(`[ENEMY-LOAD] Created walkLower for ${playerObj.username}`);
            }
            if (playerObj.knightAnimations.run && lowerBodyBones.length > 0) {
                const originalClip = playerObj.knightAnimations.run.getClip();
                const lowerClip = createLayeredClip(originalClip, lowerBodyBones, 'run_lowerBody');
                playerObj.knightAnimations.runLower = mixer.clipAction(lowerClip);
                playerObj.knightAnimations.runLower.setLoop(THREE.LoopRepeat);
                console.log(`[ENEMY-LOAD] Created runLower for ${playerObj.username}`);
            }

            // 4. Powerup Upper
            if (playerObj.knightAnimations.powerup && upperBodyBones.length > 0) {
                const originalClip = playerObj.knightAnimations.powerup.getClip();
                const upperClip = createLayeredClip(originalClip, upperBodyBones, 'powerup_upperBody');
                playerObj.knightAnimations.powerupUpper = mixer.clipAction(upperClip);
                playerObj.knightAnimations.powerupUpper.setLoop(THREE.LoopOnce);
                playerObj.knightAnimations.powerupUpper.clampWhenFinished = true;
                console.log(`[ENEMY-LOAD] Created powerupUpper for ${playerObj.username}`);
            }

            if (playerObj.knightAnimations.walk && lowerBodyBones.length > 0) {
                const originalClip = playerObj.knightAnimations.walk.getClip();
                const lowerClip = createLayeredClip(originalClip, lowerBodyBones, 'walk_lowerBody');
                playerObj.knightAnimations.walkLower = mixer.clipAction(lowerClip);
                playerObj.knightAnimations.walkLower.setLoop(THREE.LoopRepeat);
            }

            if (playerObj.knightAnimations.run && lowerBodyBones.length > 0) {
                const originalClip = playerObj.knightAnimations.run.getClip();
                const lowerClip = createLayeredClip(originalClip, lowerBodyBones, 'run_lowerBody');
                playerObj.knightAnimations.runLower = mixer.clipAction(lowerClip);
                playerObj.knightAnimations.runLower.setLoop(THREE.LoopRepeat);
            }
        }

        // Start Idle
        if (playerObj.knightAnimations.idle) {
            playerObj.knightAnimations.idle.play();
            playerObj.currentKnightAction = playerObj.knightAnimations.idle;
        }

        console.log(`[ENEMY] Knight model loaded for ${playerObj.username}`);
    });
}

function playEnemyKnightAnimation(playerObj, name, isOneShot = false, forceRestart = false) {
    if (!playerObj.knightAnimations) {
        // console.warn(`[ANIM-DEBUG] No knightAnimations for ${playerObj.username}`);
        return false;
    }
    if (!playerObj.knightAnimations[name]) {
        console.warn(`[ANIM-DEBUG] Animation '${name}' not found for ${playerObj.username}. Trying fallbacks.`);

        // FALLBACK CHAIN
        let fallbackName = 'idle';
        if (name === 'powerup') fallbackName = 'attack'; // If powerup missing, try attack
        else if (name === 'whirlwind') fallbackName = 'attack'; // If whirlwind missing, try attack
        else if (name === 'jump') fallbackName = 'idle'; // If jump missing, use idle

        // Try fallback
        if (playerObj.knightAnimations[fallbackName]) {
            console.log(`[ANIM-DEBUG] Using fallback '${fallbackName}' for '${name}'`);
            // Recursive call with fallback, but ensure we don't loop infinitely
            if (fallbackName !== name) {
                return playEnemyKnightAnimation(playerObj, fallbackName, isOneShot);
            }
        }

        // FINAL RESORT: FORCE IDLE
        if (playerObj.knightAnimations.idle) {
            const idleAction = playerObj.knightAnimations.idle;
            if (playerObj.currentKnightAction !== idleAction) {
                if (playerObj.currentKnightAction) playerObj.currentKnightAction.fadeOut(0.2);
                idleAction.reset();
                idleAction.fadeIn(0.2);
                idleAction.play();
                playerObj.currentKnightAction = idleAction;
            }
        }
        return false;
    }

    // console.log(`[ANIM-DEBUG] Playing '${name}' for ${playerObj.username} (OneShot: ${isOneShot})`);

    const newAction = playerObj.knightAnimations[name];

    // Prevent restarting if already playing (unless forced)
    // This fixes the T-pose/glitch when 'jump' state is sent continuously
    if (playerObj.currentKnightAction === newAction && newAction.isRunning() && !forceRestart) return true;

    if (playerObj.currentKnightAction && playerObj.currentKnightAction !== newAction) {
        playerObj.currentKnightAction.fadeOut(0.2);
    }

    newAction.reset();
    newAction.fadeIn(0.2);
    newAction.play();
    playerObj.currentKnightAction = newAction;

    if (isOneShot) {
        playerObj.isPerformingOneShot = true;
        const onFinished = (e) => {
            if (e.action === newAction) {
                playerObj.knightMixer.removeEventListener('finished', onFinished);
                playerObj.isPerformingOneShot = false;
                // Fallback to idle will happen in update loop
            }
        };
        playerObj.knightMixer.addEventListener('finished', onFinished);
    } else {
        playerObj.isPerformingOneShot = false;
    }
    return true;
}

function updateOtherPlayersAnimations(delta) {
    Object.values(otherPlayers).forEach(p => {
        if (p.knightMixer && p.knightModel && p.knightModel.visible) {
            p.knightMixer.update(delta);

            // Logic to update state based on p.mesh.userData
            const state = p.mesh.userData.animState; // idle, walk, run
            const isAttacking = p.mesh.userData.isAttacking;
            const isWhirlwinding = p.mesh.userData.isWhirlwinding;
            const isBlocking = p.mesh.userData.isBlocking;

            // Handle Powerup Timer locally since it's not in the main loop
            if (p.mesh.userData.isPoweringUp) {
                p.mesh.userData.powerupTimer = (p.mesh.userData.powerupTimer || 0) + delta * 15;
                if (p.mesh.userData.powerupTimer > Math.PI) { // Approx 1s duration
                    p.mesh.userData.isPoweringUp = false;
                    p.mesh.userData.powerupTimer = 0;
                }
            }
            const isPoweringUp = p.mesh.userData.isPoweringUp;

            // Priority: Whirlwind > Block > Powerup > Attack > Movement > Idle
            // REORDERED: Block is now higher priority than Powerup/Attack/OneShot

            // 1. Whirlwind (High Priority State)
            if (isWhirlwinding) {
                if (playEnemyKnightAnimation(p, 'whirlwind', true)) return;
            }

            // 2. Blocking (High Priority - Interrupts Powerup/Attack)
            if (isBlocking) {
                // Stop conflicting one-shot animations (Powerup, Attack)
                if (p.knightAnimations.powerup && p.knightAnimations.powerup.isRunning()) p.knightAnimations.powerup.stop();
                if (p.knightAnimations.powerupUpper && p.knightAnimations.powerupUpper.isRunning()) p.knightAnimations.powerupUpper.stop();
                if (p.knightAnimations.attack && p.knightAnimations.attack.isRunning()) p.knightAnimations.attack.stop();

                // Force exit one-shot mode
                p.isPerformingOneShot = false;

                // Layered Blocking Logic (Upper Block + Lower Strafe)
                // console.log(`[ANIM-DEBUG] Blocking check for ${p.username}: BlockUpper=${!!p.knightAnimations.blockUpper}, StrafeLower=${!!p.knightAnimations.strafeLower}, State=${state}`);

                if (p.knightAnimations.blockUpper && p.knightAnimations.strafeLower && (state === 'run' || state === 'walk')) {
                    // console.log(`[ANIM-DEBUG] ${p.username} is blocking and moving. Activating layered animations.`);

                    // Stop conflicting full-body animations
                    if (p.knightAnimations.blockIdle && p.knightAnimations.blockIdle.isRunning()) p.knightAnimations.blockIdle.fadeOut(0.2);
                    if (p.knightAnimations.block && p.knightAnimations.block.isRunning()) p.knightAnimations.block.fadeOut(0.2);
                    if (p.knightAnimations.walk && p.knightAnimations.walk.isRunning()) p.knightAnimations.walk.fadeOut(0.2);
                    if (p.knightAnimations.run && p.knightAnimations.run.isRunning()) p.knightAnimations.run.fadeOut(0.2);
                    if (p.knightAnimations.strafe && p.knightAnimations.strafe.isRunning()) p.knightAnimations.strafe.fadeOut(0.2);

                    // Activate Upper Layer
                    if (!p.knightAnimations.blockUpper.isRunning()) {
                        p.knightAnimations.blockUpper.reset();
                        p.knightAnimations.blockUpper.play();
                    }
                    p.knightAnimations.blockUpper.setEffectiveWeight(2.0);

                    // Activate Lower Layer
                    if (!p.knightAnimations.strafeLower.isRunning()) {
                        p.knightAnimations.strafeLower.reset();
                        p.knightAnimations.strafeLower.play();
                    }
                    p.knightAnimations.strafeLower.setEffectiveTimeScale(1.0); // Ensure it moves
                    p.knightAnimations.strafeLower.setEffectiveWeight(1.5);

                    p.currentKnightAction = p.knightAnimations.blockUpper;
                    return;

                } else {
                    // Not moving or missing layers -> Full Block
                    // Stop layers if running
                    if (p.knightAnimations.blockUpper && p.knightAnimations.blockUpper.isRunning()) p.knightAnimations.blockUpper.fadeOut(0.2);

                    // Freeze and Fade lower body
                    if (p.knightAnimations.strafeLower && p.knightAnimations.strafeLower.isRunning()) {
                        p.knightAnimations.strafeLower.setEffectiveTimeScale(0);
                        p.knightAnimations.strafeLower.fadeOut(0.2);
                    }
                    if (p.knightAnimations.walkLower && p.knightAnimations.walkLower.isRunning()) {
                        p.knightAnimations.walkLower.setEffectiveTimeScale(0);
                        p.knightAnimations.walkLower.fadeOut(0.2);
                    }
                    if (p.knightAnimations.runLower && p.knightAnimations.runLower.isRunning()) {
                        p.knightAnimations.runLower.setEffectiveTimeScale(0);
                        p.knightAnimations.runLower.fadeOut(0.2);
                    }

                    // Prefer blockIdle if available
                    if (p.knightAnimations.blockIdle) {
                        // SYNC: If blockUpper was running, start blockIdle at the same time
                        let startTime = 0;
                        if (p.knightAnimations.blockUpper && p.knightAnimations.blockUpper.isRunning()) {
                            startTime = p.knightAnimations.blockUpper.time;
                        }

                        playEnemyKnightAnimation(p, 'blockIdle');

                        if (startTime > 0 && p.knightAnimations.blockIdle.isRunning()) {
                            p.knightAnimations.blockIdle.time = startTime;
                        }
                    } else {
                        playEnemyKnightAnimation(p, 'block');
                    }
                    return;
                }
            }

            // 3. Locked One-Shot Animations (Attack, Powerup, Jump landing)
            // Checked AFTER blocking, so blocking can interrupt them
            if (p.isPerformingOneShot) {
                return; // Let animation finish
            }

            // 4. Trigger New Actions
            if (isPoweringUp) {
                // Layered Powerup Logic (Upper Powerup + Lower Run/Walk)
                if (p.knightAnimations.powerupUpper && (state === 'run' || state === 'walk')) {
                    // console.log(`[ANIM-DEBUG] ${p.username} is powering up and moving. Activating layered animations.`);

                    // Stop conflicting full-body animations
                    if (p.knightAnimations.powerup && p.knightAnimations.powerup.isRunning()) p.knightAnimations.powerup.stop();
                    if (p.knightAnimations.walk && p.knightAnimations.walk.isRunning()) p.knightAnimations.walk.fadeOut(0.2);
                    if (p.knightAnimations.run && p.knightAnimations.run.isRunning()) p.knightAnimations.run.fadeOut(0.2);

                    // Activate Upper Layer
                    if (!p.knightAnimations.powerupUpper.isRunning()) {
                        p.knightAnimations.powerupUpper.reset();
                        p.knightAnimations.powerupUpper.play();
                    }
                    p.knightAnimations.powerupUpper.setEffectiveWeight(2.0);

                    // Activate Lower Layer
                    let lowerAction = (state === 'run') ? p.knightAnimations.runLower : p.knightAnimations.walkLower;
                    if (lowerAction) {
                        if (!lowerAction.isRunning()) {
                            lowerAction.reset();
                            lowerAction.play();
                        }
                        lowerAction.setEffectiveTimeScale(1.0);
                        lowerAction.setEffectiveWeight(1.5);
                    }
                    p.currentKnightAction = p.knightAnimations.powerupUpper;
                    return;
                } else {
                    // Not moving or missing layers -> Full Powerup
                    if (p.knightAnimations.walkLower && p.knightAnimations.walkLower.isRunning()) {
                        p.knightAnimations.walkLower.setEffectiveTimeScale(0);
                        p.knightAnimations.walkLower.fadeOut(0.2);
                    }
                    if (p.knightAnimations.runLower && p.knightAnimations.runLower.isRunning()) {
                        p.knightAnimations.runLower.setEffectiveTimeScale(0);
                        p.knightAnimations.runLower.fadeOut(0.2);
                    }
                    if (playEnemyKnightAnimation(p, 'powerup', true)) return;
                }
            }

            if (isAttacking) {
                if (playEnemyKnightAnimation(p, 'attack', true)) return;
            }

            // 5. Movement States (if not blocking/attacking/powering up) else {
            // Stop layers if running
            if (p.knightAnimations.blockUpper && p.knightAnimations.blockUpper.isRunning()) p.knightAnimations.blockUpper.fadeOut(0.2);
            // Freeze and Fade lower body
            if (p.knightAnimations.strafeLower && p.knightAnimations.strafeLower.isRunning()) {
                p.knightAnimations.strafeLower.setEffectiveTimeScale(0);
                p.knightAnimations.strafeLower.fadeOut(0.2);
            }
            if (p.knightAnimations.walkLower && p.knightAnimations.walkLower.isRunning()) {
                p.knightAnimations.walkLower.setEffectiveTimeScale(0);
                p.knightAnimations.walkLower.fadeOut(0.2);
            }
            if (p.knightAnimations.runLower && p.knightAnimations.runLower.isRunning()) {
                p.knightAnimations.runLower.setEffectiveTimeScale(0);
                p.knightAnimations.runLower.fadeOut(0.2);
            }

            // 4. Movement States
            if (state === 'jump') {
                playEnemyKnightAnimation(p, 'jump', true);
            }
            else if (state === 'run') playEnemyKnightAnimation(p, 'run');
            else if (state === 'walk') playEnemyKnightAnimation(p, 'walk');
            else playEnemyKnightAnimation(p, 'idle');
        }

        // SAFETY CHECK: If no action is running, force IDLE
        if (!p.currentKnightAction || !p.currentKnightAction.isRunning()) {
            playEnemyKnightAnimation(p, 'idle');
        }
    });
}

// Expose to window
window.loadEnemyKnightModel = loadEnemyKnightModel;
window.playEnemyKnightAnimation = playEnemyKnightAnimation;
window.updateOtherPlayersAnimations = updateOtherPlayersAnimations;

