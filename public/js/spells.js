// spells.js - autogenerated module from original game.js

// OTTIMIZZAZIONE: Cache geometrie e materiali per riutilizzo
const projectileCache = {
    geometries: {
        missile: new THREE.SphereGeometry(1.0, 8, 6),
        push: new THREE.SphereGeometry(1.8, 8, 6),
        fireball: new THREE.SphereGeometry(3.0, 8, 6),
        arrow: (() => { const g = new THREE.CylinderGeometry(0.1, 0.1, 4, 6); g.rotateX(-Math.PI / 2); return g; })()
    },
    materials: {
        missile: new THREE.MeshBasicMaterial({ color: 0x00ffff }),
        push: new THREE.MeshBasicMaterial({ color: 0xffffff }),
        fireball: new THREE.MeshBasicMaterial({ color: 0xff6600 }),
        arrow: new THREE.MeshBasicMaterial({ color: 0x8B4513 })
    }
};

window.meleeState = { active: false, timer: 0, duration: 0.8, hits: [] };
window.whirlwindState = { active: false, timer: 0, duration: 4.0, hits: [] };
// Whirlwind cooldown is 4000ms. Duration of "damage window" should be maybe 0.5s or 1.0s. Let's say 0.8s.
const MELEE_DURATION = 0.8; // Increased from 0.5 to match attack_1 animation
const WHIRLWIND_DURATION = 0.8;

function startCasting(spellId, type, key) {
    if (castingState.active) return;
    let castTime = 0.5;
    if (spellId === 1) castTime = 0.2;
    if (spellId === 3) castTime = 0.7; // Fireball increased to 0.7s
    if (spellId === 3) castTime = 0.7; // Fireball increased to 0.7s
    if (spellId === 4) castTime = 0.0;
    if (spellId === 5) castTime = SETTINGS.healOtherCastTime / 1000; // Convert to seconds

    if (type === 'bow_shot') {
        if (playerStats.stamina < SETTINGS.arrowCost) {
            addToLog("Not enough Stamina!", "error");
            return;
        }
        castTime = SETTINGS.bowCastTime;
        playSound('bow_reload', playerMesh.position); // Local reload sound
    } else if (type === 'attack' && spellId !== 4) {
        let cost = (spellId === 1) ? SETTINGS.missileCost : (spellId === 2) ? SETTINGS.pushCost : (spellId === 3) ? SETTINGS.fireballCost : (spellId === 5) ? SETTINGS.healOtherCost : SETTINGS.beamCost;

        if (playerStats.mana < cost) { addToLog("Not enough Mana!", "error"); return; }

        if (spellId === 5) {
            const now = performance.now();
            if (now - lastHealOtherTime < SETTINGS.healOtherCooldown) {
                addToLog("Heal Other on Cooldown!", "#ffa500");
                return;
            }
        }

        // TRIGGER MAGE START ANIMATION
        if (typeof switchMageAnimation !== 'undefined') {
            switchMageAnimation("arms_armature|arms_armature|Magic_spell_loop_start");
        }

    } else if (type === 'conversion') {
        const now = performance.now();
        if (now - lastConversionTime < SETTINGS.conversionCooldown) { addToLog("Recharging...", "#aaa"); return; }
    }
    if (castTime === 0) {
        if (type === 'attack') executeAttack(spellId); else if (type === 'conversion') executeConversion(spellId); return;
    }
    castingState.active = true; castingState.timer = 0; castingState.maxTime = castTime; castingState.currentSpell = spellId; castingState.type = type; castingState.ready = false; castingState.keyHeld = key;
    document.getElementById('cast-bar-container').style.display = 'block'; document.getElementById('cast-text').innerText = "CARICAMENTO...";
    const bar = document.getElementById('cast-bar-fill');
    bar.className = ''; bar.style.width = '0%';

    // LOCAL SPELL SOUND (Only for Spells 1, 2, 3, 5)
    if (type === 'attack' && (spellId === 1 || spellId === 2 || spellId === 3 || spellId === 5)) {
        if (typeof playCastingSound === 'function') {
            // Create a temporary object for local player to hold the sound reference
            // We store it in castingState so we can stop it later
            if (!castingState.soundObj) castingState.soundObj = { mesh: playerMesh };
            else castingState.soundObj.mesh = playerMesh; // Ensure mesh is up to date

            playCastingSound(castingState.soundObj);
        }
    }

    // NETWORK: Notify start casting (for hold animation)
    if (socket && socket.connected && (type === 'attack' || type === 'bow_shot')) {
        socket.emit('playerStartCasting', { type: spellId || 'bow' });
    }
}

function stopCasting(key) {
    if (!castingState.active) return;
    if (castingState.keyHeld === key) {
        // STOP LOCAL SPELL SOUND
        if (typeof stopCastingSound === 'function' && castingState.soundObj) {
            stopCastingSound(castingState.soundObj);
            castingState.soundObj = null; // Clear reference
        }

        // NETWORK: Notify stop casting
        if (socket && socket.connected && (castingState.type === 'attack' || castingState.type === 'bow_shot')) {
            socket.emit('playerStopCasting');
        }

        if (castingState.ready) {
            if (castingState.type === 'attack') executeAttack(castingState.currentSpell);
            else if (castingState.type === 'conversion') executeConversion(castingState.currentSpell);
            else if (castingState.type === 'bow_shot') executeAttack('bow');
        } else {
            addToLog("Cast cancelled", "#555");
            // CANCEL ANIMATION -> Return to Idle
            if (typeof switchMageAnimation !== 'undefined') {
                switchMageAnimation("arms_armature|arms_armature|Combat_idle_loop");
            }
        }
        castingState.active = false; document.getElementById('cast-bar-container').style.display = 'none';
    }
}

// FIX: Function to force reset casting state (e.g. on death/respawn)
function resetCastingState() {
    castingState.active = false;
    castingState.timer = 0;
    castingState.ready = false;
    castingState.keyHeld = null;

    const castBar = document.getElementById('cast-bar-container');
    if (castBar) castBar.style.display = 'none';

    // Also reset channeling effects if any
    const slots = document.querySelectorAll('.action-slot');
    slots.forEach(slot => slot.classList.remove('channeling'));
}
window.resetCastingState = resetCastingState;

function updateCasting(delta) {
    if (!castingState.active) return;
    castingState.timer += delta; let progress = Math.min(1, castingState.timer / castingState.maxTime);
    document.getElementById('cast-bar-fill').style.width = (progress * 100) + '%';
    if (progress >= 1 && !castingState.ready) { castingState.ready = true; document.getElementById('cast-text').innerText = "PRONTO!"; document.getElementById('cast-bar-fill').className = 'ready'; }
}

function selectSpell(id) { if (weaponMode !== 'ranged') { weaponMode = 'ranged'; toggleWeapon(true); } currentSpell = id; updateStaffColor(id); updateActionBarUI(); }

function performAttack() {
    if (playerStats.isDead) return;
    if (weaponMode === 'ranged') { startCasting(currentSpell, 'attack', 'Mouse'); }
    else if (weaponMode === 'bow') { startCasting(null, 'bow_shot', 'Mouse'); }
    else {
        if (isBlocking || isWhirlwinding) return;
        if (performance.now() - lastAttackTime < SETTINGS.meleeRate) return;
        lastAttackTime = performance.now();
        swingSword();
    }
}

function executeAttack(id) {
    const now = performance.now();

    if (id === 'bow') {
        // Arrow shot - Calculate from camera NOW
        let camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);
        const spawnPos = camera.position.clone().add(camDir.multiplyScalar(2));
        spawnProjectile(5); // 5 is Arrow ID

        // Trigger FPS Animation
        if (typeof switchArcherAnimation !== 'undefined') {
            switchArcherAnimation('Bow_FIRE');
        }

        if (socket) socket.emit('playerAttack', { type: 5, origin: spawnPos, direction: camDir });
        playSound('bow_shot'); // Use loaded MP3
        return;
    }



    // HEAL OTHER (ID 5)
    if (id === 5) {
        if (playerStats.mana < SETTINGS.healOtherCost) { addToLog("Not enough Mana!", "error"); return; }
        // Check cooldown
        if (now - lastHealOtherTime < SETTINGS.healOtherCooldown) { addToLog("Heal Other in cooldown", "#aaa"); return; }

        playerStats.mana -= SETTINGS.healOtherCost;
        lastHealOtherTime = now;

        // Trigger animation
        if (typeof switchMageAnimation !== 'undefined') {
            switchMageAnimation("arms_armature|arms_armature|Magic_spell_attack");
        }

        if (typeof fireHealBeam === 'function') fireHealBeam();
        spawnGlowEffect(0x00ff00);
        playSound('heal'); // Play sound here or in fireHealBeam
        return;
    }

    let cost = (id === 1) ? SETTINGS.missileCost : (id === 2) ? SETTINGS.pushCost : (id === 3) ? SETTINGS.fireballCost : SETTINGS.beamCost;
    if (playerStats.mana < cost) { addToLog("Not enough Mana!", "error"); return; }
    if (id === 4 && (now - lastSpikesTime < SETTINGS.spikesCooldown)) { addToLog("Spikes recharging...", "#aaa"); return; }
    playerStats.mana -= cost; lastAttackTime = now; isAttacking = true; attackTimer = 0;

    // TRIGGER MAGE ATTACK ANIMATION
    if (typeof switchMageAnimation !== 'undefined') {
        switchMageAnimation("arms_armature|arms_armature|Magic_spell_attack");
    }

    let camDir = new THREE.Vector3(); camera.getWorldDirection(camDir); let spawnPos = getStaffTip();
    if (id === 4) { lastSpikesTime = now; fireHitscan(); } else { spawnProjectile(id); if (socket) socket.emit('playerAttack', { type: id, origin: spawnPos, direction: camDir }); }
    if (id === 1) playSound('shoot_bolt'); if (id === 3) playSound('shoot_fire'); if (id === 2) playSound('shoot_bolt');
}

function performConversion(type) {
    if (playerStats.isDead) return;
    if (castingState.active) { addToLog("Busy casting!", "error"); return; }
    const now = performance.now();
    if (now - lastConversionTime < SETTINGS.conversionCooldown) { addToLog("Recharging...", "#aaa"); return; }

    // Trigger powerup animation in melee mode
    if (weaponMode === 'melee' && knightAnimations.powerup) {
        playKnightAnimation('powerup', true);
    }

    activeConversions.push({ type: type, duration: 5.0, nextTick: 1.0 });
    lastConversionTime = now;
    updateUI();
    const slotId = (type === 1) ? 'slot-5' : (type === 2) ? 'slot-6' : 'slot-7';
    document.getElementById(slotId).classList.add('channeling');
    setTimeout(() => document.getElementById(slotId).classList.remove('channeling'), 5000);

    // Visual effects
    let color = 0xffffff;
    let effectType = 'conversion'; // Renamed to avoid conflict with function parameter 'type'
    if (type === 1) { color = 0xff0000; effectType = 'stamina'; } // Stamina -> HP (Red)
    else if (type === 2) { color = 0x0000ff; effectType = 'mana'; } // HP -> Mana (Blue)
    else if (type === 3) { color = 0xffff00; effectType = 'stamina_gain'; } // Mana -> Stamina (Yellow)

    spawnGlowEffect(color);
    playSound('heal'); // Use heal sound for conversion too

    // Trigger animation locally
    if (weaponMode === 'melee' && knightAnimations.powerup) {
        playKnightAnimation('powerup', true);
    }

    // Notify server for other players
    if (socket && socket.connected) {
        socket.emit('remoteEffect', { type: effectType });
    }
}

function updateConversions(delta) {
    for (let i = activeConversions.length - 1; i >= 0; i--) {
        const conv = activeConversions[i]; conv.duration -= delta; conv.nextTick -= delta;
        if (conv.nextTick <= 0) { applyConversionTick(conv.type); conv.nextTick = 1.0; }
        if (conv.duration <= 0) activeConversions.splice(i, 1);
    }
}

function applyConversionTick(type) {
    const cost = 5; const gain = 5;

    // Calcola posizione testo visibile in prima e terza persona
    let textPosition;
    if (weaponMode === 'ranged' || weaponMode === 'bow') {
        // Prima persona: testo leggermente davanti e in basso rispetto alla camera
        const forward = new THREE.Vector3(0, 0, -1).applyEuler(camera.rotation);
        textPosition = camera.position.clone().add(forward.multiplyScalar(3)).add(new THREE.Vector3(0, -1, 0));
    } else {
        // Terza persona: testo sopra il personaggio
        textPosition = playerMesh.position.clone().add(new THREE.Vector3(0, 8, 0));
    }

    if (type === 1) {
        // Stamina -> HP
        if (playerStats.stamina >= cost && playerStats.hp < playerStats.maxHp) {
            playerStats.stamina -= cost;
            playerStats.hp = Math.min(playerStats.maxHp, playerStats.hp + gain);


            // FIX: Notify server of HP gain to keep sync
            if (socket && socket.connected) {
                socket.emit('playerHealed', { amount: gain });
            }

            // Mostra testo floating HP guadagnato (verde)
            createFloatingText(textPosition, `+${gain}`, '#00ff00');
        }
    }
    else if (type === 2) {
        // HP -> Mana
        if (playerStats.hp > cost && playerStats.mana < playerStats.maxMana) {
            playerStats.hp -= cost;
            playerStats.mana = Math.min(playerStats.maxMana, playerStats.mana + gain);

            // FIX: Notify server of HP loss to keep sync
            if (socket && socket.connected) {
                socket.emit('playerHealed', { amount: -cost });
            }

            // Mostra testo floating Mana guadagnato (blu) e HP perso (rosso)
            // Separazione maggiore in melee per evitare sovrapposizione
            const separation = (weaponMode === 'melee' || weaponMode === 'block') ? 1.5 : 0.5;
            createFloatingText(textPosition.clone().add(new THREE.Vector3(-separation, 0, 0)), `-${cost}`, '#ff6666');
            createFloatingText(textPosition.clone().add(new THREE.Vector3(separation, 0, 0)), `+${gain}`, '#6666ff');
        }
    }
    else if (type === 3) {
        // Mana -> Stamina
        if (playerStats.mana >= cost && playerStats.stamina < playerStats.maxStamina) {
            playerStats.mana -= cost;
            playerStats.stamina = Math.min(playerStats.maxStamina, playerStats.stamina + gain);

            // Mostra testo floating Stamina guadagnata (giallo)
            createFloatingText(textPosition, `+${gain}`, '#ffff00');
        }
    }
    updateUI();
}

function performHeal() {
    if (playerStats.isDead) return;
    if (castingState.active) { addToLog("Busy casting!", "error"); return; }
    const now = performance.now();
    if (now - lastHealTime < SETTINGS.healCooldown) { addToLog("Heal in cooldown", "#aaa"); return; }
    if (playerStats.mana < SETTINGS.healCost) { addToLog("Not enough Mana", "error"); return; }
    if (playerStats.hp >= playerStats.maxHp) return;
    playerStats.mana -= SETTINGS.healCost;
    playerStats.hp = Math.min(playerStats.maxHp, playerStats.hp + SETTINGS.healAmount);

    // Play sound and effect locally
    playSound('heal');
    spawnGlowEffect(0x00ff00);

    // Trigger animation locally
    if (weaponMode === 'melee' && knightAnimations.powerup) {
        playKnightAnimation('powerup', true);
    }

    // Notify server for other players
    if (socket && socket.connected) {
        socket.emit('playerHealed', { amount: SETTINGS.healAmount });
        socket.emit('remoteEffect', { type: 'heal' });
    }
    lastHealTime = now; addToLog(`Healed ${SETTINGS.healAmount} HP`, "heal");

    // FIX: Posiziona testo floating davanti alla camera per visibilità in prima e terza persona
    let textPosition;
    if (weaponMode === 'ranged' || weaponMode === 'bow') {
        // Prima persona: testo leggermente davanti e in basso rispetto alla camera
        const forward = new THREE.Vector3(0, 0, -1).applyEuler(camera.rotation);
        textPosition = camera.position.clone().add(forward.multiplyScalar(3)).add(new THREE.Vector3(0, -1, 0));
    } else {
        // Terza persona: testo sopra il personaggio
        textPosition = playerMesh.position.clone().add(new THREE.Vector3(0, 8, 0));
    }
    createFloatingText(textPosition, `+${SETTINGS.healAmount}`, '#00ff00');

    flashScreen('green'); updateUI();
}

function performWhirlwind() {
    if (playerStats.isDead || isBlocking) return;
    const now = performance.now();
    if (now - lastWhirlwindTime < SETTINGS.whirlwindCooldown) { addToLog("Whirlwind recharging...", "#aaa"); return; }
    if (playerStats.stamina < SETTINGS.whirlwindCost) {
        if (now - (window.lastStaminaLogTime || 0) > 1000) {
            addToLog("Not enough Stamina!", "error");
            window.lastStaminaLogTime = now;
        }
        return;
    }
    playerStats.stamina -= SETTINGS.whirlwindCost; lastWhirlwindTime = now;
    // Permetti whirlwind anche in aria: rimuove early return su !canJump
    if (canJump) {
        // Piccolo impulso verticale solo se a terra
        velocity.y += 150;
        canJump = false;
    }
    // Avvia animazione se disponibile
    if (weaponMode === 'melee' && knightAnimations.whirlwind) {
        playKnightAnimation('whirlwind', true);
    }
    isWhirlwinding = true;
    let whirlDurationMs = 600; // Fixed duration requested by user
    // if (knightAnimations.whirlwind) {
    //     const clipDur = knightAnimations.whirlwind.getClip().duration / knightAnimations.whirlwind.getEffectiveTimeScale();
    //     whirlDurationMs = Math.round(clipDur * 1000);
    //     console.log(`[WHIRLWIND] Flag duration set to clip length: ${clipDur.toFixed(2)}s`);
    // }
    setTimeout(() => { isWhirlwinding = false; }, whirlDurationMs);

    spawnParticles(playerMesh.position, 0xffffff, 40, 60, 0.6, false);
    addToLog("WHIRLWIND ACTIVATED!", "spell-cast");
    playSound('whirlwind');

    if (socket) socket.emit('playerAttack', { type: 'whirlwind', origin: playerMesh.position, direction: new THREE.Vector3(), duration: whirlDurationMs });

    // CONTINUOUS DETECTION START
    whirlwindState.active = true;
    whirlwindState.timer = 0;
    whirlwindState.duration = whirlDurationMs / 1000; // Convert to seconds
    whirlwindState.hits = [];
}

function spawnStoneSpikes(target, isSticky = false) {
    const group = new THREE.Group(); const material = new THREE.MeshLambertMaterial({ color: 0x888888 });
    for (let i = 0; i < 8; i++) {
        const height = 8 + random() * 4; const geo = new THREE.ConeGeometry(1.5, height, 6); const mesh = new THREE.Mesh(geo, material);
        const angle = random() * Math.PI * 2; const radius = 4 + random() * 2;
        mesh.position.set(Math.cos(angle) * radius, height / 2 - 2, Math.sin(angle) * radius);
        mesh.rotation.x = (random() - 0.5) * 0.8; mesh.rotation.z = (random() - 0.5) * 0.8; group.add(mesh);
    }
    if (isSticky && target) { target.add(group); group.position.set(0, 0, 0); } else { scene.add(group); group.position.copy(target instanceof THREE.Vector3 ? target : target.position); }
    setTimeout(() => { if (isSticky && target) target.remove(group); else scene.remove(group); group.children.forEach(c => { c.geometry.dispose(); }); material.dispose(); }, 1500);
}

function fireHitscan() {
    const raycaster = new THREE.Raycaster(); raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
    const opponentMeshes = Object.values(otherPlayers).map(p => p.mesh);
    const intersects = raycaster.intersectObjects([...opponentMeshes, ...obstacles], true);
    if (intersects.length > 0) {
        let hitPoint = intersects[0].point; let obj = intersects[0].object; let enemyFound = null; let currentObj = obj;
        while (currentObj) { if (Object.values(otherPlayers).find(p => p.mesh === currentObj)) { enemyFound = currentObj; break; } currentObj = currentObj.parent; }
        if (enemyFound) {
            spawnStoneSpikes(enemyFound, true);
            const hitId = Object.keys(otherPlayers).find(key => otherPlayers[key].mesh === enemyFound);
            if (hitId && socket) {
                // CRITICAL: Verifica se il target è già morto o ha HP ≤ 0
                if (otherPlayers[hitId].mesh.userData.isDead || (otherPlayers[hitId].hp !== undefined && otherPlayers[hitId].hp <= 0)) {
                    console.log(`[SPUNTONI] Target ${hitId} già morto, hit ignorato`);
                    return;
                }

                let dmg = SETTINGS.beamDmg;
                if (otherPlayers[hitId].mesh.userData.isBlocking) {
                    dmg *= (1.0 - SETTINGS.blockMitigation);
                    createFloatingText(enemyFound.position.clone().add(new THREE.Vector3(0, 10, 0)), "BLOCK", "#aaa");
                } else {
                    createFloatingText(enemyFound.position.clone().add(new THREE.Vector3(0, 10, 0)), `-${Math.round(dmg)}`, "#ff3333");
                }
                socket.emit('playerHit', {
                    damage: dmg,
                    targetId: hitId,
                    hitPosition: otherPlayers[hitId].mesh.position.clone()
                });
                socket.emit('playerAttack', { type: 'spikes', origin: new THREE.Vector3(), direction: new THREE.Vector3(), targetId: hitId });
            }
            addToLog("Stone Spikes hit!", "spell-cast"); playSound('hit');
        } else {
            spawnStoneSpikes(hitPoint, false);
            if (socket) socket.emit('playerAttack', { type: 'spikes', origin: hitPoint, direction: new THREE.Vector3() });
        }
    }
    playSound('shoot_fire');
}

function spawnProjectile(type) {
    // Controllo stamina per arco
    if (type === 5 && playerStats.stamina < SETTINGS.arrowCost) {
        const now = performance.now();
        if (now - (window.lastStaminaLogTime || 0) > 1000) {
            addToLog("Not enough Stamina!", "error");
            window.lastStaminaLogTime = now;
        }
        return;
    }

    if (type === 5) {
        playerStats.stamina -= SETTINGS.arrowCost;
    }

    let geo, mat, speed, color, radius;
    if (type === 1) { geo = projectileCache.geometries.missile; mat = projectileCache.materials.missile; color = 0x00ffff; speed = SETTINGS.missileSpeed; radius = 1.0; }
    else if (type === 2) { geo = projectileCache.geometries.push; mat = projectileCache.materials.push; color = 0xffffff; speed = SETTINGS.pushSpeed; radius = 1.8; }
    else if (type === 3) { geo = projectileCache.geometries.fireball; mat = projectileCache.materials.fireball; color = 0xff6600; speed = SETTINGS.fireballSpeed; radius = 3.0; }
    else if (type === 5) {
        geo = projectileCache.geometries.arrow;
        mat = projectileCache.materials.arrow;
        color = 0x8B4513; speed = SETTINGS.arrowSpeed; radius = 0.5;
    }

    const proj = new THREE.Mesh(geo, mat);

    let spawnPos;
    if (type === 5 && weaponMode === 'bow') {
        const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);
        spawnPos = camera.position.clone().add(camDir.multiplyScalar(2));
    } else {
        spawnPos = getStaffTip();
    }

    const raycaster = new THREE.Raycaster(); raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
    const hits = raycaster.intersectObjects([...obstacles], true);
    let targetPoint;
    if (hits.length > 0) { targetPoint = hits[0].point; } else { const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir); targetPoint = camera.position.clone().add(camDir.multiplyScalar(100)); }

    const velocityDir = new THREE.Vector3().subVectors(targetPoint, spawnPos).normalize();
    proj.position.copy(spawnPos);

    if (type === 5) proj.lookAt(targetPoint);
    else { const light = new THREE.PointLight(color, 1, 30); proj.add(light); }

    proj.userData = { velocity: velocityDir.multiplyScalar(speed), life: (type === 5 ? 5.0 : 2.0), type: type, isMine: true, radius: radius };
    scene.add(proj); projectiles.push(proj);
}

function spawnEnemyProjectile(startPos, direction, type) {
    let color = 0xff0000; let speed = 900; let radius = 1.0;
    let geo, mat;
    if (type === 1) { geo = projectileCache.geometries.missile; mat = projectileCache.materials.missile; color = 0x00ffff; speed = SETTINGS.missileSpeed; radius = 1.0; }
    else if (type === 2) { geo = projectileCache.geometries.push; mat = projectileCache.materials.push; color = 0xffffff; speed = SETTINGS.pushSpeed; radius = 1.8; }
    else if (type === 3) { geo = projectileCache.geometries.fireball; mat = projectileCache.materials.fireball; color = 0xff6600; speed = SETTINGS.fireballSpeed; radius = 3.0; }
    else if (type === 5) {
        geo = projectileCache.geometries.arrow;
        mat = projectileCache.materials.arrow;
        color = 0x8B4513; speed = SETTINGS.arrowSpeed; radius = 0.5;
    }

    const proj = new THREE.Mesh(geo, mat);
    proj.position.copy(startPos);
    const dirVec = new THREE.Vector3(direction.x, direction.y, direction.z).normalize();

    if (type === 5) {
        proj.lookAt(proj.position.clone().add(dirVec));
    } else {
        const light = new THREE.PointLight(color, 1, 20); proj.add(light);
    }

    proj.userData = { velocity: dirVec.multiplyScalar(speed), life: (type === 5 ? 5.0 : 3.0), type: type, isMine: false, radius: radius };
    scene.add(proj); projectiles.push(proj);

    if (type === 5) playSound('bow_shot', startPos);
    else playSound(type === 3 ? 'shoot_fire' : 'shoot_bolt', startPos);
}

function updateProjectiles(delta) {
    const opponentMeshes = Object.values(otherPlayers).map(p => p.mesh);

    for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        const move = p.userData.velocity.clone().multiplyScalar(delta);

        if (move.lengthSq() < 0.000001) continue;

        const prevPos = p.position.clone(); // Salva posizione precedente
        const nextPos = p.position.clone().add(move);
        let hit = false, hitPoint = p.position.clone();
        let hitTarget = null;

        if (p.userData.isMine) {
            // MIGLIORAMENTO: Ray casting continuo per proiettili veloci
            // Controlla collisione lungo il percorso tra posizione precedente e successiva
            Object.values(otherPlayers).forEach(op => {
                if (hit) return; // Skip se già colpito qualcuno

                // --- FIX: Ignore Dead Players ---
                if (op.hp <= 0 || op.mesh.userData.isDead) return;

                const targetPos = op.mesh.position.clone();
                targetPos.y -= 6.0; // Sposta al livello del terreno

                // HITBOX COMPOSTA (Body Cylinder + Head Cone)
                const shoulderHeight = 11.5;
                const totalHeight = 15.5;
                const baseRadius = 4.5;
                const headRadius = 2.5;

                // Crea un ray dalla posizione precedente a quella successiva
                const rayDir = new THREE.Vector3().subVectors(nextPos, prevPos);
                const rayLength = rayDir.length();
                if (rayLength < 0.001) return;

                rayDir.normalize();

                // Trova il punto più vicino al target lungo il ray
                const toTarget = new THREE.Vector3().subVectors(targetPos, prevPos);
                const projection = toTarget.dot(rayDir);

                // Clamp la proiezione alla lunghezza del ray
                const clampedProjection = Math.max(0, Math.min(rayLength, projection));
                const closestPoint = prevPos.clone().add(rayDir.clone().multiplyScalar(clampedProjection));

                // Calcola distanza ORIZZONTALE (XZ) per cilindro
                const dx = closestPoint.x - targetPos.x;
                const dz = closestPoint.z - targetPos.z;
                const distXZ = Math.sqrt(dx * dx + dz * dz);

                // Calcola differenza verticale (Y) dalla BASE dell'hitbox
                const heightDiff = closestPoint.y - targetPos.y;

                // Calcola raggio dinamico in base all'altezza (Cilindro + Cono smussato)
                let allowedRadius = 0;
                if (heightDiff < 0 || heightDiff > totalHeight) {
                    allowedRadius = 0; // Fuori altezza
                } else if (heightDiff <= shoulderHeight) {
                    allowedRadius = baseRadius; // Corpo cilindrico
                } else {
                    // Parte superiore conica (Spalle -> Testa)
                    const ratio = (heightDiff - shoulderHeight) / (totalHeight - shoulderHeight);
                    allowedRadius = baseRadius * (1 - ratio) + headRadius * ratio;
                }

                // Verifica collisione
                if (distXZ < allowedRadius && allowedRadius > 0) {
                    hit = true;
                    hitTarget = op.mesh;
                    hitPoint = closestPoint.clone();
                }
            });

            // Controlla collisione con il mostro IA (con ray casting migliorato)
            if (!hit && isPvEMode && aiMonster && aiMonster.state !== 'dead') {
                // HITBOX CORRETTA per mostro AI
                const targetPos = aiMonster.mesh.position.clone();
                targetPos.y -= 6.0; // Base a livello del terreno

                const targetRadius = 12.0; // Raggio maggiore per il mostro
                const targetHeight = 24.0; // Mostro più alto

                const rayDir = new THREE.Vector3().subVectors(nextPos, prevPos);
                const rayLength = rayDir.length();

                if (rayLength > 0.001) {
                    rayDir.normalize();
                    const toTarget = new THREE.Vector3().subVectors(targetPos, prevPos);
                    const projection = toTarget.dot(rayDir);
                    const clampedProjection = Math.max(0, Math.min(rayLength, projection));
                    const closestPoint = prevPos.clone().add(rayDir.clone().multiplyScalar(clampedProjection));

                    // Distanza cilindrica XZ per mostro AI
                    const dx = closestPoint.x - targetPos.x;
                    const dz = closestPoint.z - targetPos.z;
                    const distXZ = Math.sqrt(dx * dx + dz * dz);
                    const heightDiff = closestPoint.y - targetPos.y;

                    if (distXZ < targetRadius && heightDiff >= 0 && heightDiff <= targetHeight) {
                        hit = true;
                        hitTarget = aiMonster.mesh;
                        hitPoint = closestPoint.clone();
                    }
                }
            }

            if (!hit) {
                obstacleRaycaster.set(p.position, p.userData.velocity.clone().normalize());
                obstacleRaycaster.far = move.length() + 0.1;
                const intersects = obstacleRaycaster.intersectObjects([...obstacles], true);
                if (intersects.length > 0) { hit = true; hitPoint = intersects[0].point; }
            }

            if (hitTarget) {
                let dmg = 0;
                if (p.userData.type === 1) dmg = SETTINGS.missileDmg;
                else if (p.userData.type === 3) dmg = SETTINGS.fireballDmg;
                else if (p.userData.type === 2) dmg = 10;
                else if (p.userData.type === 5) dmg = SETTINGS.arrowDmg;

                // Controlla se il bersaglio è un giocatore o il mostro IA
                const targetId = Object.keys(otherPlayers).find(key => otherPlayers[key].mesh === hitTarget);
                const isMonsterTarget = hitTarget === aiMonster?.mesh;

                if (isMonsterTarget) {
                    // Colpito il mostro IA
                    damageAIMonster(dmg);
                    createFloatingText(hitTarget.position.clone().add(new THREE.Vector3(0, 15, 0)), `-${dmg}`, "#ff9999");
                    addToLog(`Hit monster for ${dmg} damage!`, "dmg-dealt");
                } else if (targetId) {
                    // Colpito un altro giocatore
                    let mitigatedDmg = dmg;
                    if (otherPlayers[targetId].mesh.userData.isBlocking) {
                        mitigatedDmg *= (1.0 - SETTINGS.blockMitigation);
                        createFloatingText(hitTarget.position.clone().add(new THREE.Vector3(0, 10, 0)), "BLOCK", "#aaa");
                    } else {
                        createFloatingText(hitTarget.position.clone().add(new THREE.Vector3(0, 10, 0)), `-${Math.round(mitigatedDmg)}`, "#ff3333");
                    }

                    if (socket) {
                        // CRITICAL: Verifica se il target è già morto o ha HP ≤ 0
                        if (otherPlayers[targetId].mesh.userData.isDead || (otherPlayers[targetId].hp !== undefined && otherPlayers[targetId].hp <= 0)) {
                            console.log(`[PROJECTILE] Target ${targetId} già morto, hit ignorato`);
                            toRemove.push(i);
                            continue;
                        }

                        if (p.userData.type === 2) {
                            spawnExplosionVisual(hitPoint, 0xffffff, SETTINGS.pushVisualRadius);
                            checkShockwaveAoE(hitPoint);
                        } else if (p.userData.type === 3) {
                            spawnExplosionVisual(hitPoint, 0xff4500, SETTINGS.fireballRadius);
                            socket.emit('playerPushed', { targetId: targetId, forceY: SETTINGS.fireballUpForce, damage: mitigatedDmg });
                            checkSplashDamage(hitPoint, SETTINGS.fireballRadius, 5, false);
                            addToLog(`Hit ${otherPlayers[targetId].username} with Fireball!`, "dmg-dealt");
                        } else if (p.userData.type === 5) {
                            // ARROW KNOCKBACK
                            const forceVec = p.userData.velocity.clone().normalize().multiplyScalar(SETTINGS.arrowKnockback);
                            // Aggiunge un po' di lift verticale per evitare attrito a terra
                            forceVec.y = 150;
                            socket.emit('playerPushed', { targetId: targetId, forceVec: forceVec, damage: mitigatedDmg });
                            addToLog(`Hit ${otherPlayers[targetId].username} with Arrow!`, "dmg-dealt");
                        } else {
                            socket.emit('playerHit', {
                                damage: mitigatedDmg,
                                targetId: targetId,
                                hitPosition: otherPlayers[targetId].mesh.position.clone()
                            });
                        }
                    }
                }
            }
        }
        else {
            // MIGLIORAMENTO: Ray casting per proiettili nemici verso il giocatore locale
            // HITBOX CORRETTA: base a livello del terreno
            const targetPos = playerMesh.position.clone();
            targetPos.y -= 6.0; // Sposta al livello del terreno

            const targetRadius = 10.0;
            const targetHeight = 18.0; // Da piedi a sopra testa

            const rayDir = new THREE.Vector3().subVectors(nextPos, prevPos);
            const rayLength = rayDir.length();

            if (rayLength > 0.001) {
                rayDir.normalize();
                const toTarget = new THREE.Vector3().subVectors(targetPos, prevPos);
                const projection = toTarget.dot(rayDir);
                const clampedProjection = Math.max(0, Math.min(rayLength, projection));
                const closestPoint = prevPos.clone().add(rayDir.clone().multiplyScalar(clampedProjection));

                // Distanza cilindrica XZ per proiettili nemici verso giocatore locale
                const dx = closestPoint.x - targetPos.x;
                const dz = closestPoint.z - targetPos.z;
                const distXZ = Math.sqrt(dx * dx + dz * dz);
                const heightDiff = closestPoint.y - targetPos.y;

                if (distXZ < targetRadius && heightDiff >= 0 && heightDiff <= targetHeight) {
                    hit = true;
                    hitPoint = closestPoint.clone();
                    playSound('hit');
                }
            }
        }

        if (!hit && nextPos.y <= 0) {
            hit = true; hitPoint.y = 0; p.position.y = 0;
            if (p.userData.isMine) {
                if (p.userData.type === 2) {
                    spawnExplosionVisual(hitPoint, 0xffffff, SETTINGS.pushVisualRadius);
                    checkShockwaveAoE(hitPoint);
                } else if (p.userData.type === 3) {
                    spawnExplosionVisual(hitPoint, 0xff4500, SETTINGS.fireballRadius);
                    checkSplashDamage(hitPoint, SETTINGS.fireballRadius, 5, false);
                }
            }
        }

        if (hit) {
            if (p.userData.type !== 2 && p.userData.type !== 5) spawnExplosionVisual(hitPoint, p.material.color.getHex(), p.userData.type === 3 ? SETTINGS.fireballRadius : 5);
            scene.remove(p);
            // OTTIMIZZAZIONE: Dispose per prevenire memory leak (geometry è condivisa, non dispose)
            if (p.children.length > 0) p.children.forEach(c => { if (c.dispose) c.dispose(); });
            projectiles.splice(i, 1);
        } else {
            // Salva posizione precedente per debug visualization
            p.userData.prevPosition = p.position.clone();

            p.position.add(move); p.userData.life -= delta;

            let gravity = SETTINGS.gravity;
            if (p.userData.type === 5) gravity = SETTINGS.arrowGravity; // Freccia
            else if (p.userData.type === 1) gravity = SETTINGS.missileGravity; // Dardo
            p.userData.velocity.y -= gravity * delta;

            if (p.userData.type === 5) p.lookAt(p.position.clone().add(p.userData.velocity));
            if (p.userData.life <= 0) {
                scene.remove(p);
                // OTTIMIZZAZIONE: Dispose luci punto per prevenire memory leak
                if (p.children.length > 0) p.children.forEach(c => { if (c.dispose) c.dispose(); });
                projectiles.splice(i, 1);
            }
        }
    }
}

function checkShockwaveAoE(origin) {
    const distToMe = playerMesh.position.distanceTo(origin);
    if (distToMe < SETTINGS.pushRadius) {
        const dir = new THREE.Vector3().subVectors(playerMesh.position, origin).normalize();
        const forceVec = dir.multiplyScalar(SETTINGS.pushForce);
        velocity.add(forceVec);
        velocity.y += SETTINGS.pushUpForce;
        canJump = false; playerStats.isFalling = true; playerMesh.position.y += 0.5;
        addToLog("Knocked back by wave!", "spell-cast"); playSound('jump');
    }

    Object.values(otherPlayers).forEach(op => {
        const distToEnemy = op.mesh.position.distanceTo(origin);
        if (distToEnemy < SETTINGS.pushRadius) {
            // CRITICAL: Verifica se il target è già morto o ha HP ≤ 0
            if (op.mesh.userData.isDead || (op.hp !== undefined && op.hp <= 0)) {
                console.log(`[SHOCKWAVE] Target già morto, push ignorato`);
                return; // Salta questo target
            }

            const targetId = Object.keys(otherPlayers).find(key => otherPlayers[key] === op);
            let finalDmg = 10;
            if (op.mesh.userData.isBlocking) finalDmg *= (1.0 - SETTINGS.blockMitigation);
            // FIX: Assicura che il danno sia sempre positivo (minimo 1)
            finalDmg = Math.max(1, Math.round(finalDmg));
            const dir = new THREE.Vector3().subVectors(op.mesh.position, origin).normalize();
            const forceVec = dir.multiplyScalar(SETTINGS.pushForce);
            forceVec.y = SETTINGS.pushUpForce;
            console.log(`[SHOCKWAVE] Emitting playerPushed: targetId=${targetId}, damage=${finalDmg}`);
            socket.emit('playerPushed', { targetId: targetId, forceVec: forceVec, damage: finalDmg });
        }
    });
}

function checkSplashDamage(origin, radius, damage, pushBack) {
    Object.values(otherPlayers).forEach(op => {
        if (op.mesh.position.distanceTo(origin) < radius) {
            // CRITICAL: Verifica se il target è già morto o ha HP ≤ 0
            if (op.mesh.userData.isDead || (op.hp !== undefined && op.hp <= 0)) {
                console.log(`[SPLASH] Target già morto, danno ignorato`);
                return; // Salta questo target
            }

            const targetId = Object.keys(otherPlayers).find(key => otherPlayers[key] === op);
            let finalDmg = damage;
            if (op.mesh.userData.isBlocking) {
                finalDmg *= (1.0 - SETTINGS.blockMitigation);
                createFloatingText(op.mesh.position.clone().add(new THREE.Vector3(3, 5, 0)), "BLOCK", "#aaa");
            } else {
                createFloatingText(op.mesh.position.clone().add(new THREE.Vector3(3, 5, 0)), `-${Math.round(finalDmg)}`, "#ff3333");
            }
            if (pushBack) {
                const dir = new THREE.Vector3().subVectors(op.mesh.position, origin).normalize();
                const forceVec = dir.multiplyScalar(SETTINGS.pushForce * 0.5);
                forceVec.y = 100;
                socket.emit('playerPushed', { targetId: targetId, forceVec: forceVec, damage: finalDmg });
            } else {
                socket.emit('playerHit', {
                    damage: finalDmg,
                    targetId: targetId,
                    hitPosition: otherPlayers[targetId].mesh.position.clone()
                });
            }
        }
    });
}

function swingSword() {
    if (playerStats.stamina < SETTINGS.meleeStaminaCost) {
        const now = performance.now();
        if (now - (window.lastStaminaLogTime || 0) > 1000) {
            addToLog("Not enough Stamina!", "error");
            window.lastStaminaLogTime = now;
        }
        return;
    }

    playerStats.stamina -= SETTINGS.meleeStaminaCost;
    isAttacking = true; attackTimer = 0;
    if (swordContainer.userData.trail) { swordContainer.userData.trail.material.opacity = 0.8; setTimeout(() => swordContainer.userData.trail.material.opacity = 0, 200); }
    playSound('swing_heavy');

    // Forza riavvio animazione attack del Knight
    if (weaponMode === 'melee' && knightAnimations && knightAnimations.attack) {
        if (currentKnightAction === knightAnimations.attack) {
            knightAnimations.attack.stop();
        }
        currentKnightAnimName = '';
        playKnightAnimation('attack', true);
    }

    if (socket) socket.emit('playerAttack', { type: 'melee', origin: playerMesh.position, direction: new THREE.Vector3() });

    if (socket) socket.emit('playerAttack', { type: 'melee', origin: playerMesh.position, direction: new THREE.Vector3() });

    // CONTINUOUS HIT DETECTION START
    meleeState.active = true;
    meleeState.timer = 0;
    meleeState.duration = MELEE_DURATION;
    meleeState.hits = []; // Reset hits for this swing
}

function updateMeleeCombat(delta) {
    const origin = playerMesh.position.clone();

    // --- MELEE (SWORD) ---
    if (meleeState.active) {
        meleeState.timer += delta;
        // Forward vector changes as player rotates during swing, which is good (drag shots)
        const forward = new THREE.Vector3(0, 0, -1).applyEuler(new THREE.Euler(0, euler.y, 0));

        Object.entries(otherPlayers).forEach(([id, p]) => {
            if (meleeState.hits.includes(id)) return; // Already hit

            // Check Hitbox
            const dir = new THREE.Vector3().subVectors(p.mesh.position, origin);
            const dist = dir.length();

            // CONE CHECK: Distance < Range AND Angle < 10deg (Total 20deg cone)
            // Math.PI / 18 = 10 degrees
            if (dist < SETTINGS.meleeRange && forward.angleTo(dir.normalize()) < Math.PI / 18) {
                // HIT
                let dmg = SETTINGS.meleeDmg;
                if (p.mesh.userData.isBlocking) {
                    dmg *= (1.0 - SETTINGS.blockMitigation);
                    createFloatingText(p.mesh.position.clone().add(new THREE.Vector3(0, 10, 0)), "BLOCK", "#aaa");
                } else {
                    createFloatingText(p.mesh.position.clone().add(new THREE.Vector3(0, 10, 0)), `-${Math.round(dmg)}`, "#ff3333");
                }

                if (socket) {
                    const pushVec = new THREE.Vector3().subVectors(p.mesh.position, origin).normalize().multiplyScalar(SETTINGS.meleeKnockbackForce);
                    socket.emit('playerPushed', { targetId: id, forceVec: pushVec, damage: dmg });
                }
                addToLog(`Hit ${p.username} with Sword! -${Math.round(dmg)}`, "dmg-dealt");
                playSound('punch');
                meleeState.hits.push(id);
            }
        });

        if (meleeState.timer >= meleeState.duration) {
            meleeState.active = false;
        }
    }

    // --- WHIRLWIND ---
    if (whirlwindState.active) {
        whirlwindState.timer += delta;

        Object.entries(otherPlayers).forEach(([id, p]) => {
            if (whirlwindState.hits.includes(id)) return; // Already hit

            // CIRCLE CHECK: Simple Distance < Radius
            const dist = p.mesh.position.distanceTo(origin);

            if (dist < SETTINGS.whirlwindRadius) {
                // HIT
                if (p.mesh.userData.isDead || (p.hp !== undefined && p.hp <= 0)) return;

                let dmg = SETTINGS.whirlwindDmg;
                if (p.mesh.userData.isBlocking) {
                    dmg *= (1.0 - SETTINGS.blockMitigation);
                    createFloatingText(p.mesh.position.clone().add(new THREE.Vector3(0, 10, 0)), "BLOCK", "#aaa");
                } else {
                    createFloatingText(p.mesh.position.clone().add(new THREE.Vector3(0, 10, 0)), `-${Math.round(dmg)}`, "#ff3333");
                }

                if (socket) socket.emit('playerHit', {
                    damage: dmg,
                    targetId: id,
                    hitPosition: p.mesh.position.clone()
                });
                addToLog(`Whirlwind on ${p.username}! -${Math.round(dmg)}`, "dmg-dealt");

                whirlwindState.hits.push(id);
            }
        });

        if (whirlwindState.timer >= whirlwindState.duration) {
            whirlwindState.active = false;
        }
    }
}
window.updateMeleeCombat = updateMeleeCombat;

// === VISUAL EFFECTS FOR CASTING ===

function startCastingEffect(playerObj, spellId) {
    if (!playerObj || !playerObj.mesh) return;

    // Remove existing effect if present (to avoid duplicates)
    stopCastingEffect(playerObj);

    let color = 0xffffff;
    // Map spell ID to Color
    // 1 = Dart (Cyan), 2 = Wave (White/Grey), 3 = Fireball (Orange)
    if (spellId === 1) color = 0x00ffff; // Cyan
    else if (spellId === 2) color = 0xffffff; // White
    else if (spellId === 3) color = 0xff4500; // OrangeHelper (OrangeRed)
    else if (spellId === 5) color = 0x00ff00; // Green (Heal Other)
    else return; // Do not show sphere for Bow or other types

    // PLAY SOUND
    if (typeof playCastingSound === 'function') {
        playCastingSound(playerObj);
    }

    // Geometry & Material
    let geometry = new THREE.SphereGeometry(10.0, 32, 32);
    let material;
    let isEnhanced = false;
    let mainColor, emissiveColor, lightColor;

    if (spellId === 1) { // DART (Cyan)
        isEnhanced = true;
        mainColor = 0x00ffff;
        emissiveColor = 0x0088ff;
        lightColor = 0x00ffff;
    } else if (spellId === 2) { // WAVE (White/Air)
        isEnhanced = true;
        mainColor = 0xffffff;
        emissiveColor = 0xaaaaaa;
        lightColor = 0xaaddff;
    } else if (spellId === 3) { // FIREBALL (Orange/Red)
        isEnhanced = true;
        mainColor = 0xff2200;
        emissiveColor = 0xff4500;
        lightColor = 0xffaa00;
    }

    if (isEnhanced) {
        // Cinematic Visuals for all active spells
        material = new THREE.MeshStandardMaterial({
            color: mainColor,
            emissive: emissiveColor,
            emissiveIntensity: 2.0,
            transparent: true,
            opacity: 0.15, // Base low opacity
            side: THREE.DoubleSide,
            depthWrite: false
        });
    } else {
        // Fallback (should not be reached for 1, 2, 3)
        geometry = new THREE.SphereGeometry(10.0, 16, 16);
        material = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.15,
            side: THREE.DoubleSide,
            depthWrite: false
        });
    }

    const sphere = new THREE.Mesh(geometry, material);
    sphere.userData.isCastingEffect = true;
    sphere.userData.isEnhanced = isEnhanced;

    // Add pulsing animation helper
    sphere.userData.pulseTime = 0;

    // Attach to player mesh: Center at pelvis (approx y=3.5)
    sphere.position.set(0, 3.5, 0);

    if (isEnhanced) {
        // Add Internal PointLight
        const light = new THREE.PointLight(lightColor, 2, 20);
        sphere.add(light);
        sphere.userData.light = light;

        // Initial random offset for "scia" simulation
        sphere.userData.basePos = sphere.position.clone();
    }

    playerObj.mesh.add(sphere);
    playerObj.castingSphere = sphere; // Store reference for easy removal
}

// Global update function for casting visuals
function updateCastingEffects(delta) {
    if (typeof otherPlayers === 'undefined') return;

    // Iterate other players
    Object.values(otherPlayers).forEach(p => {
        // Check for ANY enhanced sphere (Fireball, Dart, Wave)
        if (p.castingSphere && p.castingSphere.userData.isEnhanced) {
            const sphere = p.castingSphere;
            const time = performance.now() / 1000;

            // 1. Intense Emissive with Micro-Variation (Flicker)
            const baseIntensity = 3.0; // Very bright
            const flicker = Math.random() * 2.0; // Random flicker 0.0 to 2.0
            // Combine pulse (slow) with flicker (fast)
            const pulse = Math.sin(time * 8) * 0.5 + 0.5;

            sphere.material.emissiveIntensity = baseIntensity + (pulse * 1.0) + flicker;
            sphere.material.opacity = 0.1 + (Math.random() * 0.15); // Micro opacity flicker (0.1 - 0.25)

            if (sphere.userData.light) {
                sphere.userData.light.intensity = 3 + (flicker * 2);
                // Slight light position jitter
                sphere.userData.light.position.set(
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5
                );
            }

            // 2. Fake Oscillation "Scia lieve" (Perlin-like jitter)
            const noiseX = Math.sin(time * 20) * Math.cos(time * 12);
            const noiseY = Math.cos(time * 15) * Math.sin(time * 18);
            const noiseZ = Math.sin(time * 14) * Math.cos(time * 22);
            const amplitude = 0.2; // Keep it subtle

            if (sphere.userData.basePos) {
                sphere.position.x = sphere.userData.basePos.x + noiseX * amplitude;
                sphere.position.y = sphere.userData.basePos.y + noiseY * amplitude;
                sphere.position.z = sphere.userData.basePos.z + noiseZ * amplitude;
            }

            // 3. Rotation on self (Faster and chaotic)
            sphere.rotation.x += delta * 1.5;
            sphere.rotation.y += delta * 3.0;
            sphere.rotation.z += delta * 0.8;
        }
    });

    // Also update local player if casting fireball?
    // castingState stores reference?
    if (castingState && castingState.active && castingState.currentSpell === 3) {
        // Local visual update is tricky as sphere is not stored in castingState typically same way?
        // Local player doesn't usually see "Casting Effect" sphere in the same way?
        // startCastingEffect is for OTHER players.
        // Local player visuals might be different or needed? "vedere ... del player nemico".
        // Request specifically said "player nemico". So local update is not required.
    }
}
window.updateCastingEffects = updateCastingEffects;

function stopCastingEffect(playerObj) {
    if (!playerObj || !playerObj.mesh) return;

    // STOP SOUND
    if (typeof stopCastingSound === 'function') {
        stopCastingSound(playerObj);
    }

    if (playerObj.castingSphere) {
        playerObj.mesh.remove(playerObj.castingSphere);
        if (playerObj.castingSphere.geometry) playerObj.castingSphere.geometry.dispose();
        if (playerObj.castingSphere.material) playerObj.castingSphere.material.dispose();
        playerObj.castingSphere = null;
    } else {
        // Fallback search if reference lost
        const toRemove = [];
        playerObj.mesh.traverse(child => {
            if (child.userData.isCastingEffect) {
                toRemove.push(child);
            }
        });
        toRemove.forEach(c => {
            playerObj.mesh.remove(c);
            if (c.geometry) c.geometry.dispose();
            if (c.material) c.material.dispose();
        });
    }
}

// Global Exports
window.startCastingEffect = startCastingEffect;
window.stopCastingEffect = stopCastingEffect;
