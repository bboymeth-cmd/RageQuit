// spells.js - autogenerated module from original game.js

function startCasting(spellId, type, key) {
    if (castingState.active) return;
    let castTime = 0.5; if (spellId === 1) castTime = 0.2; if (spellId === 4) castTime = 0.0;

    if (type === 'bow_shot') {
        castTime = SETTINGS.bowCastTime;
    } else if (type === 'attack' && spellId !== 4) {
        let cost = (spellId === 1) ? SETTINGS.missileCost : (spellId === 2) ? SETTINGS.pushCost : (spellId === 3) ? SETTINGS.fireballCost : SETTINGS.beamCost;
        if (playerStats.mana < cost) { addToLog("Mana insufficiente!", "#555"); return; }
    } else if (type === 'conversion') {
        const now = performance.now();
        if (now - lastConversionTime < SETTINGS.conversionCooldown) { addToLog("Ricarica...", "#aaa"); return; }
    }
    if (castTime === 0) {
        if (type === 'attack') executeAttack(spellId); else if (type === 'conversion') executeConversion(spellId); return;
    }
    castingState.active = true; castingState.timer = 0; castingState.maxTime = castTime; castingState.currentSpell = spellId; castingState.type = type; castingState.ready = false; castingState.keyHeld = key;
    document.getElementById('cast-bar-container').style.display = 'block'; document.getElementById('cast-text').innerText = "CARICAMENTO..."; document.getElementById('cast-bar-fill').className = '';
}

function stopCasting(key) {
    if (!castingState.active) return;
    if (castingState.keyHeld === key) {
        if (castingState.ready) {
            if (castingState.type === 'attack') executeAttack(castingState.currentSpell);
            else if (castingState.type === 'conversion') executeConversion(castingState.currentSpell);
            else if (castingState.type === 'bow_shot') executeAttack('bow');
        } else { addToLog("Lancio annullato", "#555"); }
        castingState.active = false; document.getElementById('cast-bar-container').style.display = 'none';
    }
}

function updateCasting(delta) {
    if (!castingState.active) return;
    castingState.timer += delta; let progress = Math.min(1, castingState.timer / castingState.maxTime);
    document.getElementById('cast-bar-fill').style.width = (progress * 100) + '%';
    if (progress >= 1 && !castingState.ready) { castingState.ready = true; document.getElementById('cast-text').innerText = "PRONTO!"; document.getElementById('cast-bar-fill').className = 'ready'; }
}

function selectSpell(id) { if (weaponMode !== 'ranged') { weaponMode = 'ranged'; toggleWeapon(true); } currentSpell = id; updateStaffColor(id); updateActionBarUI(); }

function performAttack() {
    if (playerStats.isDead) return;
    if (weaponMode === 'ranged') { startCasting(currentSpell, 'attack', 'Mouse'); }
    else if (weaponMode === 'bow') { startCasting(null, 'bow_shot', 'Mouse'); }
    else {
        if (isBlocking) return;
        if (performance.now() - lastAttackTime < SETTINGS.meleeRate) return;
        lastAttackTime = performance.now();
        swingSword();
    }
}

function executeAttack(id) {
    const now = performance.now();

    if (id === 'bow') {
        // Arrow shot - Calculate from camera NOW
        let camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);
        const spawnPos = camera.position.clone().add(camDir.multiplyScalar(2));
        spawnProjectile(5); // 5 is Arrow ID
        if (socket) socket.emit('playerAttack', { type: 5, origin: spawnPos, direction: camDir });
        playSound('shoot_bolt'); // Reuse bolt sound
        return;
    }

    let cost = (id === 1) ? SETTINGS.missileCost : (id === 2) ? SETTINGS.pushCost : (id === 3) ? SETTINGS.fireballCost : SETTINGS.beamCost;
    if (playerStats.mana < cost) { addToLog("Mana insufficiente!", "#555"); return; }
    if (id === 4 && (now - lastSpikesTime < SETTINGS.spikesCooldown)) { addToLog("Spuntoni in ricarica...", "#aaa"); return; }
    playerStats.mana -= cost; lastAttackTime = now; isAttacking = true; attackTimer = 0;

    let camDir = new THREE.Vector3(); camera.getWorldDirection(camDir); let spawnPos = getStaffTip();
    if (id === 4) { lastSpikesTime = now; fireHitscan(); } else { spawnProjectile(id); if (socket) socket.emit('playerAttack', { type: id, origin: spawnPos, direction: camDir }); }
    if (id === 1) playSound('shoot_bolt'); if (id === 3) playSound('shoot_fire'); if (id === 2) playSound('shoot_bolt');
}

function performConversion(type) {
    if (playerStats.isDead) return;
    const now = performance.now();
    if (now - lastConversionTime < SETTINGS.conversionCooldown) { addToLog("Ricarica...", "#aaa"); return; }

    // Trigger powerup animation in melee mode
    if (weaponMode === 'melee' && knightAnimations.powerup) {
        playKnightAnimation('powerup', true);
    }

    activeConversions.push({ type: type, duration: 5.0, nextTick: 1.0 });
    lastConversionTime = now;
    updateUI();
    const slotId = (type === 1) ? 'slot-5' : (type === 2) ? 'slot-6' : 'slot-7';
    document.getElementById(slotId).classList.add('channeling');
    setTimeout(() => document.getElementById(slotId).classList.remove('channeling'), 5000);

    // Visual effects
    let color = 0xffffff;
    let effectType = 'conversion'; // Renamed to avoid conflict with function parameter 'type'
    if (type === 1) { color = 0xff0000; effectType = 'stamina'; } // Stamina -> HP (Red)
    else if (type === 2) { color = 0x0000ff; effectType = 'mana'; } // HP -> Mana (Blue)
    else if (type === 3) { color = 0xffff00; effectType = 'stamina_gain'; } // Mana -> Stamina (Yellow)

    spawnGlowEffect(color);
    playSound('heal'); // Use heal sound for conversion too

    // Trigger animation locally
    if (weaponMode === 'melee' && knightAnimations.powerup) {
        playKnightAnimation('powerup', true);
    }

    // Notify server for other players
    if (socket && socket.connected) {
        socket.emit('remoteEffect', { type: effectType });
    }
}

function updateConversions(delta) {
    for (let i = activeConversions.length - 1; i >= 0; i--) {
        const conv = activeConversions[i]; conv.duration -= delta; conv.nextTick -= delta;
        if (conv.nextTick <= 0) { applyConversionTick(conv.type); conv.nextTick = 1.0; }
        if (conv.duration <= 0) activeConversions.splice(i, 1);
    }
}

function applyConversionTick(type) {
    const cost = 5; const gain = 5;
    if (type === 1) {
        // Stamina -> HP
        if (playerStats.stamina >= cost && playerStats.hp < playerStats.maxHp) {
            playerStats.stamina -= cost; 
            playerStats.hp = Math.min(playerStats.maxHp, playerStats.hp + gain);
            // FIX: NON inviare playerHealed per conversioni - gestite solo localmente
            // Questo previene il "burst" doppio di HP (locale + server)
        }
    }
    else if (type === 2) {
        // HP -> Mana
        if (playerStats.hp > cost && playerStats.mana < playerStats.maxMana) {
            playerStats.hp -= cost; 
            playerStats.mana = Math.min(playerStats.maxMana, playerStats.mana + gain);
        }
    }
    else if (type === 3) {
        // Mana -> Stamina
        if (playerStats.mana >= cost && playerStats.stamina < playerStats.maxStamina) {
            playerStats.mana -= cost; 
            playerStats.stamina = Math.min(playerStats.maxStamina, playerStats.stamina + gain);
        }
    }
    updateUI();
}

function performHeal() {
    if (playerStats.isDead) return; const now = performance.now();
    if (now - lastHealTime < SETTINGS.healCooldown) { addToLog("Cura in cooldown", "#aaa"); return; }
    if (playerStats.mana < SETTINGS.healCost) { addToLog("Mana insufficiente", "#555"); return; }
    if (playerStats.hp >= playerStats.maxHp) return;
    playerStats.mana -= SETTINGS.healCost;
    playerStats.hp = Math.min(playerStats.maxHp, playerStats.hp + SETTINGS.healAmount);

    // Play sound and effect locally
    playSound('heal');
    spawnGlowEffect(0x00ff00);

    // Trigger animation locally
    if (weaponMode === 'melee' && knightAnimations.powerup) {
        playKnightAnimation('powerup', true);
    }

    // Notify server for other players
    if (socket && socket.connected) {
        socket.emit('playerHealed', { amount: SETTINGS.healAmount });
        socket.emit('remoteEffect', { type: 'heal' });
    }
    lastHealTime = now; addToLog(`Curato di ${SETTINGS.healAmount} HP`, "heal"); createFloatingText(playerMesh.position.clone().add(new THREE.Vector3(0, 5, 0)), `+${SETTINGS.healAmount}`, '#00ff00');
    flashScreen('green'); updateUI();
}

function performWhirlwind() {
    if (playerStats.isDead || isBlocking) return;
    const now = performance.now();
    if (now - lastWhirlwindTime < SETTINGS.whirlwindCooldown) { addToLog("Whirlwind in ricarica...", "#aaa"); return; }
    if (playerStats.stamina < SETTINGS.whirlwindCost) { addToLog("Stamina insufficiente!", "#555"); return; }
    playerStats.stamina -= SETTINGS.whirlwindCost; lastWhirlwindTime = now;
    // Permetti whirlwind anche in aria: rimuove early return su !canJump
    if (canJump) {
        // Piccolo impulso verticale solo se a terra
        velocity.y += 150;
        canJump = false;
    }
    // Avvia animazione se disponibile
    if (weaponMode === 'melee' && knightAnimations.whirlwind) {
        playKnightAnimation('whirlwind', true);
    }
    isWhirlwinding = true;
    let whirlDurationMs = 500; // fallback
    if (knightAnimations.whirlwind) {
        const clipDur = knightAnimations.whirlwind.getClip().duration / knightAnimations.whirlwind.getEffectiveTimeScale();
        whirlDurationMs = Math.round(clipDur * 1000);
        console.log(`[WHIRLWIND] Flag duration set to clip length: ${clipDur.toFixed(2)}s`);
    }
    setTimeout(() => { isWhirlwinding = false; }, whirlDurationMs);

    spawnParticles(playerMesh.position, 0xffffff, 40, 60, 0.6, false);

    addToLog("TURBINE ATTIVATO!", "spell-cast");
    playSound('whirlwind');

    if (socket) socket.emit('playerAttack', { type: 'whirlwind', origin: playerMesh.position, direction: new THREE.Vector3(), duration: whirlDurationMs });
    Object.values(otherPlayers).forEach((e) => {
        if (e.mesh.position.distanceTo(playerMesh.position) < SETTINGS.whirlwindRadius) {
            // CRITICAL: Verifica se il target è già morto o ha HP ≤ 0
            if (e.mesh.userData.isDead || (e.hp !== undefined && e.hp <= 0)) {
                return; // Salta questo target
            }
            
            let dmg = SETTINGS.whirlwindDmg;
            if (e.mesh.userData.isBlocking) {
                dmg *= (1.0 - SETTINGS.blockMitigation);
                createFloatingText(e.mesh.position.clone().add(new THREE.Vector3(0, 10, 0)), "BLOCK", "#aaa");
            } else {
                createFloatingText(e.mesh.position.clone().add(new THREE.Vector3(0, 10, 0)), `-${Math.round(dmg)}`, "#ff3333");
            }
            if (socket) socket.emit('playerHit', {
                damage: dmg,
                targetId: Object.keys(otherPlayers).find(key => otherPlayers[key] === e),
                hitPosition: e.mesh.position.clone() // Posizione del target al momento dell'hit
            });
        }
    });

    updateUI();
}

function spawnStoneSpikes(target, isSticky = false) {
    const group = new THREE.Group(); const material = new THREE.MeshLambertMaterial({ color: 0x888888 });
    for (let i = 0; i < 8; i++) {
        const height = 8 + random() * 4; const geo = new THREE.ConeGeometry(1.5, height, 6); const mesh = new THREE.Mesh(geo, material);
        const angle = random() * Math.PI * 2; const radius = 4 + random() * 2;
        mesh.position.set(Math.cos(angle) * radius, height / 2 - 2, Math.sin(angle) * radius);
        mesh.rotation.x = (random() - 0.5) * 0.8; mesh.rotation.z = (random() - 0.5) * 0.8; group.add(mesh);
    }
    if (isSticky && target) { target.add(group); group.position.set(0, 0, 0); } else { scene.add(group); group.position.copy(target instanceof THREE.Vector3 ? target : target.position); }
    setTimeout(() => { if (isSticky && target) target.remove(group); else scene.remove(group); group.children.forEach(c => { c.geometry.dispose(); }); material.dispose(); }, 1500);
}

function fireHitscan() {
    const raycaster = new THREE.Raycaster(); raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
    const opponentMeshes = Object.values(otherPlayers).map(p => p.mesh);
    const intersects = raycaster.intersectObjects([...opponentMeshes, ...obstacles], true);
    if (intersects.length > 0) {
        let hitPoint = intersects[0].point; let obj = intersects[0].object; let enemyFound = null; let currentObj = obj;
        while (currentObj) { if (Object.values(otherPlayers).find(p => p.mesh === currentObj)) { enemyFound = currentObj; break; } currentObj = currentObj.parent; }
        if (enemyFound) {
            spawnStoneSpikes(enemyFound, true);
            const hitId = Object.keys(otherPlayers).find(key => otherPlayers[key].mesh === enemyFound);
            if (hitId && socket) {
                // CRITICAL: Verifica se il target è già morto o ha HP ≤ 0
                if (otherPlayers[hitId].mesh.userData.isDead || (otherPlayers[hitId].hp !== undefined && otherPlayers[hitId].hp <= 0)) {
                    console.log(`[SPUNTONI] Target ${hitId} già morto, hit ignorato`);
                    return;
                }
                
                let dmg = SETTINGS.beamDmg;
                if (otherPlayers[hitId].mesh.userData.isBlocking) {
                    dmg *= (1.0 - SETTINGS.blockMitigation);
                    createFloatingText(enemyFound.position.clone().add(new THREE.Vector3(0, 10, 0)), "BLOCK", "#aaa");
                } else {
                    createFloatingText(enemyFound.position.clone().add(new THREE.Vector3(0, 10, 0)), `-${Math.round(dmg)}`, "#ff3333");
                }
                socket.emit('playerHit', {
                    damage: dmg,
                    targetId: hitId,
                    hitPosition: otherPlayers[hitId].mesh.position.clone()
                });
                socket.emit('playerAttack', { type: 'spikes', origin: new THREE.Vector3(), direction: new THREE.Vector3(), targetId: hitId });
            }
            addToLog("Spuntoni di Pietra colpiti!", "spell-cast"); playSound('hit');
        } else {
            spawnStoneSpikes(hitPoint, false);
            if (socket) socket.emit('playerAttack', { type: 'spikes', origin: hitPoint, direction: new THREE.Vector3() });
        }
    }
    playSound('shoot_fire');
}

function spawnProjectile(type) {
    // Controllo stamina per arco
    if (type === 5 && playerStats.stamina < SETTINGS.arrowCost) {
        addToLog("Stamina insufficiente!", "#555");
        return;
    }

    if (type === 5) {
        playerStats.stamina -= SETTINGS.arrowCost;
    }

    let geo, speed, color, radius;
    if (type === 1) { geo = new THREE.SphereGeometry(1.0); color = 0x00ffff; speed = SETTINGS.missileSpeed; radius = 1.0; }
    else if (type === 2) { geo = new THREE.SphereGeometry(1.8); color = 0xffffff; speed = SETTINGS.pushSpeed; radius = 1.8; }
    else if (type === 3) { geo = new THREE.SphereGeometry(3.0); color = 0xff6600; speed = SETTINGS.fireballSpeed; radius = 3.0; }
    else if (type === 5) {
        geo = new THREE.CylinderGeometry(0.1, 0.1, 4);
        // RUOTA LA GEOMETRIA PER ALLINEARLA ALL'ASSE Z (Orizzontale)
        geo.rotateX(-Math.PI / 2);
        color = 0x8B4513; speed = SETTINGS.arrowSpeed; radius = 0.5;
    }

    const proj = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: color }));

    let spawnPos;
    if (type === 5 && weaponMode === 'bow') {
        const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);
        spawnPos = camera.position.clone().add(camDir.multiplyScalar(2));
    } else {
        spawnPos = getStaffTip();
    }

    const raycaster = new THREE.Raycaster(); raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
    const hits = raycaster.intersectObjects([...obstacles], true);
    let targetPoint;
    if (hits.length > 0) { targetPoint = hits[0].point; } else { const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir); targetPoint = camera.position.clone().add(camDir.multiplyScalar(100)); }

    const velocityDir = new THREE.Vector3().subVectors(targetPoint, spawnPos).normalize();
    proj.position.copy(spawnPos);

    if (type === 5) proj.lookAt(targetPoint);
    else { const light = new THREE.PointLight(color, 1, 30); proj.add(light); }

    proj.userData = { velocity: velocityDir.multiplyScalar(speed), life: (type === 5 ? 5.0 : 2.0), type: type, isMine: true, radius: radius };
    scene.add(proj); projectiles.push(proj);
}

function spawnEnemyProjectile(startPos, direction, type) {
    let color = 0xff0000; let speed = 900; let radius = 1.0;
    let geo;
    if (type === 1) { geo = new THREE.SphereGeometry(1.0); color = 0x00ffff; speed = SETTINGS.missileSpeed; radius = 1.0; }
    else if (type === 2) { geo = new THREE.SphereGeometry(1.8); color = 0xffffff; speed = SETTINGS.pushSpeed; radius = 1.8; }
    else if (type === 3) { geo = new THREE.SphereGeometry(3.0); color = 0xff6600; speed = SETTINGS.fireballSpeed; radius = 3.0; }
    else if (type === 5) {
        geo = new THREE.CylinderGeometry(0.1, 0.1, 4);
        geo.rotateX(-Math.PI / 2);
        color = 0x8B4513; speed = SETTINGS.arrowSpeed; radius = 0.5;
    }

    const proj = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: color }));
    proj.position.copy(startPos);
    const dirVec = new THREE.Vector3(direction.x, direction.y, direction.z).normalize();

    if (type === 5) {
        proj.lookAt(proj.position.clone().add(dirVec));
    } else {
        const light = new THREE.PointLight(color, 1, 20); proj.add(light);
    }

    proj.userData = { velocity: dirVec.multiplyScalar(speed), life: (type === 5 ? 5.0 : 3.0), type: type, isMine: false, radius: radius };
    scene.add(proj); projectiles.push(proj); playSound(type === 3 ? 'shoot_fire' : 'shoot_bolt');
}

function updateProjectiles(delta) {
    const opponentMeshes = Object.values(otherPlayers).map(p => p.mesh);

    for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        const move = p.userData.velocity.clone().multiplyScalar(delta);

        if (move.lengthSq() < 0.000001) continue;

        const prevPos = p.position.clone(); // Salva posizione precedente
        const nextPos = p.position.clone().add(move);
        let hit = false, hitPoint = p.position.clone();
        let hitTarget = null;

        if (p.userData.isMine) {
            // MIGLIORAMENTO: Ray casting continuo per proiettili veloci
            // Controlla collisione lungo il percorso tra posizione precedente e successiva
            Object.values(otherPlayers).forEach(op => {
                if (hit) return; // Skip se già colpito qualcuno

                // HITBOX CORRETTA: usa bottom del player (y-6) come base dell'hitbox
                const targetPos = op.mesh.position.clone();
                targetPos.y -= 6.0; // Sposta al livello del terreno (pivot è a y=6, piedi a y=0)
                
                const targetRadius = 10.0; // Raggio di collisione aumentato per catturare meglio i colpi
                const targetHeight = 18.0; // Da piedi (y=0) a sopra testa (y=18)

                // Crea un ray dalla posizione precedente a quella successiva
                const rayDir = new THREE.Vector3().subVectors(nextPos, prevPos);
                const rayLength = rayDir.length();
                if (rayLength < 0.001) return;
                
                rayDir.normalize();

                // Trova il punto più vicino al target lungo il ray
                const toTarget = new THREE.Vector3().subVectors(targetPos, prevPos);
                const projection = toTarget.dot(rayDir);
                
                // Clamp la proiezione alla lunghezza del ray
                const clampedProjection = Math.max(0, Math.min(rayLength, projection));
                const closestPoint = prevPos.clone().add(rayDir.clone().multiplyScalar(clampedProjection));

                // Calcola distanza ORIZZONTALE (XZ) per cilindro
                const dx = closestPoint.x - targetPos.x;
                const dz = closestPoint.z - targetPos.z;
                const distXZ = Math.sqrt(dx * dx + dz * dz);
                
                // Calcola differenza verticale (Y) dalla BASE dell'hitbox
                const heightDiff = closestPoint.y - targetPos.y;

                // Verifica collisione con cilindro: da y=0 (piedi) fino a y=18 (sopra testa)
                if (distXZ < targetRadius && heightDiff >= 0 && heightDiff <= targetHeight) {
                    hit = true;
                    hitTarget = op.mesh;
                    hitPoint = closestPoint.clone();
                }
            });

            // Controlla collisione con il mostro IA (con ray casting migliorato)
            if (!hit && isPvEMode && aiMonster && aiMonster.state !== 'dead') {
                // HITBOX CORRETTA per mostro AI
                const targetPos = aiMonster.mesh.position.clone();
                targetPos.y -= 6.0; // Base a livello del terreno
                
                const targetRadius = 12.0; // Raggio maggiore per il mostro
                const targetHeight = 24.0; // Mostro più alto

                const rayDir = new THREE.Vector3().subVectors(nextPos, prevPos);
                const rayLength = rayDir.length();
                
                if (rayLength > 0.001) {
                    rayDir.normalize();
                    const toTarget = new THREE.Vector3().subVectors(targetPos, prevPos);
                    const projection = toTarget.dot(rayDir);
                    const clampedProjection = Math.max(0, Math.min(rayLength, projection));
                    const closestPoint = prevPos.clone().add(rayDir.clone().multiplyScalar(clampedProjection));

                    // Distanza cilindrica XZ per mostro AI
                    const dx = closestPoint.x - targetPos.x;
                    const dz = closestPoint.z - targetPos.z;
                    const distXZ = Math.sqrt(dx * dx + dz * dz);
                    const heightDiff = closestPoint.y - targetPos.y;

                    if (distXZ < targetRadius && heightDiff >= 0 && heightDiff <= targetHeight) {
                        hit = true;
                        hitTarget = aiMonster.mesh;
                        hitPoint = closestPoint.clone();
                    }
                }
            }

            if (!hit) {
                obstacleRaycaster.set(p.position, p.userData.velocity.clone().normalize());
                obstacleRaycaster.far = move.length() + 0.1;
                const intersects = obstacleRaycaster.intersectObjects([...obstacles], true);
                if (intersects.length > 0) { hit = true; hitPoint = intersects[0].point; }
            }

            if (hitTarget) {
                let dmg = 0;
                if (p.userData.type === 1) dmg = SETTINGS.missileDmg;
                else if (p.userData.type === 3) dmg = SETTINGS.fireballDmg;
                else if (p.userData.type === 2) dmg = 10;
                else if (p.userData.type === 5) dmg = SETTINGS.arrowDmg;

                // Controlla se il bersaglio è un giocatore o il mostro IA
                const targetId = Object.keys(otherPlayers).find(key => otherPlayers[key].mesh === hitTarget);
                const isMonsterTarget = hitTarget === aiMonster?.mesh;

                if (isMonsterTarget) {
                    // Colpito il mostro IA
                    damageAIMonster(dmg);
                    createFloatingText(hitTarget.position.clone().add(new THREE.Vector3(0, 15, 0)), `-${dmg}`, "#ff9999");
                    addToLog(`Colpito il mostro per ${dmg} danni!`, "dmg-dealt");
                } else if (targetId) {
                    // Colpito un altro giocatore
                    let mitigatedDmg = dmg;
                    if (otherPlayers[targetId].mesh.userData.isBlocking) {
                        mitigatedDmg *= (1.0 - SETTINGS.blockMitigation);
                        createFloatingText(hitTarget.position.clone().add(new THREE.Vector3(0, 10, 0)), "BLOCK", "#aaa");
                    } else {
                        createFloatingText(hitTarget.position.clone().add(new THREE.Vector3(0, 10, 0)), `-${Math.round(mitigatedDmg)}`, "#ff3333");
                    }

                    if (socket) {
                        // CRITICAL: Verifica se il target è già morto o ha HP ≤ 0
                        if (otherPlayers[targetId].mesh.userData.isDead || (otherPlayers[targetId].hp !== undefined && otherPlayers[targetId].hp <= 0)) {
                            console.log(`[PROJECTILE] Target ${targetId} già morto, hit ignorato`);
                            toRemove.push(i);
                            continue;
                        }
                        
                        if (p.userData.type === 2) {
                            spawnExplosionVisual(hitPoint, 0xffffff, SETTINGS.pushVisualRadius);
                            checkShockwaveAoE(hitPoint);
                        } else if (p.userData.type === 3) {
                            spawnExplosionVisual(hitPoint, 0xff4500, SETTINGS.fireballRadius);
                            socket.emit('playerPushed', { targetId: targetId, forceY: SETTINGS.fireballUpForce, damage: mitigatedDmg });
                            checkSplashDamage(hitPoint, SETTINGS.fireballRadius, 5, false);
                            addToLog(`Colpito ${otherPlayers[targetId].username} con Palla di Fuoco!`, "dmg-dealt");
                        } else {
                            socket.emit('playerHit', {
                                damage: mitigatedDmg,
                                targetId: targetId,
                                hitPosition: otherPlayers[targetId].mesh.position.clone()
                            });
                        }
                    }
                }
            }
        }
        else {
            // MIGLIORAMENTO: Ray casting per proiettili nemici verso il giocatore locale
            // HITBOX CORRETTA: base a livello del terreno
            const targetPos = playerMesh.position.clone();
            targetPos.y -= 6.0; // Sposta al livello del terreno
            
            const targetRadius = 10.0;
            const targetHeight = 18.0; // Da piedi a sopra testa

            const rayDir = new THREE.Vector3().subVectors(nextPos, prevPos);
            const rayLength = rayDir.length();
            
            if (rayLength > 0.001) {
                rayDir.normalize();
                const toTarget = new THREE.Vector3().subVectors(targetPos, prevPos);
                const projection = toTarget.dot(rayDir);
                const clampedProjection = Math.max(0, Math.min(rayLength, projection));
                const closestPoint = prevPos.clone().add(rayDir.clone().multiplyScalar(clampedProjection));

                // Distanza cilindrica XZ per proiettili nemici verso giocatore locale
                const dx = closestPoint.x - targetPos.x;
                const dz = closestPoint.z - targetPos.z;
                const distXZ = Math.sqrt(dx * dx + dz * dz);
                const heightDiff = closestPoint.y - targetPos.y;

                if (distXZ < targetRadius && heightDiff >= 0 && heightDiff <= targetHeight) {
                    hit = true;
                    hitPoint = closestPoint.clone();
                    playSound('hit');
                }
            }
        }

        if (!hit && nextPos.y <= 0) {
            hit = true; hitPoint.y = 0; p.position.y = 0;
            if (p.userData.isMine) {
                if (p.userData.type === 2) {
                    spawnExplosionVisual(hitPoint, 0xffffff, SETTINGS.pushVisualRadius);
                    checkShockwaveAoE(hitPoint);
                } else if (p.userData.type === 3) {
                    spawnExplosionVisual(hitPoint, 0xff4500, SETTINGS.fireballRadius);
                    checkSplashDamage(hitPoint, SETTINGS.fireballRadius, 5, false);
                }
            }
        }

        if (hit) {
            if (p.userData.type !== 2 && p.userData.type !== 5) spawnExplosionVisual(hitPoint, p.material.color.getHex(), p.userData.type === 3 ? SETTINGS.fireballRadius : 5);
            scene.remove(p); projectiles.splice(i, 1);
        } else {
            // Salva posizione precedente per debug visualization
            p.userData.prevPosition = p.position.clone();
            
            p.position.add(move); p.userData.life -= delta;

            let gravity = SETTINGS.gravity;
            if (p.userData.type === 5) gravity = SETTINGS.arrowGravity; // Freccia
            else if (p.userData.type === 1) gravity = SETTINGS.missileGravity; // Dardo
            p.userData.velocity.y -= gravity * delta;

            if (p.userData.type === 5) p.lookAt(p.position.clone().add(p.userData.velocity));
            if (p.userData.life <= 0) { scene.remove(p); projectiles.splice(i, 1); }
        }
    }
}

function checkShockwaveAoE(origin) {
    const distToMe = playerMesh.position.distanceTo(origin);
    if (distToMe < SETTINGS.pushRadius) {
        const dir = new THREE.Vector3().subVectors(playerMesh.position, origin).normalize();
        const forceVec = dir.multiplyScalar(SETTINGS.pushForce);
        velocity.add(forceVec);
        velocity.y += SETTINGS.pushUpForce;
        canJump = false; playerStats.isFalling = true; playerMesh.position.y += 0.5;
        addToLog("Sbalzato dall'onda!", "spell-cast"); playSound('jump');
    }

    Object.values(otherPlayers).forEach(op => {
        const distToEnemy = op.mesh.position.distanceTo(origin);
        if (distToEnemy < SETTINGS.pushRadius) {
            // CRITICAL: Verifica se il target è già morto o ha HP ≤ 0
            if (op.mesh.userData.isDead || (op.hp !== undefined && op.hp <= 0)) {
                console.log(`[SHOCKWAVE] Target già morto, push ignorato`);
                return; // Salta questo target
            }
            
            const targetId = Object.keys(otherPlayers).find(key => otherPlayers[key] === op);
            let finalDmg = 10;
            if (op.mesh.userData.isBlocking) finalDmg *= (1.0 - SETTINGS.blockMitigation);
            const dir = new THREE.Vector3().subVectors(op.mesh.position, origin).normalize();
            const forceVec = dir.multiplyScalar(SETTINGS.pushForce);
            forceVec.y = SETTINGS.pushUpForce;
            socket.emit('playerPushed', { targetId: targetId, forceVec: forceVec, damage: finalDmg });
        }
    });
}

function checkSplashDamage(origin, radius, damage, pushBack) {
    Object.values(otherPlayers).forEach(op => {
        if (op.mesh.position.distanceTo(origin) < radius) {
            // CRITICAL: Verifica se il target è già morto o ha HP ≤ 0
            if (op.mesh.userData.isDead || (op.hp !== undefined && op.hp <= 0)) {
                console.log(`[SPLASH] Target già morto, danno ignorato`);
                return; // Salta questo target
            }
            
            const targetId = Object.keys(otherPlayers).find(key => otherPlayers[key] === op);
            let finalDmg = damage;
            if (op.mesh.userData.isBlocking) {
                finalDmg *= (1.0 - SETTINGS.blockMitigation);
                createFloatingText(op.mesh.position.clone().add(new THREE.Vector3(3, 5, 0)), "BLOCK", "#aaa");
            } else {
                createFloatingText(op.mesh.position.clone().add(new THREE.Vector3(3, 5, 0)), `-${Math.round(finalDmg)}`, "#ff3333");
            }
            if (pushBack) {
                const dir = new THREE.Vector3().subVectors(op.mesh.position, origin).normalize();
                const forceVec = dir.multiplyScalar(SETTINGS.pushForce * 0.5);
                forceVec.y = 100;
                socket.emit('playerPushed', { targetId: targetId, forceVec: forceVec, damage: finalDmg });
            } else {
                socket.emit('playerHit', {
                    damage: finalDmg,
                    targetId: targetId,
                    hitPosition: otherPlayers[targetId].mesh.position.clone()
                });
            }
        }
    });
}

function swingSword() {
    if (playerStats.stamina < SETTINGS.meleeStaminaCost) {
        addToLog("Stamina insufficiente!", "#555");
        return;
    }

    playerStats.stamina -= SETTINGS.meleeStaminaCost;
    isAttacking = true; attackTimer = 0;
    if (swordContainer.userData.trail) { swordContainer.userData.trail.material.opacity = 0.8; setTimeout(() => swordContainer.userData.trail.material.opacity = 0, 200); }
    playSound('swing_heavy');

    // Forza riavvio animazione attack del Knight
    if (weaponMode === 'melee' && knightAnimations && knightAnimations.attack) {
        if (currentKnightAction === knightAnimations.attack) {
            knightAnimations.attack.stop();
        }
        currentKnightAnimName = '';
        playKnightAnimation('attack', true);
    }

    if (socket) socket.emit('playerAttack', { type: 'melee', origin: playerMesh.position, direction: new THREE.Vector3() });

    const origin = playerMesh.position.clone();
    const forward = new THREE.Vector3(0, 0, -1).applyEuler(new THREE.Euler(0, euler.y, 0));
    Object.entries(otherPlayers).forEach(([id, p]) => {
        const dir = new THREE.Vector3().subVectors(p.mesh.position, origin);
        if (dir.length() < SETTINGS.meleeRange && forward.angleTo(dir.normalize()) < Math.PI / 2) {
            let dmg = SETTINGS.meleeDmg;
            if (p.mesh.userData.isBlocking) {
                dmg *= (1.0 - SETTINGS.blockMitigation);
                createFloatingText(p.mesh.position.clone().add(new THREE.Vector3(0, 10, 0)), "BLOCK", "#aaa");
            } else {
                createFloatingText(p.mesh.position.clone().add(new THREE.Vector3(0, 10, 0)), `-${Math.round(dmg)}`, "#ff3333");
            }
            if (socket) {
                const pushVec = new THREE.Vector3().subVectors(p.mesh.position, origin).normalize().multiplyScalar(SETTINGS.meleeKnockbackForce);
                socket.emit('playerPushed', { targetId: id, forceVec: pushVec, damage: dmg });
            }
            addToLog(`Colpito ${p.username} con Spada! -${Math.round(dmg)}`, "dmg-dealt");
        }
    });
}
