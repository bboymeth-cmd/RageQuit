// spells.js - autogenerated module from original game.js

function startCasting(spellId, type, key) {
            if (castingState.active) return;
            let castTime = 0.5; if (spellId === 1) castTime = 0.2; if (spellId === 4) castTime = 0.0;
            
            if (type === 'bow_shot') {
                castTime = SETTINGS.bowCastTime;
            } else if (type === 'attack' && spellId !== 4) {
                let cost = (spellId===1)?SETTINGS.missileCost:(spellId===2)?SETTINGS.pushCost:(spellId===3)?SETTINGS.fireballCost:SETTINGS.beamCost;
                if (playerStats.mana < cost) { addToLog("Mana insufficiente!", "#555"); return; }
            } else if (type === 'conversion') {
                const now = performance.now();
                if (now - lastConversionTime < SETTINGS.conversionCooldown) { addToLog("Ricarica...", "#aaa"); return; }
            }
            if (castTime === 0) {
                if (type === 'attack') executeAttack(spellId); else if (type === 'conversion') executeConversion(spellId); return;
            }
            castingState.active = true; castingState.timer = 0; castingState.maxTime = castTime; castingState.currentSpell = spellId; castingState.type = type; castingState.ready = false; castingState.keyHeld = key;
            document.getElementById('cast-bar-container').style.display = 'block'; document.getElementById('cast-text').innerText = "CARICAMENTO..."; document.getElementById('cast-bar-fill').className = ''; 
        }

function stopCasting(key) {
            if (!castingState.active) return;
            if (castingState.keyHeld === key) {
                if (castingState.ready) { 
                    if (castingState.type === 'attack') executeAttack(castingState.currentSpell); 
                    else if (castingState.type === 'conversion') executeConversion(castingState.currentSpell);
                    else if (castingState.type === 'bow_shot') executeAttack('bow');
                } else { addToLog("Lancio annullato", "#555"); }
                castingState.active = false; document.getElementById('cast-bar-container').style.display = 'none';
            }
        }

function updateCasting(delta) {
            if (!castingState.active) return;
            castingState.timer += delta; let progress = Math.min(1, castingState.timer / castingState.maxTime);
            document.getElementById('cast-bar-fill').style.width = (progress * 100) + '%';
            if (progress >= 1 && !castingState.ready) { castingState.ready = true; document.getElementById('cast-text').innerText = "PRONTO!"; document.getElementById('cast-bar-fill').className = 'ready'; }
        }

function selectSpell(id) { if(weaponMode !== 'ranged') { weaponMode = 'ranged'; toggleWeapon(true); } currentSpell = id; updateStaffColor(id); updateActionBarUI(); }

function performAttack() {
            if (playerStats.isDead) return;
            if (weaponMode === 'ranged') { startCasting(currentSpell, 'attack', 'Mouse'); } 
            else if (weaponMode === 'bow') { startCasting(null, 'bow_shot', 'Mouse'); }
            else { 
                if(isBlocking) return; 
                if (performance.now() - lastAttackTime < SETTINGS.meleeRate) return; 
                lastAttackTime = performance.now(); 
                swingSword(); 
            }
        }

function executeAttack(id) {
            const now = performance.now();
            
            if (id === 'bow') {
                // Arrow shot - Calculate from camera NOW
                let camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);
                const spawnPos = camera.position.clone().add(camDir.multiplyScalar(2));
                spawnProjectile(5); // 5 is Arrow ID
                if (socket) socket.emit('playerAttack', { type: 5, origin: spawnPos, direction: camDir });
                playSound('shoot_bolt'); // Reuse bolt sound
                return;
            }
            
            let cost = (id===1)?SETTINGS.missileCost:(id===2)?SETTINGS.pushCost:(id===3)?SETTINGS.fireballCost:SETTINGS.beamCost;
            if (playerStats.mana < cost) { addToLog("Mana insufficiente!", "#555"); return; }
            if (id === 4 && (now - lastSpikesTime < SETTINGS.spikesCooldown)) { addToLog("Spuntoni in ricarica...", "#aaa"); return; }
            playerStats.mana -= cost; lastAttackTime = now; isAttacking = true; attackTimer = 0;
            
            let camDir = new THREE.Vector3(); camera.getWorldDirection(camDir); let spawnPos = getStaffTip();
            if (id === 4) { lastSpikesTime = now; fireHitscan(); } else { spawnProjectile(id); if (socket) socket.emit('playerAttack', { type: id, origin: spawnPos, direction: camDir }); }
            if(id === 1) playSound('shoot_bolt'); if(id === 3) playSound('shoot_fire'); if(id === 2) playSound('shoot_bolt');
        }

function performConversion(type) {
            if (playerStats.isDead) return;
            const now = performance.now();
            if (now - lastConversionTime < SETTINGS.conversionCooldown) { addToLog("Ricarica...", "#aaa"); return; }
            
            playSound('heal'); 
            activeConversions.push({ type: type, duration: 5.0, nextTick: 1.0 }); 
            lastConversionTime = now; 
            updateUI();
            const slotId = (type === 1) ? 'slot-5' : (type === 2) ? 'slot-6' : 'slot-7'; 
            document.getElementById(slotId).classList.add('channeling'); 
            setTimeout(() => document.getElementById(slotId).classList.remove('channeling'), 5000);
            
            let color = (type === 1) ? 0xff0000 : (type === 2) ? 0x0000ff : 0xffff00;
            spawnGlowEffect(color);
            if(socket) socket.emit('playerEffect', { type: (type===1?'heal':(type===2?'mana':'stamina')) });
        }

function updateConversions(delta) {
            for (let i = activeConversions.length - 1; i >= 0; i--) {
                const conv = activeConversions[i]; conv.duration -= delta; conv.nextTick -= delta;
                if (conv.nextTick <= 0) { applyConversionTick(conv.type); conv.nextTick = 1.0; }
                if (conv.duration <= 0) activeConversions.splice(i, 1);
            }
        }

function applyConversionTick(type) {
            // Non applicare conversione se morto
            if (playerStats.isDead) return;
            
            const cost = 5; const gain = 5;
            if (type === 1) { 
                if (playerStats.stamina >= cost && playerStats.hp < playerStats.maxHp) { 
                    playerStats.stamina -= cost; 
                    playerStats.hp = Math.min(playerStats.maxHp, playerStats.hp + gain); 
                    if(socket) socket.emit('playerHealed', { amount: gain });
                } 
            } 
            else if (type === 2) { 
                if (playerStats.hp > cost && playerStats.mana < playerStats.maxMana) { 
                    playerStats.hp -= cost; playerStats.mana = Math.min(playerStats.maxMana, playerStats.mana + gain); 
                } 
            } 
            else if (type === 3) { 
                if (playerStats.mana >= cost && playerStats.stamina < playerStats.maxStamina) { 
                    playerStats.mana -= cost; playerStats.stamina = Math.min(playerStats.maxStamina, playerStats.stamina + gain); 
                } 
            }
            updateUI(); 
        }

function performHeal() {
            if (playerStats.isDead) return; const now = performance.now();
            if (now - lastHealTime < SETTINGS.healCooldown) { addToLog("Cura in cooldown", "#aaa"); return; }
            if (playerStats.mana < SETTINGS.healCost) { addToLog("Mana insufficiente", "#555"); return; }
            if (playerStats.hp >= playerStats.maxHp) return;
            playerStats.mana -= SETTINGS.healCost; 
            playerStats.hp = Math.min(playerStats.maxHp, playerStats.hp + SETTINGS.healAmount);
            if(socket) {
                socket.emit('playerHealed', { amount: SETTINGS.healAmount });
                socket.emit('playerEffect', { type: 'heal' });
            }
            lastHealTime = now; addToLog(`Curato di ${SETTINGS.healAmount} HP`, "heal"); createFloatingText(playerMesh.position.clone().add(new THREE.Vector3(0,5,0)), `+${SETTINGS.healAmount}`, '#00ff00');
            spawnGlowEffect(0x00ff00); flashScreen('green'); playSound('heal'); updateUI(); 
        }

function performWhirlwind() {
            if (playerStats.isDead || isBlocking) return;
            const now = performance.now();
            if (now - lastWhirlwindTime < SETTINGS.whirlwindCooldown) { addToLog("Whirlwind in ricarica...", "#aaa"); return; }
            if (playerStats.stamina < SETTINGS.whirlwindCost) { addToLog("Stamina insufficiente!", "#555"); return; }
            playerStats.stamina -= SETTINGS.whirlwindCost; lastWhirlwindTime = now; if (!canJump) return; velocity.y += 150; canJump = false; isWhirlwinding = true; setTimeout(() => { isWhirlwinding = false; }, 500);
            
            spawnParticles(playerMesh.position, 0xffffff, 40, 60, 0.6, false);
            
            addToLog("TURBINE ATTIVATO!", "spell-cast"); 
            playSound('whirlwind');
            
            if (socket) socket.emit('playerAttack', { type: 'whirlwind', origin: playerMesh.position, direction: new THREE.Vector3() });
            Object.values(otherPlayers).forEach((e) => {
                if (e.mesh.position.distanceTo(playerMesh.position) < SETTINGS.whirlwindRadius) {
                    let dmg = SETTINGS.whirlwindDmg;
                    if(e.mesh.userData.isBlocking) {
                        dmg *= (1.0 - SETTINGS.blockMitigation); 
                        createFloatingText(e.mesh.position.clone().add(new THREE.Vector3(0,10,0)), "BLOCK", "#aaa");
                    } else {
                        createFloatingText(e.mesh.position.clone().add(new THREE.Vector3(0,10,0)), `-${Math.round(dmg)}`, "#ff3333");
                    }
                    if (socket) socket.emit('playerHit', { 
                        damage: dmg, 
                        targetId: Object.keys(otherPlayers).find(key => otherPlayers[key] === e),
                        hitPosition: e.mesh.position.clone() // Posizione del target al momento dell'hit
                    });
                }
            });

            updateUI();
        }

function spawnStoneSpikes(target, isSticky = false) {
            const group = new THREE.Group(); const material = new THREE.MeshLambertMaterial({ color: 0x888888 }); 
            for(let i=0; i<8; i++) { 
                const height = 8 + random() * 4; const geo = new THREE.ConeGeometry(1.5, height, 6); const mesh = new THREE.Mesh(geo, material);
                const angle = random() * Math.PI * 2; const radius = 4 + random() * 2; 
                mesh.position.set(Math.cos(angle)*radius, height/2 - 2, Math.sin(angle)*radius);
                mesh.rotation.x = (random() - 0.5) * 0.8; mesh.rotation.z = (random() - 0.5) * 0.8; group.add(mesh);
            }
            if (isSticky && target) { target.add(group); group.position.set(0, 0, 0); } else { scene.add(group); group.position.copy(target instanceof THREE.Vector3 ? target : target.position); }
            setTimeout(() => { if (isSticky && target) target.remove(group); else scene.remove(group); group.children.forEach(c => { c.geometry.dispose(); }); material.dispose(); }, 1500);
        }

function fireHitscan() {
            const raycaster = new THREE.Raycaster(); raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const opponentMeshes = Object.values(otherPlayers).map(p => p.mesh);
            const intersects = raycaster.intersectObjects([...opponentMeshes, ...obstacles], true);
            if(intersects.length > 0) {
                let hitPoint = intersects[0].point; let obj = intersects[0].object; let enemyFound = null; let currentObj = obj;
                while(currentObj) { if(Object.values(otherPlayers).find(p => p.mesh === currentObj)) { enemyFound = currentObj; break; } currentObj = currentObj.parent; }
                if(enemyFound) {
                    spawnStoneSpikes(enemyFound, true); 
                    const hitId = Object.keys(otherPlayers).find(key => otherPlayers[key].mesh === enemyFound);
                    if(hitId && socket) {
                        let dmg = SETTINGS.beamDmg; 
                        if(otherPlayers[hitId].mesh.userData.isBlocking) {
                            dmg *= (1.0 - SETTINGS.blockMitigation); 
                            createFloatingText(enemyFound.position.clone().add(new THREE.Vector3(0,10,0)), "BLOCK", "#aaa");
                        } else {
                            createFloatingText(enemyFound.position.clone().add(new THREE.Vector3(0,10,0)), `-${Math.round(dmg)}`, "#ff3333");
                        }
                        socket.emit('playerHit', { 
                            damage: dmg, 
                            targetId: hitId,
                            hitPosition: otherPlayers[hitId].mesh.position.clone()
                        }); 
                        socket.emit('playerAttack', { type: 'spikes', origin: new THREE.Vector3(), direction: new THREE.Vector3(), targetId: hitId });
                    }
                    addToLog("Spuntoni di Pietra colpiti!", "spell-cast"); playSound('hit');
                } else { 
                    spawnStoneSpikes(hitPoint, false); 
                    if (socket) socket.emit('playerAttack', { type: 'spikes', origin: hitPoint, direction: new THREE.Vector3() });
                }
            }
            playSound('shoot_fire');
        }

function spawnProjectile(type) {
            // Controllo stamina per arco
            if (type === 5 && playerStats.stamina < SETTINGS.arrowCost) {
                addToLog("Stamina insufficiente!", "#555");
                return;
            }
            
            if (type === 5) {
                playerStats.stamina -= SETTINGS.arrowCost;
            }
            
            let geo, speed, color, radius;
            if (type === 1) { geo = new THREE.SphereGeometry(1.0); color = 0x00ffff; speed = SETTINGS.missileSpeed; radius = 1.0; } 
            else if (type === 2) { geo = new THREE.SphereGeometry(1.8); color = 0xffffff; speed = SETTINGS.pushSpeed; radius = 1.8; } 
            else if (type === 3) { geo = new THREE.SphereGeometry(3.0); color = 0xff6600; speed = SETTINGS.fireballSpeed; radius = 3.0; }
            else if (type === 5) { 
                geo = new THREE.CylinderGeometry(0.1, 0.1, 4); 
                // RUOTA LA GEOMETRIA PER ALLINEARLA ALL'ASSE Z (Orizzontale)
                geo.rotateX(-Math.PI / 2); 
                color = 0x8B4513; speed = SETTINGS.arrowSpeed; radius = 0.5; 
            } 
            
            const proj = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: color }));
            
            let spawnPos;
            if(type === 5 && weaponMode === 'bow') {
                 const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);
                 spawnPos = camera.position.clone().add(camDir.multiplyScalar(2));
            } else {
                 spawnPos = getStaffTip();
            }

            const raycaster = new THREE.Raycaster(); raycaster.setFromCamera(new THREE.Vector2(0, 0), camera); 
            const hits = raycaster.intersectObjects([...obstacles], true);
            let targetPoint;
            if(hits.length > 0) { targetPoint = hits[0].point; } else { const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir); targetPoint = camera.position.clone().add(camDir.multiplyScalar(100)); }
            
            const velocityDir = new THREE.Vector3().subVectors(targetPoint, spawnPos).normalize();
            proj.position.copy(spawnPos);
            
            if(type === 5) proj.lookAt(targetPoint);
            else { const light = new THREE.PointLight(color, 1, 30); proj.add(light); }

            proj.userData = { velocity: velocityDir.multiplyScalar(speed), life: (type===5 ? 5.0 : 2.0), type: type, isMine: true, radius: radius };
            scene.add(proj); projectiles.push(proj);
        }

function spawnEnemyProjectile(startPos, direction, type) {
            let color = 0xff0000; let speed = 900; let radius = 1.0;
            let geo;
            if (type === 1) { geo = new THREE.SphereGeometry(1.0); color = 0x00ffff; speed = SETTINGS.missileSpeed; radius = 1.0; } 
            else if (type === 2) { geo = new THREE.SphereGeometry(1.8); color = 0xffffff; speed = SETTINGS.pushSpeed; radius = 1.8; } 
            else if (type === 3) { geo = new THREE.SphereGeometry(3.0); color = 0xff6600; speed = SETTINGS.fireballSpeed; radius = 3.0; }
            else if (type === 5) { 
                geo = new THREE.CylinderGeometry(0.1, 0.1, 4); 
                geo.rotateX(-Math.PI / 2); 
                color = 0x8B4513; speed = SETTINGS.arrowSpeed; radius = 0.5; 
            }
            
            const proj = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: color }));
            proj.position.copy(startPos);
            const dirVec = new THREE.Vector3(direction.x, direction.y, direction.z).normalize();
            
            if(type === 5) {
                proj.lookAt(proj.position.clone().add(dirVec));
            } else {
                const light = new THREE.PointLight(color, 1, 20); proj.add(light);
            }

            proj.userData = { velocity: dirVec.multiplyScalar(speed), life: (type===5 ? 5.0 : 3.0), type: type, isMine: false, radius: radius };
            scene.add(proj); projectiles.push(proj); playSound(type === 3 ? 'shoot_fire' : 'shoot_bolt');
        }

function updateProjectiles(delta) {
            const opponentMeshes = Object.values(otherPlayers).map(p => p.mesh);
            
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i]; 
                const move = p.userData.velocity.clone().multiplyScalar(delta);
                
                if (move.lengthSq() < 0.000001) continue; 

                const nextPos = p.position.clone().add(move);
                let hit = false, hitPoint = p.position.clone();
                let hitTarget = null;
                
                if (p.userData.isMine) {
                    // Controlla collisione con altri giocatori
                    Object.values(otherPlayers).forEach(op => {
                        const dx = p.position.x - op.mesh.position.x;
                        const dz = p.position.z - op.mesh.position.z;
                        const distXZ = Math.sqrt(dx*dx + dz*dz);
                        const dy = p.position.y - op.mesh.position.y;
                        if (distXZ < 8.0 && dy > 0 && dy < 15.0) {
                            hit = true; hitTarget = op.mesh; hitPoint = p.position.clone();
                        }
                    });
                    
                    // Controlla collisione con il mostro IA
                    if (!hit && isPvEMode && aiMonster && aiMonster.state !== 'dead') {
                        const dx = p.position.x - aiMonster.mesh.position.x;
                        const dz = p.position.z - aiMonster.mesh.position.z;
                        const distXZ = Math.sqrt(dx*dx + dz*dz);
                        const dy = p.position.y - aiMonster.mesh.position.y;
                        if (distXZ < 10.0 && dy > 0 && dy < 20.0) {
                            hit = true; 
                            hitTarget = aiMonster.mesh;
                            hitPoint = p.position.clone();
                        }
                    }

                    if (!hit) {
                        obstacleRaycaster.set(p.position, p.userData.velocity.clone().normalize());
                        obstacleRaycaster.far = move.length() + 0.1;
                        const intersects = obstacleRaycaster.intersectObjects([...obstacles], true);
                        if (intersects.length > 0) { hit = true; hitPoint = intersects[0].point; }
                    }
                        
                    if (hitTarget) {
                        let dmg = 0;
                        if (p.userData.type === 1) dmg = SETTINGS.missileDmg; 
                        else if (p.userData.type === 3) dmg = SETTINGS.fireballDmg;
                        else if (p.userData.type === 2) dmg = 10;
                        else if (p.userData.type === 5) dmg = SETTINGS.arrowDmg; 

                        // Controlla se il bersaglio Ã¨ un giocatore o il mostro IA
                        const targetId = Object.keys(otherPlayers).find(key => otherPlayers[key].mesh === hitTarget);
                        const isMonsterTarget = hitTarget === aiMonster?.mesh;
                        
                        if (isMonsterTarget) {
                            // Colpito il mostro IA
                            damageAIMonster(dmg);
                            createFloatingText(hitTarget.position.clone().add(new THREE.Vector3(0, 15, 0)), `-${dmg}`, "#ff9999");
                            addToLog(`Colpito il mostro per ${dmg} danni!`, "dmg-dealt");
                        } else if (targetId) {
                            // Colpito un altro giocatore
                            let mitigatedDmg = dmg;
                            if(otherPlayers[targetId].mesh.userData.isBlocking) {
                                 mitigatedDmg *= (1.0 - SETTINGS.blockMitigation); 
                                 createFloatingText(hitTarget.position.clone().add(new THREE.Vector3(0,10,0)), "BLOCK", "#aaa");
                            } else {
                                 createFloatingText(hitTarget.position.clone().add(new THREE.Vector3(0,10,0)), `-${Math.round(mitigatedDmg)}`, "#ff3333");
                            }

                            if (socket) {
                                if (p.userData.type === 2) { 
                                    spawnExplosionVisual(hitPoint, 0xffffff, SETTINGS.pushVisualRadius);
                                    checkShockwaveAoE(hitPoint);
                                } else if (p.userData.type === 3) { 
                                    spawnExplosionVisual(hitPoint, 0xff4500, SETTINGS.fireballRadius); 
                                    socket.emit('playerPushed', { targetId: targetId, forceY: SETTINGS.fireballUpForce, damage: mitigatedDmg });
                                    checkSplashDamage(hitPoint, SETTINGS.fireballRadius, 5, false);
                                    addToLog(`Colpito ${otherPlayers[targetId].username} con Palla di Fuoco!`, "dmg-dealt");
                                } else { 
                                    socket.emit('playerHit', { 
                                        damage: mitigatedDmg, 
                                        targetId: targetId,
                                        hitPosition: otherPlayers[targetId].mesh.position.clone()
                                    });
                                }
                            }
                        }
                    }
                } 
                else {
                    const dx = p.position.x - playerMesh.position.x;
                    const dz = p.position.z - playerMesh.position.z;
                    const distXZ = Math.sqrt(dx*dx + dz*dz);
                    const dy = p.position.y - playerMesh.position.y;
                    if (distXZ < 8.0 && dy > 0 && dy < 15.0) {
                         hit = true; hitPoint = playerMesh.position;
                         playSound('hit');
                    }
                }

                if(!hit && nextPos.y <= 0) { 
                    hit=true; hitPoint.y = 0; p.position.y = 0;
                    if (p.userData.isMine) {
                        if (p.userData.type === 2) {
                            spawnExplosionVisual(hitPoint, 0xffffff, SETTINGS.pushVisualRadius); 
                            checkShockwaveAoE(hitPoint);
                        } else if (p.userData.type === 3) { 
                            spawnExplosionVisual(hitPoint, 0xff4500, SETTINGS.fireballRadius); 
                            checkSplashDamage(hitPoint, SETTINGS.fireballRadius, 5, false);
                        }
                    }
                }
                
                if (hit) { 
                    if(p.userData.type !== 2 && p.userData.type !== 5) spawnExplosionVisual(hitPoint, p.material.color.getHex(), p.userData.type === 3 ? SETTINGS.fireballRadius : 5); 
                    scene.remove(p); projectiles.splice(i, 1); 
                } else { 
                    p.position.add(move); p.userData.life -= delta; 
                    
                    let gravity = SETTINGS.gravity;
                    if (p.userData.type === 5) gravity = SETTINGS.arrowGravity; // Freccia
                    else if (p.userData.type === 1) gravity = SETTINGS.missileGravity; // Dardo
                    p.userData.velocity.y -= gravity * delta;
                    
                    if (p.userData.type === 5) p.lookAt(p.position.clone().add(p.userData.velocity)); 
                    if (p.userData.life <= 0) { scene.remove(p); projectiles.splice(i, 1); }
                }
            }
        }

function checkShockwaveAoE(origin) {
            const distToMe = playerMesh.position.distanceTo(origin);
            if (distToMe < SETTINGS.pushRadius) {
                const dir = new THREE.Vector3().subVectors(playerMesh.position, origin).normalize();
                const forceVec = dir.multiplyScalar(SETTINGS.pushForce);
                velocity.add(forceVec);
                velocity.y += SETTINGS.pushUpForce;
                canJump = false; playerStats.isFalling = true; playerMesh.position.y += 0.5;
                addToLog("Sbalzato dall'onda!", "spell-cast"); playSound('jump');
            }

            Object.values(otherPlayers).forEach(op => {
                const distToEnemy = op.mesh.position.distanceTo(origin);
                if (distToEnemy < SETTINGS.pushRadius) {
                    const targetId = Object.keys(otherPlayers).find(key => otherPlayers[key] === op);
                    let finalDmg = 10; 
                    if(op.mesh.userData.isBlocking) finalDmg *= (1.0 - SETTINGS.blockMitigation); 
                    const dir = new THREE.Vector3().subVectors(op.mesh.position, origin).normalize();
                    const forceVec = dir.multiplyScalar(SETTINGS.pushForce);
                    forceVec.y = SETTINGS.pushUpForce; 
                    socket.emit('playerPushed', { targetId: targetId, forceVec: forceVec, damage: finalDmg });
                }
            });
        }

function checkSplashDamage(origin, radius, damage, pushBack) {
            Object.values(otherPlayers).forEach(op => {
                if (op.mesh.position.distanceTo(origin) < radius) {
                    const targetId = Object.keys(otherPlayers).find(key => otherPlayers[key] === op);
                    let finalDmg = damage;
                    if(op.mesh.userData.isBlocking) {
                        finalDmg *= (1.0 - SETTINGS.blockMitigation); 
                        createFloatingText(op.mesh.position.clone().add(new THREE.Vector3(3,5,0)), "BLOCK", "#aaa");
                    } else {
                        createFloatingText(op.mesh.position.clone().add(new THREE.Vector3(3,5,0)), `-${Math.round(finalDmg)}`, "#ff3333");
                    }
                    if (pushBack) {
                         const dir = new THREE.Vector3().subVectors(op.mesh.position, origin).normalize();
                         const forceVec = dir.multiplyScalar(SETTINGS.pushForce * 0.5); 
                         forceVec.y = 100;
                         socket.emit('playerPushed', { targetId: targetId, forceVec: forceVec, damage: finalDmg });
                    } else {
                         socket.emit('playerHit', { 
                             damage: finalDmg, 
                             targetId: targetId,
                             hitPosition: otherPlayers[targetId].mesh.position.clone()
                         });
                    }
                }
            });
        }

function swingSword() {
            if (playerStats.stamina < SETTINGS.meleeStaminaCost) {
                addToLog("Stamina insufficiente!", "#555");
                return;
            }
            
            playerStats.stamina -= SETTINGS.meleeStaminaCost;
            isAttacking = true; attackTimer = 0;
            if(swordContainer.userData.trail) { swordContainer.userData.trail.material.opacity = 0.8; setTimeout(() => swordContainer.userData.trail.material.opacity = 0, 200); }
            playSound('swing_heavy');
            
            if (socket) socket.emit('playerAttack', { type: 'melee', origin: playerMesh.position, direction: new THREE.Vector3() });
            
            const origin = playerMesh.position.clone(); 
            const forward = new THREE.Vector3(0,0,-1).applyEuler(new THREE.Euler(0,euler.y,0));
            Object.entries(otherPlayers).forEach(([id, p]) => {
                const dir = new THREE.Vector3().subVectors(p.mesh.position, origin);
                if (dir.length() < SETTINGS.meleeRange && forward.angleTo(dir.normalize()) < Math.PI/2) {
                    let dmg = SETTINGS.meleeDmg;
                    if(p.mesh.userData.isBlocking) {
                        dmg *= (1.0 - SETTINGS.blockMitigation); 
                        createFloatingText(p.mesh.position.clone().add(new THREE.Vector3(0,10,0)), "BLOCK", "#aaa");
                    } else {
                        createFloatingText(p.mesh.position.clone().add(new THREE.Vector3(0,10,0)), `-${Math.round(dmg)}`, "#ff3333");
                    }
                    if (socket) {
                        const pushVec = new THREE.Vector3().subVectors(p.mesh.position, origin).normalize().multiplyScalar(SETTINGS.meleeKnockbackForce);
                         socket.emit('playerPushed', { targetId: id, forceVec: pushVec, damage: dmg });
                    }
                    addToLog(`Colpito ${p.username} con Spada! -${Math.round(dmg)}`, "dmg-dealt");
                }
            });
        }

